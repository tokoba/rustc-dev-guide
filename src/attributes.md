# 属性

属性には 2 つのタイプがあります：*inert*（または *built-in*）と *active*（*non-builtin*）。

## ビルトイン/inert 属性

これらの属性はコンパイラ自体で定義されており、
[`compiler/rustc_feature/src/builtin_attrs.rs`][builtin_attrs] にあります。

例としては `#[allow]` と `#[macro_use]` があります。

[builtin_attrs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_feature/builtin_attrs/index.html

これらの属性にはいくつかの重要な特徴があります：
* 常にスコープ内にあり、典型的なパスベースの解決には参加しません。
* 名前を変更できません。たとえば、`use allow as foo` はコンパイルされますが、`#[foo]` を書くと
  エラーが発生します。
* 'inert' であり、マクロ展開コードによってそのまま残されます。
  その結果、動作はコンパイラがそれらの存在を明示的にチェックすることによって生じます。
  たとえば、lint 関連のコードは `#[allow]`、`#[warn]`、`#[deny]`、
  `#[forbid]` を明示的にチェックします。属性自体の展開から動作が生じるのではありません。

## '非ビルトイン'/'アクティブ' 属性

これらの属性はクレート（標準ライブラリまたは proc-macro クレート）によって定義されます。

**重要**：`#[derive]` などの多くの非ビルトイン属性は、依然としてコア Rust 言語の一部と見なされます。ただし、標準ライブラリに対応する定義があるため、'ビルトイン属性' とは**呼ばれません**。

非ビルトイン属性の定義には 2 つの形式があります：

1. Proc-macro 属性。proc-macro クレート内の `#[proc_macro_attribute]` で注釈された関数によって定義されます。
2. AST ベースの属性。標準ライブラリで定義されます。これらの属性には、[`library/core/src/macros/mod.rs`][core_macros] のような場所で定義された特別な 'スタブ' マクロがあります。

[core_macros]:  https://github.com/rust-lang/rust/blob/HEAD/library/core/src/macros/mod.rs

これらの定義は、マクロが典型的なパスベースの解決に参加できるようにするために存在します。他のアイテム定義と同様にインポート、再エクスポート、名前変更できます。ただし、定義の本体は空です。代わりに、マクロは `#[rustc_builtin_macro]` 属性で注釈されており、これはコンパイラに `rustc_builtin_macros` 内の対応する関数を実行するよう指示します。

すべての非ビルトイン属性には以下の特徴があります：
* 他のすべての定義（例：構造体）と同様に、インポートを介してスコープに入れる必要があります。
  多くの標準ライブラリ属性がプリュードに含まれています。これが `#[derive]` を
  インポートなしで書ける理由です。
* マクロ展開に参加します。マクロの実装は、属性ターゲットを変更せずに残したり、ターゲットを変更したり、
  新しい AST ノードを生成したり、ターゲットを完全に削除したりできます。
