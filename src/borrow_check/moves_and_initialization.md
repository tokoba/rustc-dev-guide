# 移動と初期化の追跡

borrow checker の仕事の一部は、任意の時点でどの変数が「初期化されている」かを追跡することです -- これには、移動が発生する場所を把握し、それらを追跡することも必要です。

## 初期化と移動

ユーザーの視点からは、初期化 -- 変数に値を与えること -- と移動 -- 所有権を別の場所に転送すること -- は異なるトピックに見えるかもしれません。実際、borrow checker のエラーメッセージは、それらについて異なる言い方をすることがよくあります。しかし、**borrow checker 内部**では、それらはほとんど分離されていません。大まかに言えば、borrow checker はソースコードの任意の時点で「初期化された場所」のセットを追跡します。以前に初期化されていないローカル変数に代入すると、そのセットに追加されます; ローカル変数から移動すると、そのセットから削除されます。

次の例を考えてみましょう:

```rust,ignore
fn foo() {
    let a: Vec<u32>;

    // a はまだ初期化されていません

    a = vec![22];

    // a はここで初期化されています

    std::mem::drop(a); // a はここで移動されます

    // a はここではもう初期化されていません

    let l = a.len(); //~ ERROR
}
```

ここでは、`a` が初期化されていない状態から始まることがわかります; 代入されると、初期化されます。しかし、`drop(a)` が呼び出されると、それは `a` を呼び出しに移動するため、再び初期化されていない状態になります。

## サブセクション

見やすくするために、このセクションはいくつかのサブセクションに分かれています:

- [Move paths](./moves_and_initialization/move_paths.html) 初期化されているローカル変数（または場合によってはローカル変数の一部）を追跡するために使用する*move path*の概念。
- TODO *残りはまだ書かれていません* =)
