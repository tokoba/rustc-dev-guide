# メンバー制約

メンバー制約 `'m member of ['c_1..'c_N]` は、領域 `'m` が何らかの**選択領域** `'c_i`（いくつかの `i` について）と*等しく*なければならないことを表現します。これらの制約はユーザーによって表現することはできませんが、ライフタイムキャプチャルールのため、`impl Trait` から生じます。次のような関数を考えてみましょう:

```rust,ignore
fn make(a: &'a u32, b: &'b u32) -> impl Trait<'a, 'b> { .. }
```

ここで、真の戻り値型（しばしば「隠れた型」と呼ばれる）は、ライフタイム `'a` または `'b` のみをキャプチャすることが許可されます。`impl Trait` 戻り値型をより明示的な形式に脱糖することで、これをより明確に見ることができます:

```rust,ignore
type MakeReturn<'x, 'y> = impl Trait<'x, 'y>;
fn make(a: &'a u32, b: &'b u32) -> MakeReturn<'a, 'b> { .. }
```

ここでのアイデアは、隠れた型は `impl Trait<'x, 'y>` の代わりに書かれた可能性のある型でなければならないということです -- しかし、そのような型はスコープ内にある名前である領域 `'x` または `'y`（または `'static`!）のみを参照できることは明らかです。この制限は、`'a` または `'b` のみにアクセスする制限に変換されます。なぜなら、`MakeReturn<'a, 'b>` を返しているため、`'x` と `'y` がそれぞれ `'a` と `'b` に置き換えられているからです。

## 詳細な例

メンバー制約をより詳細に説明するために、`make` の例をもう少し詳しく説明しましょう。まず、いくつかのダミートレイトがあると仮定します:

```rust,ignore
trait Trait<'a, 'b> { }
impl<T> Trait<'_, '_> for T { }
```

そして、これが `make` 関数です（脱糖形式）:

```rust,ignore
type MakeReturn<'x, 'y> = impl Trait<'x, 'y>;
fn make(a: &'a u32, b: &'b u32) -> MakeReturn<'a, 'b> {
  (a, b)
}
```

この場合に起こることは、戻り値型が `(&'0 u32, &'1 u32)` になることです。ここで、`'0` と `'1` は新しい領域変数です。次の領域制約があります:

```txt
'0 live at {L}
'1 live at {L}
'a: '0
'b: '1
'0 member of ['a, 'b, 'static]
'1 member of ['a, 'b, 'static]
```

ここで、「生存性セット」`{L}` は、`'0` と `'1` が生きている本体のサブセットに対応します -- 基本的に、戻りタプルが構築されてから返されるまでのポイントです（実際には、`'0` と `'1` は若干異なる生存性セットを持つ可能性がありますが、ここで説明しているポイントにはあまり興味深くありません）。

`'a: '0` と `'b: '1` 制約はサブタイピングから生じます。`(a, b)` 値を構築するとき、型 `(&'0 u32, &'1 u32)` が割り当てられます -- 領域変数は、これらの参照のライフタイムが小さくなる可能性があることを反映しています。この値が `a` と `b` から作成されるためには、次のことが必要です:

```txt
(&'a u32, &'b u32) <: (&'0 u32, &'1 u32)
```

これは、`&'a u32 <: &'0 u32` したがって `'a: '0` を意味します（同様に `&'b u32 <: &'1 u32`、`'b: '1`）。

メンバー制約を無視すると、`'0` の値は生存性制約から関数本体のサブセットに推論されることに注意してください（これは明示的に書きませんでした）。`'a: '0` という制約があるだけで、`'0` がどれだけ*大きく*なることができるかについての「上限」を置くだけなので、`'a` になることはありません。*最小*の値を計算するので、`'0` を生存性セットと等しいままにしておくことで満足です。ここでメンバー制約が登場します。

## 選択は常にライフタイムパラメータです

現在、メンバー制約からの「選択」領域は常に現在の関数からのライフタイムパラメータです。<!-- date-check --> 2021 年 10 月の時点で、これは impl Trait の配置から生じますが、将来的にはそうではないかもしれません。現在のコードを単純化するため、この事実をある程度利用しています。特に、`'0 member of ['1, 'static]` のようなケースを考慮する必要はありません。ここで、`'0` と `'1` の両方の値が推論され、変化しています。詳細については、[rust-lang/rust#61773][#61773] を参照してください。

[#61773]: https://github.com/rust-lang/rust/issues/61773

## メンバー制約の適用

メンバー制約は他の形式の制約よりも少し複雑です。これは、それらに「または」の性質があるためです -- つまり、選択する必要がある複数の選択肢を記述しています。例えば、例の制約 `'0 member of ['a, 'b, 'static]` では、`'0` は `'a`、`'b`、*または* `'static` と等しい可能性があります。正しいものをどのように選択できますか？現在行っていることは、*最小の選択*を探すことです -- 見つかった場合、`'0` をその最小の選択と等しくなるように拡大します。その最小の選択を見つけるために、2 つの要素を考慮に入れます: 下限と上限。

### 下限

*下限*は、`'0` が*生存しなければならない*ライフタイム -- つまり、`'0` がより大きくなければならないライフタイムです。実際、メンバー制約を適用する時点で、`'0` の下限を既に*計算*しています。なぜなら、その最小値を計算したからです（または少なくとも、メンバー制約以外のすべてを考慮した下限）。

`LB` を `'0` の現在の値とします。`'0` の最終値が何であれ、`'0: LB` が成立しなければならないことがわかります。したがって、`'choice: LB` が成立しない選択 `'choice` を除外できます。

残念ながら、この例では、これはあまり役に立ちません。`'0` の下限は生存性セット `{L}` だけで、すべてのライフタイムパラメータがそのセットを生存することがわかっています。したがって、ここでは同じ選択肢のセットが残ります。（しかし、他の例、特に異なる分散を持つ例では、下限制約が関連する可能性があります。）

### 上限

*上限*は、`'0` を*生存しなければならない*ライフタイム -- つまり、`'0` が*小さく*なければならないライフタイムです。この例では、`'a: '0` という制約があるため、これは `'a` になります。より複雑な例では、チェーンはより間接的である可能性があります。

下限と非常に似た方法で上限を使用して、メンバーを除外できます。UB がある上限である場合、`UB: '0` が成立しなければならないことがわかっているため、`UB: 'choice` が成立しない選択 `'choice` を除外できます。

この例では、選択セットを `['a, 'b, 'static]` から `['a]` だけに減らすことができます。これは、`'0` の上限が `'a` であり、`'a: 'b` も `'a: 'static` も成立することが知られていないためです。

（実装で上限を収集する方法に関する注意事項については、[以下のセクション](#collecting) を参照してください。）

### 最小の選択

下限と上限を適用した後も、複数の可能性が残っている場合があります。例えば、反対の分散を持つ型を使用した例のバリアントを想像してください。その場合、`'a: '0` の代わりに制約 `'0: 'a` があります。したがって、`'0` の現在の値は `{L, 'a}` になります。これを下限として使用すると、メンバーの選択肢を `['a, 'static]` に絞り込むことができます。なぜなら、`'b: 'a` が成立することは知られていないからです（しかし、`'a: 'a` と `'static: 'a` は成立します）。上限はないため、それが最終的な選択肢のセットになります。

その場合、**最小の選択**ルールを適用します -- 基本的に、選択肢の 1 つが他のものより小さい場合、それを使用できます。この場合、`'a`（`'static` ではなく）を選択します。

この選択は、常に推論される領域の最小値を計算することを目指す領域伝播の一般的な「フロー」と一致しています。ただし、それは多少恣意的です。

<a id="collecting"></a>

### 実装での上限の収集

実際には、上限を計算するのは少し不便です。なぜなら、データ構造が反対に設定されているためです。行うことは、**逆 SCC グラフ**を計算することです（これを遅延的に行い、結果をキャッシュします） -- つまり、`'a: 'b` がエッジ `SCC('b) -> SCC('a)` を誘導するグラフです。通常の SCC グラフと同様に、これは DAG です。次に、このグラフで `SCC('0)` から開始して深さ優先検索を実行できます。これにより、`'0` を生存しなければならないすべての SCC に移動します。

1 つのしわは、「上限」SCC を歩くとき、それらの値はまだ完全に計算されていないことです。ただし、生存性制約を**既に**適用しているため、その値に関するいくつかの情報があります。特に、ライフタイムパラメータを表す領域については、その値は自分自身を含みます（つまり、`'a` の初期値は `'a` を含み、`'b` の値は `'b` を含みます）。したがって、到達可能なすべてのライフタイムパラメータを収集できます。これは、まさに関心のあるものです。
