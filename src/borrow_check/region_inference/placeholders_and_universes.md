# プレースホルダーとユニバース

時々、具体的にはわからない領域について推論しなければならないことがあります。例えば、次のプログラムを考えてみましょう:

```rust,ignore
// static 参照を必要とする関数
fn foo(x: &'static u32) { }

fn bar(f: for<'a> fn(&'a u32)) {
       // ^^^^^^^^^^^^^^^^^^^ **任意の**参照を受け入れることができる関数
    let x = 22;
    f(&x);
}

fn main() {
    bar(foo);
}
```

このプログラムは型チェックに合格すべきではありません: `foo` はその引数に static 参照を必要としますが、`bar` は**任意の**参照を受け入れる関数を与えられることを望んでいます（したがって、例えばスタック上の何かでそれを呼び出すことができます）。しかし、*どのように*それを拒否し、*なぜ*拒否するのでしょうか？

## サブタイピングとプレースホルダー

`main` を型チェックするとき、特に呼び出し `bar(foo)` では、次のようなサブタイピング関係になります:

```text
fn(&'static u32) <: for<'a> fn(&'a u32)
----------------    -------------------
`foo` の型          `bar` が期待する型
```

この種のサブタイピングを処理するには、スーパータイプで束縛されている変数を取り、それらを[全称量化された](../../appendix/background.md#quantified)代表で置き換えます。ここでは `!1` のように表記されます。これらの領域を「プレースホルダー領域」と呼びます -- 基本的に「いくつかの未知の領域」を表します。

その置き換えを行うと、次の関係が得られます:

```text
fn(&'static u32) <: fn(&'!1 u32)
```

ここでの重要なアイデアは、この未知の領域 `'!1` は他の領域と関連していないということです。したがって、サブタイピング関係が `'!1` に対して真であることを証明できれば、それは任意の領域に対して真であるはずで、それが私たちが望んでいたことです。

では、次に何が起こるかを見ていきましょう。2 つの関数がサブタイプであるかどうかをチェックするには、引数が望ましい関係を持っているかどうかをチェックします（fn 引数は[反変](../../appendix/background.md#variance)なので、ここでは左と右を入れ替えます）:

```text
&'!1 u32 <: &'static u32
```

参照の基本的なサブタイピングルールによれば、これは `'!1: 'static` の場合に真になります。つまり -- 「いくつかの未知の領域 `!1`」が `'static` より長く生存する場合。これは*真である可能性があります* -- 結局のところ、`'!1` は `'static` である可能性があります -- しかし、それが真であることを*知りません*。したがって、これはエラーを生じるべきです（最終的に）。

## ユニバースとは何ですか？

前のセクションで、プレースホルダー領域のアイデアを紹介し、それを `!1` と表記しました。この数字 `1` を**ユニバースインデックス**と呼びます。「ユニバース」のアイデアは、それがある型内またはあるポイントでスコープ内にある名前のセットであるということです。ユニバースはツリーに形成され、各子は親をいくつかの新しい名前で拡張します。したがって、**ルートユニバース**は概念的にグローバルな名前を含みます。例えば、ライフタイム `'static` や型 `i32` などです。コンパイラでは、ジェネリック型パラメータもこのルートユニバースに入れます（この意味で、ルートユニバースは 1 つだけではなく、アイテムごとに 1 つあります）。したがって、この関数 `bar` を考えてみましょう:

```rust,ignore
struct Foo { }

fn bar<'a, T>(t: &'a T) {
    ...
}
```

ここで、ルートユニバースはライフタイム `'static` と `'a` で構成されます。実際、ここではライフタイムに焦点を当てていますが、型にも同じ概念を適用できます。その場合、型 `Foo` と `T` はルートユニバースに入ります（`i32` のような他のグローバル型と一緒に）。基本的に、ルートユニバースには `bar` の本体で[自由に現れる](../../appendix/background.md#free-vs-bound)すべての名前が含まれます。

では、変数 `x` を追加して `bar` を少し拡張しましょう:

```rust,ignore
fn bar<'a, T>(t: &'a T) {
    let x: for<'b> fn(&'b u32) = ...;
}
```

ここで、名前 `'b` はルートユニバースの一部ではありません。代わりに、この `for<'b>` に「入る」とき（例えば、プレースホルダーで置き換えることによって）、ルートの子ユニバースを作成します。それを U1 と呼びましょう:

```text
U0 (ルートユニバース)
│
└─ U1 (子ユニバース)
```

アイデアは、この子ユニバース U1 がルートユニバース U0 を新しい名前で拡張するということです。これをユニバース番号で識別しています: `!1`。

では、もう 1 つの変数 `y` を追加して `bar` をさらに拡張しましょう:

```rust,ignore
fn bar<'a, T>(t: &'a T) {
    let x: for<'b> fn(&'b u32) = ...;
    let y: for<'c> fn(&'c u32) = ...;
}
```

*この*型に入ると、再び新しいユニバースを作成します。それを `U2` と呼びます。その親はルートユニバースになり、U1 はその兄弟になります:

```text
U0 (ルートユニバース)
│
├─ U1 (子ユニバース)
│
└─ U2 (子ユニバース)
```

これは、U2 にいる間、U0 または U2 からのものに名前を付けることができますが、U1 からは付けることができないことを意味します。

**存在変数にユニバースを与える。** ユニバースの概念ができたので、それを使用して型チェッカーなどを拡張し、不正な名前が漏れるのを防ぐことができます。アイデアは、各推論（存在）変数 -- 型またはライフタイムのいずれか -- にユニバースを与えることです。その変数の値は、そのユニバースから見える名前のみを参照できます。したがって、例えばライフタイム変数が U0 で作成された場合、`!1` または `!2` の値を割り当てることはできません。なぜなら、それらの名前はユニバース U0 から見えないからです。

**ユニバースをカウンターだけで表現する。** コンパイラがユニバースの完全なツリーを追跡していないことに驚くかもしれません。代わりに、カウンターを保持するだけです -- そして、あるユニバースが別のユニバースを見ることができるかどうかを判断するために、インデックスが大きいかどうかをチェックするだけです。例えば、U2 は U0 を見ることができます。なぜなら、2 >= 0 だからです。しかし、U0 は U2 を見ることができません。なぜなら、0 >= 2 は false だからです。

どうしてこれで済むのでしょうか？これは U2 が U1 も見ることを許可することを意味しないのでしょうか？答えは、はい、許可します。**その質問が生じた場合**。しかし、型チェッカーなどの構造のため、それが起こる方法はありません。ユニバース U1 で起こっている何かがユニバース U2 で起こっている何かと「通信」するためには、共通の推論変数 X を持っている必要があります。そして、U1 のすべてのものは U1 とその子だけにスコープされているため、その推論変数 X は U0 にある必要があります。そして、X は U0 にあるため、U1（または U2）から何も名前を付けることができません。これは、一種の汎用的な「論理」の例を使用することで最も簡単にわかります:

```text
exists<X> {
   forall<Y> { ... /* Y is in U1 ... */ }
   forall<Z> { ... /* Z is in U2 ... */ }
}
```

ここで、2 つの forall が相互作用する唯一の方法は X を介してですが、Y も Z も X が宣言されたときにスコープ内にないため、その値はどちらも参照できません。

## ユニバースとプレースホルダー領域要素

しかし、そのエラーはどこから来るのでしょうか？それが起こる方法は次のとおりです。領域推論コンテキストを構築するとき、型推論コンテキストからプレースホルダー変数がいくつ存在するかを知ることができます（`InferCtxt` には内部カウンターがあります）。それぞれについて、対応する全称領域変数 `!n` と「領域要素」`placeholder(n)` を作成します。これは「他の要素の未知のセット」に対応します。`!n` の値は `{placeholder(n)}` です。

同時に、各存在変数にも**ユニバース**（`InferCtxt` からも取得）を与えます。このユニバースは、その値にどのプレースホルダー要素が現れる可能性があるかを決定します: 例えば、ユニバース U3 の変数は `placeholder(1)`、`placeholder(2)`、および `placeholder(3)` に名前を付けることができますが、`placeholder(4)` には付けることができません。推論変数のユニバースは、その値に領域要素が**現れることができる**ものを制御することに注意してください; 領域要素が**現れる**とは言っていません。

## プレースホルダーと outlives 制約

領域推論エンジンでは、outlives 制約は次の形式を持ちます:

```text
V1: V2 @ P
```

ここで、`V1` と `V2` は領域インデックスであり、したがってある領域変数（全称的または存在的に量化される可能性があります）にマップされます。ここでの `P` は制御フローグラフの「ポイント」です; このセクションでは重要ではありません。この変数にはユニバースがあるため、それらのユニバースを `U(V1)` と `U(V2)` とそれぞれ呼びましょう。（実際、気にするのは `U(V1)` だけです。）

この制約に遭遇したとき、通常の手順は `P` から DFS を開始することです。歩いているノードが `value(V2)` に存在する限り歩き続け、それらのノードを `value(V1)` に追加します。返却ポイントに到達した場合、任意の `end(X)` 要素を追加します。その部分は変更されません。

しかし、*その後*、V2 のプレースホルダー `placeholder(x)` 要素を反復したいです（それらのそれぞれは `U(V2)` から見える必要がありますが、それが真であると仮定できるはずです。チェックする必要はありません）。`value(V1)` がそれらのプレースホルダー要素のそれぞれを生存することを確認する必要があります。

これが起こる方法は 2 つあります。第一に、`U(V1)` がユニバース `x` を見ることができる場合（つまり、`x <= U(V1)`）、`placeholder(x)` を `value(V1)` に追加して完了できます。しかし、そうでない場合は、近似する必要があります: `placeholder(x)` が表す要素のセットが何であるかはわからないかもしれませんが、その**上限** B を計算できるはずです -- `placeholder(x)` を生存する領域 B。今のところ、それには `'static` を使用します（すべてを生存するため） -- 将来的には、ここでより賢くなることができる場合があります（実際、他のコンテキストですでにこれを行うコードがあります）。さらに、`'static` はルートユニバース U0 にあるため、すべての変数がそれを見ることができることがわかります -- したがって、基本的に `value(V2)` に `V1` が見ることができないユニバース `x` の `placeholder(x)` が含まれていることがわかった場合、`V1` を `'static` に強制します。

## 「全称領域」チェックの拡張

すべての制約が伝播された後、NLL 領域推論には最終チェックがあります。各全称領域に対して計算された値を調べ、それらが「大きすぎない」かどうかをチェックします。この場合、各プレースホルダー領域を調べ、それが生存することが知られている `placeholder(u)` 要素*のみ*を含むことをチェックします。（後で、2 つのプレースホルダー領域間に関係があることを知ることができ、それらを考慮に入れることができるかもしれません。fn シグネチャからの全称領域に対して行うように。）

別の言い方をすると、「全称領域」チェックは次のような制約をチェックしていると考えることができます:

```text
{placeholder(1)}: V1
```

ここで、`{placeholder(1)}` は定数セットのようなもので、V1 は `!1` 領域を表すために作成した変数です。

## 例に戻る

さて、これまでのところ順調です。では、最初の例で何が起こるかを見ていきましょう:

```text
fn(&'static u32) <: fn(&'!1 u32) @ P  // このポイント P はここでは重要ではありません
```

領域推論エンジンは、次のような領域要素ドメインを作成します:

```text
{ CFG; end('static); placeholder(1) }
  ---  ------------  ------- ユニバース `!1` から
  |    'static は常にスコープ内にあります
  CFG 内のすべてのポイント; ここでは特に関連しません
```

常に 2 つの全称変数を作成します。1 つは `'static` を表し、もう 1 つは `'!1` を表します。それらを Vs と V1 と呼びましょう。それらは次のような初期値を持ちます:

```text
Vs = { CFG; end('static) } // U0 にあるため、他に何も名前を付けることができません
V1 = { placeholder(1) }
```

上記のサブタイピング制約から、次のような outlives 制約があります

```text
'!1: 'static @ P
```

これを処理するために、V1 の値を拡大して Vs のすべてを含めます:

```text
Vs = { CFG; end('static) }
V1 = { CFG; end('static), placeholder(1) }
```

その時点で、すべての outlives 関係が満たされるため、制約伝播は完了します。次に、コードの「全称領域をチェック」部分に移動します。これは、全称領域が大きくなりすぎていないかをテストします。

この場合、`V1` は*大きくなりすぎました* -- `end('static)` も CFG のいずれも生存することは知られていないため、エラーを報告します。

## 別の例

このサブタイピング関係についてはどうでしょうか？

```text
for<'a> fn(&'a u32, &'a u32)
    <:
for<'b, 'c> fn(&'b u32, &'c u32)
```

ここでは、前と同様に、スーパータイプの束縛領域をプレースホルダーで置き換えます:

```text
for<'a> fn(&'a u32, &'a u32)
    <:
fn(&'!1 u32, &'!2 u32)
```

次に、左辺の変数をユニバース U2 の存在変数でインスタンス化し、次のようになります（`?n` は存在変数の表記法です）:

```text
fn(&'?3 u32, &'?3 u32)
    <:
fn(&'!1 u32, &'!2 u32)
```

次に、これをさらに分解します:

```text
&'!1 u32 <: &'?3 u32
&'!2 u32 <: &'?3 u32
```

さらに分解して、領域制約を生成します:

```text
'!1: '?3
'!2: '?3
```

この場合、`'!1` と `'!2` の両方が変数 `'?3` を生存しなければならないことに注意してください。しかし、変数 `'?3` は他に何も生存することを強制されません。したがって、空の要素セットとして開始および終了し、したがって型チェックはここで成功します。

（これは少し驚くべきです。私が最初にそれに気付いたとき、私は驚きました。**両方の引数が同じ領域を持つことを必要とする** fn である場合、**2 つの異なる領域を持つ引数**で呼び出されることを受け入れることができると言っています。それは直感的に健全ではないように思えます。しかし、実際には、それは問題ありません。ずっと前に Rust issue トラッカーの[この issue][ohdeargoditsallbroken] で説明しようとしたように。理由は、2 つの異なるライフタイムを持つ引数で呼び出された場合でも、それらの 2 つのライフタイムには何らかの交差点（呼び出し自体）があり、その交差点を引数の共通ライフタイムとして使用する `'a` の値にすることができるからです。-nmatsakis）

[ohdeargoditsallbroken]: https://github.com/rust-lang/rust/issues/32330#issuecomment-202536977

## 最終例

最後の例を見てみましょう。前のものを拡張して、戻り値型を持つようにします:

```text
for<'a> fn(&'a u32, &'a u32) -> &'a u32
    <:
for<'b, 'c> fn(&'b u32, &'c u32) -> &'b u32
```

前の例と非常に似ているように見えますが、このケースはエラーになります。それは良いことです: 問題は、2 つの引数のうちの 1 つを返すことを約束する fn から、最初の引数を返すことを約束する fn に移行したことです。それは健全ではありません。どのように展開されるかを見てみましょう。

まず、スーパータイプの束縛領域をプレースホルダーで置き換えます:

```text
for<'a> fn(&'a u32, &'a u32) -> &'a u32
    <:
fn(&'!1 u32, &'!2 u32) -> &'!1 u32
```

次に、サブタイプを存在変数でインスタンス化します（U2 で）:

```text
fn(&'?3 u32, &'?3 u32) -> &'?3 u32
    <:
fn(&'!1 u32, &'!2 u32) -> &'!1 u32
```

そして、サブタイピング関係を作成します:

```text
&'!1 u32 <: &'?3 u32 // arg 1
&'!2 u32 <: &'?3 u32 // arg 2
&'?3 u32 <: &'!1 u32 // return type
```

最後に outlives 関係。ここで、V1、V2、V3 を `!1`、`!2`、`?3` にそれぞれ割り当てる変数とします:

```text
V1: V3
V2: V3
V3: V1
```

これらの変数は次の初期値を持ちます:

```text
V1 in U1 = {placeholder(1)}
V2 in U2 = {placeholder(2)}
V3 in U2 = {}
```

`V3: V1` 制約のため、`placeholder(1)` を `V3` に追加する必要があります（実際、`V3` から見えます）。したがって、次のようになります:

```text
V3 in U2 = {placeholder(1)}
```

次に、この制約 `V2: V3` があるため、`V2` を拡大して `placeholder(1)` を含める必要があります（これも見ることができます）:

```text
V2 in U2 = {placeholder(1), placeholder(2)}
```

これで制約伝播は完了しますが、outlives 関係をチェックすると、`V2` にこの新しい要素 `placeholder(1)` が含まれていることがわかるため、エラーを報告します。
