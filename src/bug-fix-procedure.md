# 破壊的変更の手順

このページでは、コンパイラでバグ修正や健全性の修正を行う際に、既存のコードがコンパイルされなくなる可能性がある場合のベストプラクティス手順を定義します。このテキストは
[RFC 1589](https://github.com/rust-lang/rfcs/blob/master/text/1589-rustc-bug-fix-procedure.md) に基づいています。

# 動機


時々、既存のコードがコンパイルされなくなるような、バグ修正、健全性の修正、
またはコンパイラでのその他の変更を行う必要に遭遇します。これが起こった場合、
Rust のユーザーにスムーズな移行を提供する方法で変更を処理することが重要です。避けたいのは、
既存のプログラムが不明瞭なエラーメッセージで突然コンパイルされなくなることです。むしろ、
問題が何か、それをどのように修正するか、なぜ変更が行われたかについて明確なガイダンスを含む、
段階的な警告期間を設けることが望ましいです。この RFC は、
そのようなスムーズな移行を達成することを目的とした、破壊的変更を処理するために開発してきた手順を説明しています。

このポリシーの重要なポイントの 1 つは、(a) 可能な限り、最初はハードエラーではなく警告を発行すべきであること、
(b) 既存のコードがコンパイルされなくなるすべての変更には、関連する追跡課題があることです。
この課題は、その変更の結果に関するフィードバックを収集するためのポイントを提供します。
変更には予想外に大きな影響があったり、考慮されなかった変更を避ける方法があったりする場合があります。そのような場合、
方針を変更して変更をロールバックするか、別の解決策を見つけることを決定する可能性があります（警告が
使用されている場合、これは特に簡単に行えます）。

### バグ修正とは何か？

この RFC は、破壊的変更が許可される時期を定義しようとはしていないことに注意してください。
それはすでに [RFC 1122][] でカバーされています。このドキュメントは、
変更がそれらのポリシーに従って行われることを前提としています。RFC 1122 からの条件の要約は次のとおりです：

- **健全性の変更：** 型システムで発見された穴の修正。
- **コンパイラのバグ：** コンパイラが RFC または lang-team の決定で見つかった指定された
  セマンティクスを実装していない場所。
- **未指定の言語セマンティクス：** コンパイラが一貫性なく動作し、正式な動作が
  以前に決定されていなかったグレーゾーンの明確化。

詳細については[RFC][rfc 1122] をご覧ください！

# 詳細設計


破壊的変更を行うための手順は次のとおりです（これらの各ステップについては以下で詳しく説明します）：

1. **crater 実行**を行い、変更の影響を評価する。
2. 変更専用の**特別な追跡課題**を作成する。
3. すぐにエラーを報告しないでください。代わりに、**将来の互換性
   lint 警告を発行**してください。
   - これが簡単でない場合があります。以下のテキストで、過去に使用してきた
     さまざまなテクニックの提案を参照してください。
   - 警告が実行不可能な場合：
     - エラーを報告しますが、ユーザーを追跡課題に誘導する的を絞った
       エラーメッセージを提供するようあらゆる努力をしてください
     - 問題を修正するすべての既知の影響を受けるクレートに PR を送信してください
       - または、少なくとも、それらのクレートの所有者に問題を警告し、
         追跡課題に誘導してください
4. 変更が少なくとも 1 サイクル野生に出てから、
   **変更を安定化**し、それらの警告をエラーに変換できます。

最後に、プラグインに影響する `rustc_ast` への変更については、一般的なポリシーは
これらの変更をバッチ処理することです。これについては以下で詳しく説明します。

### 追跡課題

すべての破壊的変更には、その変更専用の**専用追跡課題**を添付する必要があります。この課題の主要なテキストは、
行われている変更について説明し、ユーザーがコードを修正するために何をする必要があるかに焦点を当てる必要があります。課題は
アプローチ可能で実用的であるべきです。完全な詳細については、ユーザーを RFC または他の
課題に誘導することが理にかなっている場合があります。課題は、ユーザーが
質問やその他の懸念をコメントできる場所としても機能します。

これらの破壊的変更追跡課題のテンプレートは
[ここ][template] にあります。そのような課題がどのように見えるべきかの例は[ここ
で見つけることができます][breaking-change-issue]。

[template]: https://github.com/rust-lang/rust/issues/new?template=tracking_issue_future.md

### 将来の互換性警告の発行

破壊的変更を処理する最良の方法は、将来の互換性警告を発行することから始めることです。
これらは特別なカテゴリの lint 警告です。
新しい将来の互換性警告を追加するには、次のように行います。

```rust
// 1. `compiler/rustc_middle/src/lint/builtin.rs` で lint を定義します：
declare_lint! {
    pub YOUR_ERROR_HERE,
    Warn,
    "illegal use of foo bar baz"
}

// 2. 同じファイルの HardwiredLints リストに追加します：
impl LintPass for HardwiredLints {
    fn get_lints(&self) -> LintArray {
        lint_array!(
            ..,
            YOUR_ERROR_HERE
        )
    }
}

// 3. `compiler/rustc_lint/src/lib.rs` で lint を登録します：
store.register_future_incompatible(sess, vec![
    ...,
    FutureIncompatibleInfo {
        id: LintId::of(YOUR_ERROR_HERE),
        reference: "issue #1234", // ここにあなたの追跡課題！
    },
]);

// 4. lint を報告します：
tcx.lint_node(
    lint::builtin::YOUR_ERROR_HERE,
    path_id,
    binding.span,
    format!("some helper message here"));
```

#### 役立つテクニック

古い既存のエラーから新しい警告をフィルタリングすることは、しばしば困難です。過去に使用されてきた
1 つのテクニックは、古いコードを変更せずに実行し、それが報告したであろうエラーを収集することです。その後、
元のセットに表示されないエラーに対して警告を発行できます。
別のオプションは、エラーが報告された場合、元のコードが完了した後にコンパイルを中止することです：その後、
以前にエラーがなかった場合にのみ新しいコードが実行されることがわかります。

#### Crater と crates.io

[Crater] は、あなたの変更でコンパイラを使用してすべての crates.io クレートと多くの
公開 github リポジトリをコンパイルするボットです。その後、あなたの変更で
コンパイルされなくなったクレートまたはコンパイルされ始めたクレートのレポートが生成されます。Crater の実行には
完了するまで数日かかる場合があります。

[Crater]: ./tests/crater.md

影響を評価するために、常に crater 実行を行う必要があります。少なくとも
影響を受けるクレートの作成者に破壊的変更を通知することは礼儀正しく思慮深いことです。問題を修正する PR を
送信できれば、なお良いです。

#### 直接エラーを発行することは許容されますか？

影響が無視できると考えられる変更は、直接エラーを発行することができます。
1 つの経験則は、`crates.io` に対してチェックすることです：**合計**で 10 未満の影響を受ける
プロジェクトが見つかった場合（ルートエラー**ではない**）、直接エラーに移行できます。そのような場合でも、
以前と同じように「破壊的変更」ページを作成する必要があり、エラーがユーザーをこのページに誘導することを
確認する必要があります。言い換えれば、ユーザーが警告ではなくエラーを受け取ることを除いて、
すべて同じである必要があります。さらに、影響を受ける
プロジェクトに PR を送信する必要があります（理想的には、変更を実装する PR が rustc にランドする前に）。

影響が無視できないと考えられる場合（例：10 以上のクレートが
影響を受ける）、警告が必要です（コンパイラチームが
特定のケースで特別な免除を許可することに同意しない限り）。警告の実装が
実行不可能な場合、変更をランドする前にクレートを移行する積極的な戦略を立てて、
影響を受けるクレートの数を減らす必要があります。このシナリオにアプローチするためのいくつかの
テクニックは次のとおりです：

1. 問題の一部に対して警告を発行し、新しいエラーをできるだけ小さなケースのセットに予約します。
2. 問題を修正する方法を提案し、
   ユーザーを追跡課題に誘導する非常に正確なエラーメッセージを提供するようにしてください。
3. 修正をレイヤー化することも理にかなっている場合があります：
   - まず、可能な限り警告を追加し、エラーを発行する前にそれらをランドさせます。
   - 影響を受けるクレートの作成者と協力して、修正がランドする_前_に修正されたバージョンが
     利用可能であることを確認し、ダウンストリームユーザーがそれらを使用できるようにします。

### 安定化

変更が行われた後、不安定な機能に使用するのと同じプロセスを使用して
変更を**安定化**します：

- 新しいリリースが行われた後、破壊的変更に対応する未解決の追跡
  課題を調べて、その中のいくつかを**最終コメント期間**（FCP）にノミネートします。
- そのような課題の FCP は 1 サイクル続きます。サイクルの最後の 1 週間または 2 週間で、
  コメントをレビューして最終決定を下します：

  - エラーに変換：変更はハードエラーにする必要があります。
  - 元に戻す：警告を削除し、古いコードのコンパイルを続行する必要があります。
  - 延期：まだ決定できません、もっと待つか、他の戦略を試してください。

理想的には、破壊的変更は最終化される前に
コンパイラの**stable ブランチ**にランドしている必要があります。

<a id="guide"></a>

### lint の削除

「将来の警告」をハードエラーにすることを決定したら、カスタム lint を削除する PR が必要です。例として、
`overlapping_inherent_impls` 互換性 lint を削除するために必要な手順を示します。まず、lint の
名前を大文字（`OVERLAPPING_INHERENT_IMPLS`）に変換し、その文字列でソースを ripgrep します。基本的に、この
lint 名が言及されている各場所を変換します（コンパイラでは、大文字の名前を使用し、マクロが
自動的に小文字の文字列を生成します。したがって、
`overlapping_inherent_impls` を検索してもあまり見つかりません）。

> 注：これらの正確なファイルはもう存在しませんが、手順は同じです。

#### lint を削除します

最初に見つかるであろう参照は、[次のような
`rustc_session/src/lint/builtin.rs` の lint 定義][defsource]です：

[defsource]: https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc/lint/builtin.rs#L171-L175

```rust
declare_lint! {
    pub OVERLAPPING_INHERENT_IMPLS,
    Deny, // これは Warning とも言うかもしれません
    "two overlapping inherent impls define an item with the same name were erroneously allowed"
}
```

この `declare_lint!` マクロは関連するデータ構造を作成します。これを削除してください。また、
ファイルの後半に [`lint_array!` の一部として][lintarraysource]`OVERLAPPING_INHERENT_IMPLS` への言及があることがわかります。これも削除してください。

[lintarraysource]: https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc/lint/builtin.rs#L252-L290

次に、[`rustc_lint/src/lib.rs` の `OVERLAPPING_INHERENT_IMPLS` への参照][futuresource]が表示されます。これは lint を「将来の
互換性 lint」として定義しています：

```rust
FutureIncompatibleInfo {
    id: LintId::of(OVERLAPPING_INHERENT_IMPLS),
    reference: "issue #36889 <https://github.com/rust-lang/rust/issues/36889>",
},
```

これも削除してください。

#### 削除された lint のリストに lint を追加します

`compiler/rustc_lint/src/lib.rs` には「名前変更および削除された lint」のリストがあります。
この lint をリストに追加できます：

```rust
store.register_removed("overlapping_inherent_impls", "converted into hard error, see #36889");
```

ここで `#36889` はあなたの lint の追跡課題です。

#### lint を発行する場所を更新します

最後に、参照の最後のクラスは、実際に
lint 自体を**トリガー**する場所（つまり、警告が表示される原因）です。これらは
削除したくありません。代わりに、それらをエラーに変換したいと思います。
この場合、[`add_lint` 呼び出し][addlintsource]は次のようになります：

```rust
self.tcx.sess.add_lint(lint::builtin::OVERLAPPING_INHERENT_IMPLS,
                       node_id,
                       self.tcx.span_of_impl(item1).unwrap(),
                       msg);
```

これをエラーに変換したいと思います。場合によっては、このシナリオに対して
既存のエラーがある場合があります。他の場合、新しい診断コードを
割り当てる必要があります。[新しい診断コードを割り当てるための手順はここで見つけることができます。](./diagnostics/error-codes.md) 拡張説明で
コンパイラの動作がこの点で変更されたことを言及し、
変更の追跡課題への参照を含めることをお勧めします。

コードとして `E0592` を採用したとしましょう。その後、上記の
`add_lint()` 呼び出しを次のように変更できます：

```rust
struct_span_code_err!(self.dcx(), self.tcx.span_of_impl(item1).unwrap(), E0592, msg)
    .emit();
```

#### テストを更新します

最後に、テストスイートを実行します。以前は `overlapping_inherent_impls` lint を参照していたいくつかのテストがあるはずです。それらを更新する必要があります。
一般的に、テストに `#[deny(overlapping_inherent_impls)]` があった場合、
それを削除できます。

```
./x test
```

#### 完了

PR を開いてください。=)

[addlintsource]: https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc_typeck/coherence/inherent.rs#L300-L303
[futuresource]: https://github.com/rust-lang/rust/blob/085d71c3efe453863739c1fb68fd9bd1beff214f/src/librustc_lint/lib.rs#L202-L205

<!-- -Links--------------------------------------------------------------------- -->

[rfc 1122]: https://github.com/rust-lang/rfcs/blob/master/text/1122-language-semver.md
[breaking-change-issue]: https://gist.github.com/nikomatsakis/631ec8b4af9a18b5d062d9d9b7d3d967
