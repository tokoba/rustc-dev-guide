# コーディング規約

このファイルは、rustcのコーディング規約に関するいくつかのヒントを提供します。この章では、[フォーマット](#formatting)、[正確性のためのコーディング](#cc)、[crates.ioからのクレートの使用](#cio)、および簡単なレビューのために[PRを構成する](#er)ためのいくつかのヒントについて説明します。

<a id="formatting"></a>

## フォーマットとtidyスクリプト

rustcは[Rust standard coding style][fmt]に向けて移行しています。

ただし、現時点では安定版の`rustfmt`を使用していません。特別な設定でピン留めされたバージョンを使用しているため、通常の[`rustfmt`]とは異なるスタイルになる可能性があります。
したがって、`cargo fmt`を使用してこのリポジトリをフォーマットすることはお勧めしません。

代わりに、`./x fmt`を使用してフォーマットする必要があります。コミットごとに`./x fmt`を実行するのは良い習慣です。これにより、後で競合が減ります。

フォーマットは`tidy`スクリプトによってチェックされます。`./x test`を実行すると自動的に実行され、`./x fmt --check`で単独で実行することもできます。

エディタでformat-on-saveを使用したい場合、ピン留めされたバージョンの`rustfmt`は`build/<target>/stage0/bin/rustfmt`の下にビルドされます。

[fmt]: https://github.com/rust-dev-tools/fmt-rfcs
[`rustfmt`]:https://github.com/rust-lang/rustfmt

### C++コードのフォーマット

コンパイラには、安定したC APIを持たないLLVMの一部とのインターフェース用のC++コードがいくつか含まれています。
そのコードを変更する場合は、次のコマンドを使用してフォーマットしてください:

```console
./x test tidy --extra-checks cpp:fmt --bless
```

これは、ローカル環境に依存しないように、ピン留めされたバージョンの`clang-format`を使用します。

### PythonコードのフォーマットとLint

Rustリポジトリには、かなりの量のPythonコードが含まれています。[ruff]ツールによってLintとフォーマットの両方を保つようにしています。

Pythonコードを変更する場合は、次のコマンドを使用してフォーマットしてください:

```console
./x test tidy --extra-checks py:fmt --bless
```

そして、Lintを実行するには次のコマンドを使用してください:

```console
./x test tidy --extra-checks py:lint
```

これらは、ローカル環境に依存しないように、ピン留めされたバージョンの`ruff`を使用します。

[ruff]: https://github.com/astral-sh/ruff

<a id="copyright"></a>

<!-- REUSE-IgnoreStart -->
<!-- REUSEが見出しを著作権表示として解釈するのを防ぎます -->
### 著作権表示
<!-- REUSE-IgnoreEnd -->

過去には、ファイルは著作権とライセンス表示で始まっていました。標準条項(デュアルMIT/Apache-2.0)でライセンスされた新しいファイルについては、この表示を**省略**してください。

すべての著作権表示はもうなくなっているはずですが、rust-lang/rustリポジトリで見つけた場合は、削除するPRを開いてください。

### 行の長さ

行は最大100文字にしてください。80文字以内に収めることができれば、さらに良いです。

場合によっては、特にテストでは、この制限から除外する必要がある場合があります。
その場合、ファイルの上部に次のようなコメントを追加できます:

```rust
// ignore-tidy-linelength
```

### タブとスペース

4スペースのインデントを優先してください。

<a id="cc"></a>

## 正確性のためのコーディング

フォーマット以外にも、従う価値のあるいくつかのヒントがあります。

### 網羅的なマッチを優先する

マッチで`_`を使用するのは便利ですが、新しいバリアントが列挙型に追加されたときに正しく処理されない可能性があります。
自問してください: この列挙型に新しいバリアントが追加された場合、`_`コードを使用する可能性はどのくらいありますか?それとも他の処理が必要ですか?答えが「低い」でない限り、網羅的なマッチを優先してください。

同じアドバイスは、実質的に単一のバリアントのテストである`if let`と`while let`にも適用されます。

### 忘れたくないことには「TODO」コメントを使用する

自分自身への便利なツールとして、PRをランドする前に戻りたいことについて`// TODO`コメントを挿入できます:

```rust,ignore
fn do_something() {
    if something_else {
        unimplemented!(); // TODO これを書く
    }
}
```

tidyスクリプトは`// TODO`コメントに対してエラーを報告するため、このコードはTODOが修正(または削除)されるまでランドできません。

これは、PRでも、あるコミットでバグを残しており、後のコミットで修正することを知らせる方法として役立ちます:

```rust,ignore
if foo {
    return true; // TODO 間違っているが、後のコミットで修正される
}
```

<a id="cio"></a>

## crates.ioからのクレートの使用

[crates.io dependencies][crates]セクションを参照してください。

<a id="er"></a>

## PRの構成方法

PRでコミットを準備する方法は、レビュアーにとって大きな違いを生む可能性があります。いくつかのヒントを以下に示します。

**「純粋なリファクタリング」を独自のコミットに分離する。** たとえば、メソッドの名前を変更する場合は、その名前変更を、すべての使用箇所の名前変更と一緒に独自のコミットに入れてください。

**コミットは通常、多いほど良い。** 大きな変更を行っている場合、独立して理解できる小さなステップに分割する方が、ほとんどの場合良いです。注意すべき点は、ある戦略に従ってコードを導入し、後のコミットで劇的に変更する(追加するのではなく)場合、その「往復」が混乱を招く可能性があることです。

**自由にフォーマットする。** PRの最終コミットのみが正しくフォーマットされている必要がありますが、各コミットを個別に`./x fmt`でフォーマットする方が、レビューが簡単でノイズが少なくなります。

**マージなし。** 履歴にマージコミットを許可していません。borsによるものを除きます。マージコンフリクトが発生した場合は、代わりにリベースしてください。`git rebase --interactive rust-lang/main`のようなコマンドを使用してください(`rust-lang`をリモートの名前として使用していると仮定します)。

**個々のコミットはビルドする必要はありません(ただし、それが良いです)。** すべての中間コミットが正常にビルドされることは要求していません - PRレベルでの二分探索のみを期待しています。ただし、個々のコミットがビルドできる場合は、常に役立ちます。

## 命名規則

通常のRustスタイル/命名規則の他に、コンパイラに固有のものもあります。

- `cx`は「context」の略語であり、サフィックスとして使用されることがよくあります。たとえば、`tcx`は[Typing Context][tcx]の一般的な名前です。

- [`'tcx`][tcx]は、Typing Contextのライフタイム名として使用されます。

- `crate`はキーワードであるため、クレート関連の何かを表す変数が必要な場合、多くの場合、スペルが`krate`に変更されます。

[tcx]: ./ty.md

[crates]: ./crates-io.md
