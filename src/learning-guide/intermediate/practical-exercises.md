# 実践演習

このセクションでは、中級者レベルの実際のコンパイラ課題に取り組みます。学んだ知識を実践に活かし、より複雑な貢献に挑戦するための演習を提供します。

## 演習のアプローチ

### 学習の進め方

#### 1. 段階的な難易度

- **初級中級**: 基本的な機能の拡張や修正
- **中級**: 複数のコンポーネントにまたがる問題
- **中上級**: 新しい機能の実装や最適化

#### 2. 実践的な学習サイクル

```mermaid
graph LR
    A[問題の理解] --> B[解決策の設計]
    B --> C[実装]
    C --> D[テスト]
    D --> E[レビュー]
    E --> F[改善]
    F --> A
```

#### 3. 効率的な学習方法

- **小さな成功体験**: 簡単な課題から始める
- **継続的な学習**: 定期的に新しい課題に挑戦
- **記録と復習**: 学んだことを記録し定着させる

## 演習カテゴリ

### 1. 型チェックと型推論

#### 演習1.1: 新しい型のサポート

**目的**: 簡単な新しい型のサポートを追加する

**課題**: タプル型のパターンマッチングの改善

```rust
// 現在の制限
fn pattern_matching() {
    let tuple = (1, 2, 3);
    match tuple {
        (1, y, z) => println!("y={}, z={}", y, z),
        _ => println!("other"),
    }
}

// 目標: より複雑なパターンをサポート
fn advanced_pattern() {
    let tuple = (1, (2, 3), 4);
    match tuple {
        (1, (y, z), 4) => println!("y={}, z={}", y, z),
        _ => println!("other"),
    }
}
```

**学習ポイント**:

- パターンマッチングのアルゴリズム
- 型チェックの拡張方法
- エラー報告の改善

**実装のヒント**:

1. `src/librustc_pat/pat.rs` のパターン処理を確認
2. `src/librustc_typeck/pat.rs` の型チェックを拡張
3. 新しいテストを `tests/ui/patterns/` に追加

#### 演習1.2: 型推論の改善

**目的**: 型推論の精度を向上させる

**課題**: クロージャの型推論の改善

```rust
// 現在の制限
fn closure_inference() {
    let closure = |x, y| x + y; // 型推論が難しい場合
    let result = closure(1, 2); // 明示的な型注釈が必要
}

// 目標: より良い型推論
fn improved_inference() {
    let closure = |x, y| x + y; // 自動的に型推論
    let result = closure(1, 2); // 型注釈なしで動作
}
```

**学習ポイント**:

- 型推論アルゴリズムの理解
- 制約収集と解決のプロセス
- クロージャの型表現

**実装のヒント**:

1. `src/librustc_infer/infer.rs` の型推論を確認
2. `src/librustc_typeck/fn_ctxt.rs` の型チェックを拡張
3. 制約解決のロジックを改善

### 2. MIRと最適化

#### 演習2.1: 簡単な最適化パスの実装

**目的**: 新しいMIR最適化パスを実装する

**課題**: 定数伝播の改善

```rust
// 最適化前
fn constant_propagation() {
    let x = 5;
    let y = x + 3;
    let z = y * 2;
    println!("{}", z);
}

// 最適化後
fn optimized() {
    let z = 16; // 5 + 3 = 8, 8 * 2 = 16
    println!("{}", z);
}
```

**学習ポイント**:

- MIRの構造と操作
- 最適化パスの実装方法
- データフロー分析

**実装のヒント**:

1. `src/librustc_mir/transform/` に新しい最適化パスを作成
2. `src/librustc_mir/pass_manager.rs` にパスを登録
3. `src/librustc_mir/interpret/` の定数評価を活用

#### 演習2.2: MIRの可視化ツール

**目的**: MIRを可視化するツールを実装する

**課題**: MIRのGraphviz出力の改善

```rust
// MIRの可視化例
fn visualize_mir() {
    // 基本ブロックと制御フローをグラフとして出力
    // 各ステートメントとターミネータを可視化
}
```

**学習ポイント**:

- MIRの構造の理解
- グラフ表現の実装
- ツールの作成方法

**実装のヒント**:

1. `src/librustc_mir/graphviz.rs` を拡張
2. Graphviz形式の出力を実装
3. 制御フローグラフの可視化

### 3. エラー報告と診断

#### 演習3.1: エラーメッセージの改善

**目的**: より分かりやすいエラーメッセージを作成する

**課題**: 型エラーメッセージの改善

```rust
// 現在のエラーメッセージ
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     let x: i32 = "hello";
  |              ^^^   ^^^^^^ expected `i32`, found `&str`

// 改善されたエラーメッセージ
error[E0308]: type mismatch
 --> src/main.rs:3:14
  |
3 |     let x: i32 = "hello";
  |              ^^^   ^^^^^^ 
  |              |     |
  |              |     found: &str (string slice)
  |              expected: i32 (32-bit integer)
  |
  = help: if you want to store text, consider changing the type to `String`
  = help: if you want to store a number, consider changing the value to `42`
```

**学習ポイント**:

- 診断システムの構造
- エラーメッセージの作成方法
- ヘルプメッセージの追加

**実装のヒント**:

1. `src/librustc_errors/` の診断システムを確認
2. `src/librustc_typeck/errors.rs` の型エラーを改善
3. 新しい診断メッセージを追加

#### 演習3.2: 新しいlintの実装

**目的**: 有用なlintを実装する

**課題**: 未使用の変数警告の改善

```rust
// 新しいlintの例
fn unused_variables() {
    let x = 5; // 未使用の変数
    let y = 10;
    println!("{}", y);
}

// lintの警告
warning: unused variable `x`
 --> src/main.rs:2:9
  |
2 |     let x = 5;
  |         ^ help: if this is intentional, prefix with `_`: `_x`
```

**学習ポイント**:

- lintシステムの構造
- 新しいlintの実装方法
- lintの登録と設定

**実装のヒント**:

1. `src/librustc_lint/` に新しいlintを実装
2. `src/librustc_lint/builtins.rs` にlintを登録
3. `src/tools/clippy/` の既存のlintを参考

### 4. パフォーマンス改善

#### 演習4.1: メモリ使用量の最適化

**目的**: コンパイラのメモリ使用量を改善する

**課題**: 型チェックのメモリ最適化

```rust
// メモリ使用量の測定
fn memory_optimization() {
    // 型チェック中のメモリ使用量を測定
    // 不要なデータ構造を特定し削除
}
```

**学習ポイント**:

- メモリプロファイリング
- データ構造の最適化
- メモリリークの検出

**実装のヒント**:

1. `valgrind` や `heaptrack` でメモリ使用量を測定
2. `src/librustc_ty/` の型表現を最適化
3. キャッシュの効率化

#### 演習4.2: コンパイル時間の短縮

**目的**: コンパイル時間を短縮する

**課題**: クエリシステムの最適化

```rust
// クエリのパフォーマンス測定
fn query_optimization() {
    // クエリの実行時間を測定
    // ボトルネックを特定し改善
}
```

**学習ポイント**:

- クエリシステムの理解
- パフォーマンスプロファイリング
- キャッシュ戦略の改善

**実装のヒント**:

1. `rustc -Z time-passes` で実行時間を測定
2. `src/librustc_middle/ty/query/` のクエリを最適化
3. キャッシュヒット率の改善

## 実践プロジェクト

### プロジェクト1: 小さな機能の実装

#### 目標

新しい言語機能の小さな部分を実装する

#### 例: const genericsの改善

```rust
// 現在の制限
fn const_generics() {
    let array: [i32; 5] = [1, 2, 3, 4, 5];
    // const引数の制約が多い
}

// 目標: より柔軟なconst generics
fn improved_const_generics<const N: usize>() {
    let array: [i32; N] = [0; N];
    // より柔軟なconst引数
}
```

#### 実装計画

1. **要件分析**: 機能の仕様を理解
2. **設計**: 実装方法を計画
3. **実装**: コードを実装
4. **テスト**: テストを作成
5. **ドキュメント**: ドキュメントを更新

### プロジェクト2: パフォーマンス改善

#### 目標

特定のコンポーネントのパフォーマンスを改善する

#### 例: 型チェックの高速化

```rust
// パフォーマンス測定
fn benchmark_typeck() {
    let start = std::time::Instant::now();
    // 型チェックの実行
    let duration = start.elapsed();
    println!("Type checking took: {:?}", duration);
}
```

#### 実装計画

1. **プロファイリング**: ボトルネックを特定
2. **最適化**: アルゴリズムを改善
3. **測定**: 改善効果を測定
4. **検証**: 正しさを確認
5. **文書化**: 改善内容を記録

### プロジェクト3: ツールの開発

#### 目標

コンパイラ開発を支援するツールを作成する

#### 例: MIRアナライザ

```rust
// MIRアナライザの実装
fn mir_analyzer() {
    // MIRを解析し、有用な情報を抽出
    // 最適化の機会を特定
}
```

#### 実装計画

1. **要件定義**: ツールの機能を定義
2. **設計**: アーキテクチャを設計
3. **実装**: ツールを実装
4. **テスト**: ツールをテスト
5. **配布**: ツールを共有

## 評価とフィードバック

### コードレビューの基準

#### 技術的側面

- **正確性**: コードが正しく動作する
- **効率性**: 効率的な実装である
- **保守性**: 将来の保守が容易である
- **一貫性**: 既存のコードスタイルに従っている

#### 非技術的側面

- **可読性**: コードが読みやすい
- **文書化**: 適切なコメントがある
- **テスト**: 十分なテストがある
- **学習**: 新しいことを学んでいる

### 自己評価の方法

#### 1. 学習目標の達成度

- [ ] 型チェックの理解が深まった
- [ ] MIRの操作ができるようになった
- [ ] デバッグ技術が向上した
- [ ] パフォーマンス分析ができるようになった

#### 2. 実践的なスキル

- [ ] 独立して問題を解決できる
- [ ] 適切なツールを選択できる
- [ ] 効率的にデバッグできる
- [ ] コードレビューができる

#### 3. 貢献活動

- [ ] 実際のissueに貢献できた
- [ ] コードレビューに参加できた
- [ ] ドキュメントを改善できた
- [ ] 新しい機能を実装できた

## 次のステップ

### 継続的な学習

#### 1. 定期的な挑戦

- 毎月1つの新しい課題に挑戦
- 定期的なコードレビューへの参加
- コミュニティでの知識共有

#### 2. 専門分野の深化

- 特定のコンポーネントに集中
- 関連する論文や資料の読解
- 専門家との交流

#### 3. メンターシップ

- 新人開発者の指導
- 知識の共有と伝達
- コミュニティへの貢献

### 上級者への道

実践演習を完了したら、次は[上級者向け学習パス](../advanced/README.md)に進む準備ができています。

#### 準備すべきこと

- [ ] 中級者レベルの貢献経験
- [ ] 特定コンポーネントの深い理解
- [ ] 独立した問題解決能力
- [ ] コミュニティでの信頼

#### おすすめの次のステップ

1. 上級者学習パスへの進学
2. 特化パスでの専門分野の深化
3. 新機能の設計と実装への参加
4. コンパイラチームでのリーダーシップ

---

この実践演習を通じて、学んだ知識を実践に活かし、より高度な貢献ができるようになりましょう。挑戦を続けることで、必ず成長できます。
