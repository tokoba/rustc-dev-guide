# メソッド検索

メソッド検索は、セルフ型、自動参照外し、トレイト検索など、
いくつかの要因の相互作用により、かなり複雑になる可能性があります。
このファイルは、プロセスの概要を提供します。より詳細な注意事項は、
当然ながらコード自体にあります。

メソッド検索を考える1つの方法は、`receiver.method(...)`という形式の式を、
より明示的な[完全修飾構文][]（以前は[UFCS][]と呼ばれていました）に変換することです。

- トレイト呼び出しの場合は`Trait::method(ADJ(receiver), ...)`
- 固有メソッド呼び出しの場合は`ReceiverType::method(ADJ(receiver), ...)`

ここで`ADJ`は何らかの調整であり、通常は一連の
自動参照外しと、その後場合によっては自動参照（例：`&**receiver`）です。
ただし、他の調整や型強制を行うこともあります。
特に、サイズ変更（例：`[T; n]`から`[T]`への変換）を行います。

メソッド検索は、2つの主要なフェーズに分かれています。

1. プロービング（[`probe.rs`][probe]）。プロービングフェーズは、呼び出すメソッドと
   レシーバーの調整方法を決定するときです。
2. 確認（[`confirm.rs`][confirm]）。確認フェーズは、この選択を「適用」し、
   サイドテーブルを更新し、型変数を統合し、
   その他の副作用のあることを行います。

この分割の理由の1つは、キャッシュにより適しているためです。
プロービングフェーズは、「pick」（`probe::Pick`）を生成します。
これは、メソッド呼び出しサイト全体でキャッシュ可能になるように設計されています。
したがって、推論変数やその他の情報は含まれません。

[fully-qualified syntax]: https://doc.rust-lang.org/nightly/book/ch19-03-advanced-traits.html#fully-qualified-syntax-for-disambiguation-calling-methods-with-the-same-name
[UFCS]: https://github.com/rust-lang/rfcs/blob/master/text/0132-ufcs.md
[probe]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir_typeck/method/probe/
[confirm]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_hir_typeck/method/confirm/

## プロービングフェーズ

### ステップ

プロービングフェーズが最初に行うことは、一連の*ステップ*を作成することです。
これは、レシーバー型を参照外しできなくなるまで段階的に参照外しし、
オプションの「サイズ変更」ステップを適用することによって行われます。
したがって、レシーバーが型`Rc<Box<[T; 3]>>`を持つ場合、次のようになります。

1. `Rc<Box<[T; 3]>>`
2. `Box<[T; 3]>`
3. `[T; 3]`
4. `[T]`

### 候補アセンブリ

次に、これらのステップに沿って検索して、*候補*のリストを作成します。
`Candidate`は、おそらく呼び出されているメソッドであるメソッドアイテムです。
各候補について、明示的なセルフを考慮した「変換されたセルフ型」を導出します。

候補は、固有と拡張の2種類にグループ化されます。

**固有候補**は、レシーバー自体の型から派生したものです。
したがって、名義型`Foo`（例：構造体）のレシーバーがある場合、
`impl Foo`のような impl 内で定義されたメソッドはすべて固有メソッドです。
固有メソッドを使用するためにインポートする必要はありません。
これらは型自体に関連付けられています
（固有implは、型自体と同じクレートでのみ定義できることに注意してください）。

<!--
FIXME: 固有候補は常にimplから派生するとは限りません。トレイトオブジェクトがある場合、
たとえば型`Box<ToString>`の値など、トレイトメソッド（この場合は`to_string()`）は
本質的にそれに関連付けられています。もう1つのケースは型パラメータであり、
その場合、境界のメソッドは固有です。ただし、ルールのこの部分は変更される可能性があります。
DSTの「impl Trait for Trait」が完了すると、トレイトオブジェクトディスパッチは
トレイト一致に組み込まれる可能性があり、型パラメータの動作は、where句に照らして再考する必要があります。

これはまだ正確ですか？
-->

**拡張候補**は、インポートされたトレイトから派生します。`ToString`トレイトをインポートし、
メソッドとして`to_string()`を呼び出す場合、
`ToString`の各implの`to_string()`定義を候補としてリストします。
これらの種類のメソッド呼び出しは、「拡張メソッド」と呼ばれます。

それでは、例を続けましょう。レシーバー`Rc<Box<[T; 3]>>`でメソッド`foo`を呼び出しており、
`Rc<U>`型の`&self`で定義するトレイト`Foo`と、
`foo`を定義するが`&mut self`で定義する型`Box`のメソッドがあるとします。
次に、2つの候補があるかもしれません。

- 拡張候補としての`&Rc<U>`
- 固有候補としての`&mut Box<U>`

### 候補検索

最後に、実際にメソッドを選択するために、ステップを下に検索し、
レシーバー型を候補型と照合しようとします。各ステップで、
候補のいずれかが一致するかどうかを確認するために、自動参照と自動ミュータブル参照も考慮します。
結果として得られる各レシーバー型について、拡張候補の前に固有候補を考慮します。
グループ内に複数の一致する候補がある場合はエラーを報告しますが、
同じトレイトの複数のimplは単一の一致として扱われます。そうでなければ、
見つかった最初の一致を選択します。

この例の場合、最初のステップは`Rc<Box<[T; 3]>>`であり、
それ自体はどの候補とも一致しません。しかし、それを自動参照すると、
型`&Rc<Box<[T; 3]>>`が得られ、これは`&Rc<U>`と一致します。次に、
impl に表示されるすべてのwhere句を再帰的に考慮します。
それらが一致する場合（または一致しないと判断できない場合）、
これが選択するメソッドです。そうでない場合は、
一連のステップを下に続けます。
