# MIRの構築

[HIR]から[MIR]への変換は、以下の（おそらく不完全な）項目に対して行われます：

* 関数とクロージャの本体
* `static`と`const`アイテムの初期化子
* 列挙型の判別値の初期化子
* あらゆる種類の糊コードとshim
    * タプル構造体の初期化関数
    * ドロップコード（`Drop::drop`関数は直接呼び出されません）
    * 明示的な`Drop`実装を持たない型のドロップ実装

変換は[`mir_built`]クエリを呼び出すことでトリガーされます。MIRビルダーは実際にはHIRを使用せず、代わりに[THIR]を操作し、THIR式を再帰的に処理します。

変換は、シグネチャで指定されたすべての引数に対してローカル変数を作成します。次に、指定されたすべてのバインディングに対してローカル変数を作成します（例：`(a, b): (i32, String)`）は3つのバインディングを生成します。1つは引数用、2つはバインディング用です。次に、引数からフィールドを読み取り、その値をバインディング変数に書き込むフィールドアクセスを生成します。

この初期化が完了すると、変換は本体（`Block`式）のMIRを生成する関数への再帰呼び出しをトリガーし、その結果を`RETURN_PLACE`に書き込みます。

## `unpack!`ですべてを展開

MIRを生成する関数は、2つのパターンのいずれかに分類される傾向があります。まず、関数がステートメントのみを生成する場合、それらのステートメントを追加すべき基本ブロックを引数として受け取ります。そして、通常通り結果を返すことができます：

```rust,ignore
fn generate_some_mir(&mut self, block: BasicBlock) -> ResultType {
   ...
}
```

しかし、新しい基本ブロックも生成する可能性のある他の関数もあります。例えば、`if foo { 22 } else { 44 }`のような式を変換するには、小さな「ダイヤモンド形のグラフ」を生成する必要があります。この場合、関数はコードが開始される基本ブロックを受け取り、コード生成が終了する（潜在的に）新しい基本ブロックを返します。`BlockAnd`型は、これを表すために使用されます：

```rust,ignore
fn generate_more_mir(&mut self, block: BasicBlock) -> BlockAnd<ResultType> {
    ...
}
```

これらの関数を呼び出すときは、実質的に「カーソル」であるローカル変数`block`を持つのが一般的です。これは、新しいMIRを追加している地点を表します。`generate_more_mir`を呼び出すときは、このカーソルを更新したいと思うでしょう。これは手動で行うこともできますが、面倒です：

```rust,ignore
let mut block;
let v = match self.generate_more_mir(..) {
    BlockAnd { block: new_block, value: v } => {
        block = new_block;
        v
    }
};
```

このため、`let v = unpack!(block = self.generate_more_mir(...))`と書けるマクロを提供しています。これは単に新しいブロックを抽出し、`unpack!`で指定した変数`block`を上書きします。

## 式を望ましいMIRに変換

式の表現には、基本的に4つの種類があります：

* `Place`は、既存のメモリ位置（ローカル、スタティック、昇格）の（または一部の）参照です
* `Rvalue`は`Place`に割り当てることができるものです
* `Operand`は、例えば`+`演算や関数呼び出しの引数です
* 値のコピーを含む一時変数

次の画像は、表現間の相互作用の一般的な概要を示しています：

<img src="mir_overview.svg">

[より詳細なビューはこちらをクリック](mir_detailed.svg)

まず、関数本体を`Rvalue`に変換して、`RETURN_PLACE`への割り当てを作成できるようにします。この`Rvalue`の変換は、その引数（もしあれば）に対して`Operand`への変換をトリガーします。`Operand`の変換は、`const`オペランドを生成するか、`Place`から移動/コピーするため、`Place`の変換をトリガーします。`Place`に変換される式は、変換される式に演算が含まれている場合、一時変数を作成するようトリガーすることができます。ここで蛇が自分の尾を噛み、ローカルに書き込まれる式に対して`Rvalue`の変換をトリガーする必要があります。

## 演算子の変換

組み込み型の演算子は、関数呼び出しに変換されません（それは無限再帰呼び出しになってしまいます。なぜなら、トレイト実装は演算自体を再び含んでいるからです）。代わりに、二項演算子、単項演算子、インデックス演算用の`Rvalue`があります。これらの`Rvalue`は後でllvmのプリミティブ演算またはllvmイントリンシックにコード生成されます。

他のすべての型の演算子は、演算子の対応するトレイトの`impl`への関数呼び出しに変換されます。

変換の種類に関係なく、演算子への引数は`Operand`に変換されます。これは、すべての引数が定数であるか、すでにローカルまたはスタティックのどこかに存在する値を参照していることを意味します。

## メソッド呼び出しの変換

メソッド呼び出しは、関数呼び出しと同じ`TerminatorKind`に変換されます。[MIR]では、メソッド呼び出しと関数呼び出しの違いはもうありません。

## 条件

`if`条件とフィールドを持たないバリアントを持つ`enum`の`match`ステートメントは、`TerminatorKind::SwitchInt`に変換されます。各可能な値（`if`条件の場合は`0`と`1`）には、コードが続く対応する`BasicBlock`があります。分岐される引数は（再び）if条件の値を表す`Operand`です。

### パターンマッチング

フィールドを持つバリアントを持つ`enum`の`match`ステートメントも`TerminatorKind::SwitchInt`に変換されますが、`Operand`は、値の判別値が見つかる`Place`を参照します。これは多くの場合、判別値を新しい一時変数に読み込むことを伴います。

## 集約の構築

あらゆる種類の集約値（例：構造体やタプル）は、`Rvalue::Aggregate`を介して構築されます。すべてのフィールドは`Operator`に変換されます。これは基本的に、集約フィールドごとに1つの割り当てステートメント、および`enum`の場合は判別値への割り当てと同等です。

[MIR]: ./index.html
[HIR]: ../hir.html
[THIR]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/index.html

[`rustc_mir_build::thir::cx::expr`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/cx/expr/index.html
[`mir_built`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_transform/fn.mir_built.html
