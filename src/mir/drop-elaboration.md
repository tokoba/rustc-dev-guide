# ドロップ精緻化

## 動的ドロップ

[リファレンス][reference-drop]によると：

> 初期化された変数または一時変数がスコープ外になると、そのデストラクタが実行されるか、ドロップされます。代入も、初期化されている場合、その左オペランドのデストラクタを実行します。変数が部分的に初期化されている場合、その初期化されたフィールドのみがドロップされます。

MIRを構築する際、`Drop`および`DropAndReplace`ターミネータは、ドロップが発生する可能性がある場所を表します。ただし、このフェーズでは、これらのターミネータの存在は、デストラクタが実行されることを保証するものではありません。それは、ターミネータに到達する前に、ドロップのターゲットが（通常は移動されたため）初期化されていない可能性があるためです。一般に、変数が初期化されているかどうかをコンパイル時に知ることはできません。

```rust
let mut y = vec![];

{
    let x = vec![1, 2, 3];
    if std::process::id() % 2 == 0 {
        y = x; // 条件付きで`x`を`y`に移動
    }
} // `x`はここでスコープ外になります。ドロップされるべきですか？
```

これらの場合、変数が初期化されているかどうかを*動的に*追跡する必要があります。ルールは[RFC 320: 非ゼロ化動的ドロップ][RFC 320]で詳細に説明されています。

## ドロップ義務

RFCから：

> ローカル変数が初期化されると、「ドロップ義務」のセットを確立します：ドロップする必要がある構造パス（例：ローカル`a`、またはフィールドへのパス`b.f.y`）のセット。
>
> 構造体型`T`のローカル変数xのドロップ義務は、`T`の構造を分析することから計算されます。`T`自体が`Drop`を実装している場合、`x`はドロップ義務です。`T`が`Drop`を実装していない場合、ドロップ義務のセットは`T`のフィールドのドロップ義務の和集合です。

構造パスから移動される（そして初期化されていない状態になる）と、そのパスまたはその子孫（`path.f`、`path.f.g.h`など）のドロップ義務はすべて解放されます。`Drop`実装を持つ型は、個々のフィールドからの移動を許可しないため、それらを通じて初期化状態を追跡する必要はありません。

ローカル変数がスコープ外になる（`Drop`）とき、または構造パスが代入を介して上書きされる（`DropAndReplace`）とき、その変数またはパスのドロップ義務をチェックします。その時点でその義務が解放されていない限り、関連する`Drop`実装が呼び出されます。`enum`型の場合、「アクティブな」バリアントに対応するフィールドのみをドロップする必要があります。このような型のドロップ義務を処理する際、まず判別値をチェックしてアクティブなバリアントを決定します。アクティブなバリアント以外のバリアントのすべてのドロップ義務は無視されます。

これらのルールを説明するために、いくつかの興味深い型を示します：

```rust
struct NoDrop(u8); // `Drop`実装なし。`Drop`実装を持つフィールドもなし。

struct NeedsDrop(Vec<u8>); // `Drop`実装はないが、`Drop`実装を持つフィールドがある。

struct ThinVec(*const u8); // カスタム`Drop`実装。個々のフィールドからの移動は不可。

impl Drop for ThinVec {
    fn drop(&mut self) { /* ... */ }
}

enum MaybeDrop {
    Yes(NeedsDrop),
    No(NoDrop),
}
```

## ドロップ精緻化

これらのルールの1つの有効なモデルは、関数内の任意の時点で使用されるすべての構造パスに対してブールフラグ（「ドロップフラグ」）を保持することです。このフラグは、パスが初期化されたときに設定され、パスから移動されたときにクリアされます。`Drop`が発生すると、`Drop`のターゲットに関連するすべての義務のフラグをチェックし、まだ適用可能なものに対して関連する`Drop`実装を呼び出します。

このプロセス—不正確な`Drop`および`DropAndReplace`ターミネータを持つ新しく構築されたMIRをドロップフラグを持つものに変換すること—は、ドロップ精緻化として知られています。MIRステートメントが変数を初期化（または初期化解除）する原因となる場合、ドロップ精緻化は、その変数のドロップフラグを設定（またはクリア）するコードを挿入します。新しく挿入されたドロップフラグをチェックする条件文で`Drop`ターミネータをラップします。

ドロップ精緻化は、`DropAndReplace`ターミネータを、ターゲットの`Drop`と新しくドロップされた場所への書き込みに分割します。これは、上で説明したこととはやや無関係です。

これが完了すると、MIRの`Drop`ターミネータは、ドロップされた場所の型の「ドロップ糊」または「ドロップshim」への呼び出しに対応します。型のドロップ糊は、その型の`Drop`実装（存在する場合）を呼び出し、次にその型のすべてのフィールドのドロップ糊を再帰的に呼び出します。

## `rustc`でのドロップ精緻化

上記で説明したアプローチは、必要以上に高価です。いくつかの最適化を想像できます：

- `Drop`のターゲットである（またはターゲットをプレフィックスとして持つ）パスのみがドロップフラグを必要とします。
- ドロップされるときに初期化されている（または初期化されていない）ことがわかっている一部の変数。これらはドロップフラグを必要としません。
- 一連のパスが共有プレフィックスを介してのみドロップまたは移動される場合、それらのパスは単一のドロップフラグを共有できます。

これらのサブセットは`rustc`に実装されています。

コンパイラでは、ドロップ精緻化は複数のモジュールに分割されています。パス自体は[ここ][drops-transform]で定義されていますが、[主要なロジック][drops]は、[ドロップshim][drops-shim]を構築するためにも使用されるため、別の場所で定義されています。

ドロップ精緻化は、新しく構築されたMIRの各`Drop`を、4つの種類のいずれかとして指定します：

- `Static`、ターゲットは常に初期化されています。
- `Dead`、ターゲットは常に**非**初期化されています。
- `Conditional`、ターゲットは完全に初期化されているか、完全に初期化されていないかのいずれかです。部分的に初期化されていません。
- `Open`、ターゲットは部分的に初期化されている可能性があります。

このため、2つのデータフロー解析、`MaybeInitializedPlaces`と`MaybeUninitializedPlaces`を使用します。場所が一方に存在し、他方に存在しない場合、ターゲットの初期化状態はコンパイル時に既知です（`Dead`または`Static`）。この場合、ドロップ精緻化はターゲットのフラグを追加しません。単に`Drop`ターミネータを削除（`Dead`）または保持（`Static`）します。

`Conditional`ドロップの場合、変数全体の初期化状態がそのフィールドの初期化状態と同じであることがわかります。したがって、そのドロップのターゲットに対してドロップフラグを生成したら、そのターゲットのドロップ糊を呼び出すことは安全です。

### `Open`ドロップ

`Open`ドロップは最も複雑です。なぜなら、単一の`Drop`ターミネータを、ターゲットの各フィールドに対して、その型がドロップ糊を持つ（`Ty::needs_drop`）いくつかの異なるものに分解する必要があるからです。ターゲット自体のドロップ糊を呼び出すことはできません。なぜなら、それにはターゲットのすべてのフィールドが初期化されている必要があるからです。カスタム`Drop`実装を持つ型は、そのフィールドから移動できないため、`Open`ドロップを許可しないことを覚えておいてください。

これは、各フィールドを`Dead`、`Static`、`Conditional`、または`Open`として再帰的に分類することによって達成されます。ドロップ糊を持たない型のフィールドは自動的に`Dead`であり、再帰中に考慮する必要はありません。種類が`Open`でないフィールドに到達すると、上記のように処理します。フィールドも`Open`の場合、再帰は続きます。

列挙型の`Open`ドロップをどのように処理するかに注目する価値があります。ドロップ精緻化内では、列挙型の各バリアントはフィールドのように扱われ、それらの「バリアントフィールド」のうち1つだけが任意の時点で初期化できるという不変条件があります。一般的なケースでは、どのバリアントがアクティブであるかはわからないため、列挙型のドロップ糊を呼び出すか（判別値をチェックします）、精緻化された`Open`ドロップの一部として判別値を自分でチェックする必要があります。ただし、特定のケース（`match`アーム内など）では、列挙型のどのバリアントがアクティブであるかがわかります。この情報は、非アクティブなバリアントに対応するすべての場所を初期化されていないものとしてマークすることによって、`MaybeInitializedPlaces`および`MaybeUninitializedPlaces`データフロー解析にエンコードされます。

### クリーンアップパス

TODO: ドロップ精緻化とアンワインドについて議論する。

## 余談：ドロップ精緻化とconst-eval

Rustでは、コンパイル時の評価の対象となる関数は、`const`キーワードを使用して明示的にマークする必要があります。これには、`Drop`トレイトの実装が含まれます。これは`const`である場合とそうでない場合があります。コンパイル時評価の対象となるコードは、`const`関数のみを呼び出すことができるため、このようなコード内の非const `Drop`実装への呼び出しはすべて禁止する必要があります。

`Drop`実装への呼び出しは、MIRでは`Drop`ターミネータとしてエンコードされます。ただし、上で説明したように、新しく構築されたMIRの`Drop`ターミネータは、必ずしも`Drop::drop`への呼び出しにつながるわけではありません。ドロップターゲットはその時点で初期化されていない可能性があります。これは、新しく構築されたMIRで非const `Drop`をチェックすると、偽のエラーが発生する可能性があることを意味します。代わりに、ドロップ精緻化が実行された後まで待ち、`Dead`ドロップ（ターゲットが初期化されていないことがわかっているもの）を排除してから、これらのチェックを実行します。

[RFC 320]: https://rust-lang.github.io/rfcs/0320-nonzeroing-dynamic-drop.html
[reference-drop]: https://doc.rust-lang.org/reference/destructors.html
[drops]: https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_mir_dataflow/src/elaborate_drops.rs
[drops-shim]: https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_mir_transform/src/shim.rs
[drops-transform]: https://github.com/rust-lang/rust/blob/HEAD/compiler/rustc_mir_transform/src/elaborate_drops.rs
