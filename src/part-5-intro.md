# MIRからバイナリへ

このガイドの前述の章には1つの共通点があります：
実行可能なマシンコードをまったく生成していません！
この章で、すべてが変わります。

これまで、
コンパイラがUTF-8テキスト形式の生のソースコードを取得し、[MIR]に変換する方法を示しました。
また、コンパイラがコードに対して様々な解析を行い、型エラーやライフタイムエラーなどを検出する方法も示しました。
今度は、MIRを取得して実行可能なマシンコードを生成します。

[MIR]: ./mir/index.md

> 注：コンパイラのこの部分は、しばしば_バックエンド_と呼ばれます。
> この用語は、コンパイラソースでは少し過負荷です。
> 通常、「コード生成バックエンド」（つまり、LLVM、Cranelift、またはGCC）を指します。
> 通常、このパートで「バックエンド」という言葉を見かける場合、
> 「コード生成バックエンド」を指しています。

では、何をする必要がありますか？

1. まず、コードを生成する対象のセットを収集する必要があります。
   特に、
   ジェネリック型に代入する具体的な型を見つける必要があります。
   具体的な型のコードを生成する必要があるためです。
   具体的な型のコードを生成すること
   （つまり、各具体的な型に対してコードのコピーを出力すること）は_単相化_と呼ばれ、
   すべての具体的な型を収集するプロセスは_単相化収集_と呼ばれます。
2. 次に、収集した各具体的な型に対して、MIRをコード生成IR
   （通常はLLVM IR）に実際に下げる必要があります。
3. 最後に、コード生成バックエンドを呼び出す必要があります。
   これは一連の最適化パスを実行し、
   実行可能なコードを生成し、
   実行可能なバイナリをリンクします。

[codegen1]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/base/fn.codegen_crate.html

コード生成のコードは、いくつかの要因により実際には少し複雑です：

- 複数のコード生成バックエンド（LLVM、Cranelift、およびGCC）のサポート。
  それらの間でできるだけ多くのバックエンドコードを共有しようとするため、
  その多くはコード生成実装に対してジェネリックです。
  これは、多くの場合、多くの抽象化レイヤーがあることを意味します。
- コード生成はパフォーマンスのために別のスレッドで非同期に行われます。
- 実際のコード生成はサードパーティのライブラリ（3つのバックエンドのいずれか）によって行われます。

一般的に、[`rustc_codegen_ssa`][ssa]クレートにはバックエンド非依存のコードが含まれており、
[`rustc_codegen_llvm`][llvm]クレートにはLLVMコード生成に固有のコードが含まれています。

[ssa]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_ssa/index.html
[llvm]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_codegen_llvm/index.html

非常に高いレベルでは、エントリーポイントは
[`rustc_codegen_ssa::base::codegen_crate`][codegen1]です。
この関数は、この章の残りで説明するプロセスを開始します。
