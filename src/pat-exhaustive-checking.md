# パターンと網羅性チェック

Rustでは、パターンマッチングと束縛にはいくつかの非常に便利なプロパティがあります。コンパイラは、束縛が反駁不可能であることをチェックし、match アームが網羅的であることをチェックします。

## パターンの有用性

有用性チェックが答える中心的な質問は：
「この match 式では、そのブランチは冗長か？」です。
より正確には、すでに見たパターンのリストが与えられたときに、
新しいパターンが新しい値にマッチする可能性があるかどうかを計算することに帰着します。

たとえば、次の match 式では、
各パターンがその上のパターンでマッチされなかった何かにマッチするかどうかを順番に尋ねます。
ここでは、4番目のパターンが1番目のものと冗長であることがわかります。
そのブランチには「到達不可能」という警告が出されます。
3番目のパターンは、`Foo` が `Bar` 以外のバリアントを持っているかどうかによって、有用かどうかが変わります。
最後に、ワイルドカードパターン（`_`）がそのmatch内のすべてのパターンのリストに対して有用かどうかを尋ねることで、
match全体が網羅的かどうかを尋ねることができます。
ここでは、`_` が有用であることがわかります（`(false, None)` をキャッチします）。
したがって、この式は「非網羅的なmatch」エラーが出ます。

```rust
// x: (bool, Option<Foo>)
match x {
    (true, _) => {} // 1
    (false, Some(Foo::Bar)) => {} // 2
    (false, Some(_)) => {} // 3
    (true, None) => {} // 4
}
```

したがって、有用性は2つの目的に使用されます：
到達不可能なコードの検出（ユーザーにとって有用）、
および match が網羅的であることの保証（match 式が値を返せるため、健全性にとって重要）。

## 発生場所

このチェックは、パターンを書ける場所すべてで行われます：`match` 式、`if let`、`let else`、
プレーンな `let`、および関数引数です。

```rust
// `match`
// 有用性は到達不可能なブランチを検出し、非網羅的なmatchを禁止できます。
match foo() {
    Ok(x) => x,
    Err(_) => panic!(),
}

// `if let`
// 有用性は到達不可能なブランチを検出できます。
if let Some(x) = foo() {
    // ...
}

// `while let`
// 有用性は無限ループとデッドループを検出できます。
while let Some(x) = it.next() {
    // ...
}

// 分解する `let`
// 有用性は非網羅的なパターンを禁止できます。
let Foo::Bar(x, y) = foo();

// 関数引数の分解
// 有用性は非網羅的なパターンを禁止できます。
fn foo(Foo { x, y }: Foo) {
    // ...
}
```

## アルゴリズム

網羅性チェックはMIRビルドの前に [`check_match`] で実行されます。
これは [`rustc_pattern_analysis`] クレートに実装されており、
アルゴリズムのコアは [`usefulness`] モジュールにあります。
そのファイルには、アルゴリズムの詳細な説明が含まれています。

## 重要な概念

### コンストラクタとフィールド

値 `Pair(Some(0), true)` では、`Pair` はその値のコンストラクタと呼ばれ、`Some(0)` と
`true` がそのフィールドです。すべてのマッチ可能な値はこの方法で分解できます。コンストラクタの例は：
`Some`、`None`、`(,)`（2-タプルコンストラクタ）、`Foo {..}`（構造体 `Foo` のコンストラクタ）、
および `2`（数値 `2` のコンストラクタ）です。

各コンストラクタは固定数のフィールドを取ります。これはそのアリティと呼ばれます。`Pair` と `(,)` のアリティは
2、`Some` のアリティは 1、`None` と `42` のアリティは 0 です。各型には既知のコンストラクタのセットがあります。
いくつかの型は多くのコンストラクタ（`u64` など）または無限に多くのコンストラクタ（`&str` や `&[T]` など）を持っています。

パターンも似ています：`Pair(Some(_), _)` はコンストラクタ `Pair` と2つのフィールドを持ちます。違いは、
パターン専用のコンストラクタがいくつか追加されることです：ワイルドカード `_`、変数束縛、
`0..=10` のような整数範囲、および `[_, .., _]` のような可変長スライスです。or-パターンは別途扱います。

値 `v` がパターン `p` にマッチするかどうかをチェックするには、`v` のコンストラクタが `p` の
コンストラクタにマッチするかどうかをチェックし、必要に応じて再帰的にそれらのフィールドを比較します。いくつかの代表的な例：

- `matches!(v, _) := true`
- `matches!((v0,  v1), (p0,  p1)) := matches!(v0, p0) && matches!(v1, p1)`
- `matches!(Foo { a: v0, b: v1 }, Foo { a: p0, b: p1 }) := matches!(v0, p0) && matches!(v1, p1)`
- `matches!(Ok(v0), Ok(p0)) := matches!(v0, p0)`
- `matches!(Ok(v0), Err(p0)) := false`（非互換なバリアント）
- `matches!(v, 1..=100) := matches!(v, 1) || ... || matches!(v, 100)`
- `matches!([v0], [p0, .., p1]) := false`（非互換な長さ）
- `matches!([v0, v1, v2], [p0, .., p1]) := matches!(v0, p0) && matches!(v2, p1)`

この概念はパターン解析の絶対的な中心です。[`constructor`] モジュールは、
コンストラクタを抽出、リスト、操作する関数を提供します。これは十分に有用な概念であり、
コンパイラの他の場所、たとえば match 式の MIR ローワリングや一部の clippy lint にも
このバリエーションが見られます。

### コンストラクタのグループ化と分割

パターン専用のコンストラクタ（`_`、範囲、可変長スライス）は、それぞれ通常のコンストラクタの
セットを表します。例えば、`_: Option<T>` は {`None`, `Some`} のセットを表し、`[_, .., _]` は
アリティ >= 2 のスライスコンストラクタの無限集合 {`[,]`, `[,,]`, `[,,,]`, ...} を表します。

これらのコンストラクタを管理するために、できるだけグループ化された状態を保ちます。たとえば：

```rust
match (0, false) {
    (0 ..=100, true) => {}
    (50..=150, false) => {}
    (0 ..=200, _) => {}
}
```

この例では、`0`、`1`、...、`49` のすべてが同じアームにマッチするため、グループとして扱うことができます。
実際、この match では、考慮する必要がある範囲は：`0..50`、`50..=100`、
`101..=150`、`151..=200`、および `201..` だけです。同様に：

```rust
enum Direction { North, South, East, West }
# let wind = (Direction::North, 0u8);
match wind {
    (Direction::North, 50..) => {}
    (_, _) => {}
}
```

ここでは、すべての非 `North` コンストラクタをグループとして扱うことができ、
2つのケースだけを処理すればよくなります：`North` とそれ以外のすべて。

これは「コンストラクタ分割」と呼ばれ、網羅性が合理的な時間で実行されるために重要です。

### 空の型の存在下での有用性と到達可能性

これはおそらく網羅性の最も微妙な側面です。完全に正確を期すと、match は値に対して動作するのではなく、
場所に対して動作します。特定の unsafe な状況では、場所がその型の有効なデータを含まない可能性があります。
これは空の型に対して微妙な結果をもたらします。次を考えてみてください：

```rust
enum Void {}
let x: u8 = 0;
let ptr: *const Void = &x as *const u8 as *const Void;
unsafe {
    match *ptr {
        _ => println!("Reachable!"),
    }
}
```

この例では、`ptr` は無効なデータを指す場所を指す有効なポインタです。`_` パターンは
場所 `*ptr` の内容を見ないため、このコードは正常で、アームが取られます。言い換えれば、
検査している場所が `Void` 型であるにもかかわらず、到達可能なアームがあります。しかし、
アームが束縛を持っている場合：

```rust
# #[derive(Copy, Clone)]
# enum Void {}
# let x: u8 = 0;
# let ptr: *const Void = &x as *const u8 as *const Void;
# unsafe {
match *ptr {
    _a => println!("Unreachable!"),
}
# }
```

ここでは、束縛が `*ptr` の場所から `Void` 型の値をロードします。この例では、データが有効でないため
UB を引き起こします。一般的な場合、これは `*ptr` のデータの妥当性をアサートします。
いずれにせよ、このアームは決して取られません。

最後に、空の match `match *ptr {}` を考えてみましょう。これを網羅的と見なす場合、`*ptr` に無効なデータがあることは無効になります。言い換えれば、空の match は
`_a => ...` match と意味的に同等です。明示性の観点から、アームのあるケースを好むので、
`_a` アームを削除するようにユーザーに指示しません。言い換えれば、`_a` アームは
到達不可能ですが冗長ではありません。これが、到達不可能なアームではなく冗長なアームに対して lint を行う理由です。
lint が「到達不可能」と言っているにもかかわらずです。

これらの考慮事項は特定の場所にのみ影響します。すなわち、UB なしで無効なデータを含むことができる場所です。
これらは：ポインタの参照解除、参照の参照解除、および union フィールドアクセスです。網羅性チェック中に、
与えられた場所が有効なデータを含むことが知られているかどうかを追跡します。

以上のすべてを述べた上で、網羅性チェックの現在の実装は上記の考慮事項に従っていません。stable では、
空の型はほとんどの場合、空でないものとして扱われます。[`exhaustive_patterns`] 機能は反対側に偏っています：
unsafe な状況で到達可能なアームを省略することを許可します。[`never_patterns`] 実験的機能は、
これを修正し、パターン内の空の型の正しい動作を許可することを目指しています。

[`check_match`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_mir_build/thir/pattern/check_match/index.html
[`rustc_pattern_analysis`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/index.html
[`usefulness`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/usefulness/index.html
[`constructor`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_pattern_analysis/constructor/index.html
[`never_patterns`]: https://github.com/rust-lang/rust/issues/118155
[`exhaustive_patterns`]: https://github.com/rust-lang/rust/issues/51085
