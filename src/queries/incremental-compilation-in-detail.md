# インクリメンタルコンパイルの詳細

インクリメンタルコンパイルスキームは、本質的には、
全体的なクエリシステムへの驚くほどシンプルな拡張です。これは次の事実に依存しています:

  1. クエリは純粋関数です -- 同じ入力が与えられると、クエリは常に
     同じ結果を生成し、
  2. クエリモデルは、個々の計算間の依存関係を明示的にする非循環グラフで
     コンパイルを構造化します。

この章では、これらのプロパティを使用してインクリメンタルにする方法を説明し、
次にバージョン実装の問題について説明します。

## インクリメンタルクエリ評価の基本アルゴリズム

[クエリ評価モデル入門][query-model]で説明されているように、クエリ
呼び出しは有向非循環グラフを形成します。前の章からの例をもう一度示します:

```ignore
  list_of_all_hir_items <----------------------------- type_check_crate()
                                                               |
                                                               |
  Hir(foo) <--- type_of(foo) <--- type_check_item(foo) <-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
                    v                                          |
  Hir(bar) <--- type_of(bar) <--- type_check_item(bar) <-------+
```

1つのクエリから別のクエリへのすべてのアクセスはクエリ
コンテキストを経由する必要があるため、これらのアクセスを記録して、
メモリ内に依存関係グラフを実際に構築できます。依存関係追跡が有効な場合、
コンパイルが完了すると、どのクエリが呼び出されたか(グラフのノード)と、
各呼び出しについて、クエリの結果の計算に使用された他のどのクエリまたは入力があったか
(グラフのエッジ)がわかります。

ここで、プログラムのソースコードを変更して、
`bar`のHIRが以前とは異なるとします。私たちの目標は、
変更によって実際に影響を受けるクエリのみを再計算し、
他のすべてのクエリのキャッシュされた結果を再利用することです。
依存関係グラフがあれば、まさにそれを行うことができます。特定のクエリ呼び出しについて、
グラフは、その結果の計算に使用されたデータを正確に示しており、
変更されたものに到達するまでエッジをたどるだけです。変更されたものに
遭遇しない場合、すでにキャッシュにある結果がクエリが評価する
結果と同じであることがわかります。

上記の`type_of(foo)`呼び出しを例にとると、エッジをたどって
入力を確認することで、キャッシュされた結果がまだ有効かどうかを確認できます。
唯一のエッジは、変更の影響を受けていない入力である`Hir(foo)`に至ります。
したがって、`type_of(foo)`のキャッシュされた結果はまだ有効であることがわかります。

`type_check_item(foo)`の場合は少し異なります: エッジを歩いていくと、
`type_of(foo)`が問題ないことがすでにわかっています。次に`type_of(bar)`に到達しますが、
まだ確認していないので、`type_of(bar)`のエッジを歩いて、`Hir(bar)`に遭遇します。
これは*変更されました*。その結果、`type_of(bar)`の結果は、キャッシュにあるものとは
異なる結果を生成する可能性があり、推移的に、`type_check_item(foo)`の結果も
変更された可能性があります。したがって、`type_check_item(foo)`を再実行し、
順番に`type_of(bar)`を再実行します。これは、`Hir(bar)`の最新バージョンを読み取るため、
最新の結果を生成します。また、`type_of(bar)`の結果が変更された可能性があるため、
`type_check_item(bar)`も再実行します。


## 基本アルゴリズムの問題: 偽陽性

前の段落を注意深く読むと、`type_of(bar)`は、その入力の1つが変更されたため、
*変更された可能性がある*と書かれていることに気付くでしょう。
その入力が変更されたとしても、*まったく*同じ
結果を生成する可能性もあります。整数の符号を計算する単純なクエリの例を考えてみましょう:

```ignore
  IntValue(x) <---- sign_of(x) <--- some_other_query(x)
```

`IntValue(x)`が最初は`1000`で、その後`2000`に設定されたとします。
`IntValue(x)`は2つのケースで異なりますが、`sign_of(x)`は両方のケースで
結果`+`を生成します。

ただし、基本アルゴリズムに従うと、`some_other_query(x)`は推移的に変更された
入力に依存しているため、(不必要に)再評価する必要があります。変更検出は、
この場合、`some_other_query(x)`がその変更された入力によって影響を受ける可能性があると
保守的に仮定する必要があるため、「偽陽性」を生成します。

残念ながら、コンパイラの実際のクエリは、このような例でいっぱいであり、
入力への小さな変更が出力バイナリの非常に大きな部分に影響を与える可能性が
よくあることがわかります。その結果、変更検出システムをよりスマートで正確にする必要がありました。

## 精度の向上: red-greenアルゴリズム

「偽陽性」問題は、変更検出とクエリの再評価をインターリーブすることで解決できます。
キャッシュされた結果がまだ有効かどうかを確認しようとするときに
入力までグラフをたどる代わりに、再評価を余儀なくされた後に
結果が*実際に*変更されたかどうかを確認できます。

このアルゴリズムをred-greenアルゴリズムと呼びます。これは、キャッシュされた結果が
まだ有効であることを証明できた場合、依存関係グラフ内のノードに緑色が割り当てられ、
再評価後に結果が異なることが判明した場合は赤色が割り当てられるためです。

red-green変更追跡の核心は、try-mark-green
アルゴリズムに実装されています。これは、あなたが推測したように、
特定のノードを緑色としてマークしようとします:

```rust,ignore
fn try_mark_green(tcx, current_node) -> bool {

    // `current_node`への入力、つまり`node`からの直接エッジが
    // 至るノードを取得します。
    let dependencies = tcx.dep_graph.get_dependencies_of(current_node);

    // 次に、すべての入力の変更を確認します
    for dependency in dependencies {

        match tcx.dep_graph.get_node_color(dependency) {
            Green => {
                // この入力は以前に確認されており、変更されていません;
                // したがって、次の確認に進むことができます
            }
            Red => {
                // 変更された入力が見つかりました。キャッシュされた
                // クエリを再実行せずに、`current_node`を緑色として
                // マークすることはできません。
                return false
            }
            Unknown => {
                // このノードを最初に見るのはこれが初めてです。
                // try_mark_green()を再帰的に呼び出して、緑色としてマークしようとします。
                if try_mark_green(tcx, dependency) {
                    // 入力を緑色としてマークすることに成功しました。
                    // 次に進みます。
                } else {
                    // 入力を緑色としてマークすることが*できませんでした*。
                    // これは、その値が変更されたかどうかがわからないことを意味します。
                    // 調べるために、対応するクエリを今すぐ再実行します!
                    tcx.run_query_for(dependency);

                    // ノードの色を再度フェッチして確認します。クエリを実行すると、
                    // キャッシュにある結果とは異なる結果を生成した場合は赤
                    // (同じ結果を生成した場合は緑)になります。
                    match tcx.dep_graph.get_node_color(dependency) {
                        Red => {
                            // 入力が赤であることが判明しました。したがって、
                            // `current_node`を緑色としてマークすることはできません。
                            return false
                        }
                        Green => {
                            // クエリの再実行が成功しました! 結果は
                            // 以前と同じであるため、この特定の入力は
                            // `current_node`を無効にしません。
                        }
                        Unknown => {
                            // クエリを再実行した後、ノードに色がないことはあり得ません。
                            panic!("unreachable")
                        }
                    }
                }
            }
        }
    }

    // ループ全体を通過した場合、すべての入力が
    // 緑色であることが判明したことを意味します。すべての入力が変更されていない場合、
    // `current_node`に対応するクエリ結果も
    // 変更できなかったことを意味します。
    tcx.dep_graph.mark_green(current_node);

    true
}
```

> 注意:
> 実際の実装は
> [`compiler/rustc_query_system/src/dep_graph/graph.rs`][try_mark_green]にあります

red-greenマーキングを使用することで、変更検出中に偽陽性が発生する壊滅的な累積効果を
回避できます。クエリがインクリメンタルモードで実行されるときは常に、
まずすでに緑色かどうかを確認します。そうでない場合は、`try_mark_green()`を実行します。
それでも緑色でない場合は、実際にクエリプロバイダーを呼び出して結果を再計算します。
クエリを再計算すると、さらにクエリを再帰的に呼び出すことになる可能性があり、
これは依存関係に対して`try_mark_green()`アルゴリズムに再帰的に戻ることを意味する可能性があります。


## 現実の世界: 永続性がすべてを複雑にする方法

上記のセクションでは、インクリメンタル
コンパイルの基礎となるアルゴリズムについて説明しましたが、
コンパイラプロセスは終了後に終了し、
結果キャッシュを含むクエリコンテキストを忘却の彼方に持っていくため、
次のコンパイルセッションが使用できるように、データをディスクに永続化する必要があります。
これには、まったく新しい実装上の課題があります:

- クエリ結果キャッシュはディスクに保存されるため、
  変更比較にすぐに使用できません。
- 後続のコンパイルセッションは、任意の変更が適用されたコードの新しいバージョンで
  開始されます。グローバルで連続したカウンターから生成されるすべての種類のIDとインデックス
  (`NodeId`、`DefId`など)がシフトした可能性があり、
  ディスク上の永続化された結果が同じ数値のIDとインデックスがまったく新しいものを参照する可能性があるため、
  新しいコンパイルセッションですぐには使用できなくなります。
- ディスクにものを永続化するにはコストがかかるため、すべての小さな情報が
  実際にコンパイルセッション間でキャッシュされるべきではありません。
  固定サイズのプレーンオールドデータは、高価な(デ)シリアライゼーションステップを
  経る必要がある複雑なものよりも好まれます。

以下のセクションでは、コンパイラがこれらの問題をどのように解決するかについて説明します。

### 安定性の問題: コンパイルセッション間のギャップを埋める

前述のように、様々なID(`DefId`など)は、コンパイルされるソースコードの内容に
依存する方法でコンパイラによって生成されます。ID割り当ては
通常、決定論的です。つまり、まったく同じコードを2回コンパイルすると、
同じものが同じIDになります。ただし、何かが
変更された場合、たとえば関数がファイルの途中に追加された場合、
何も同じIDを持つという保証はありません。

その結果、オンディスクキャッシュのデータを、
メモリ内の表現と同じように表現することはできません。たとえば、
`TyKind::FnDef(DefId, &'tcx Substs<'tcx>)`のような型情報を保存し
(メモリ内で行うように)、含まれる`DefId`が新しい
コンパイルセッションで異なる関数を指す場合、問題になります。

この問題の解決策は、コンパイルセッション間で有効なままのIDの「安定した」形式を
見つけることです。最も重要なケースである`DefId`については、
これらはいわゆる`DefPath`です。各`DefId`には対応する`DefPath`がありますが、
数値IDの代わりに、`DefPath`は識別されたアイテムへのパスに基づいており、
例えば`std::collections::HashMap`です。このようなIDの利点は、
無関係な変更の影響を受けないことです。たとえば、
`std::collections`に新しい関数を追加できますが、
`std::collections::HashMap`は依然として`std::collections::HashMap`です。
`DefPath`は、ソースコードに加えられた変更にわたって「安定」しており、
`DefId`はそうではありません。

`DefPathHash`もあります。これは、`DefPath`の128ビットハッシュ値です。
2つは同じ情報を含んでおり、`DefPathHash`は`Copy`で自己完結型であるため、
扱いがより簡単であるため、ほとんど使用しています。

この安定した識別子の原則は、オンディスク
キャッシュ内のデータをソースコードの変更に対して耐性を持たせるために使用されます。
`DefId`を保存する代わりに、`DefPathHash`を保存し、
キャッシュから何かをデシリアライズするときに、`DefPathHash`を
*現在の*コンパイルセッションの対応する`DefId`にマッピングします
(これは単純なハッシュテーブルルックアップです)。

独自の`DefId`を持たないHIRコンポーネントを識別するために使用される`HirId`は、
もう1つのそのような安定したIDです。これは(概念的には)`DefPath`と`LocalId`のペアで、
`LocalId`は「所有者」内の何か(例: `hir::Expr`)をローカルに識別します
(例: `hir::Item`)。所有者が移動された場合でも、その中の`LocalId`は同じままです。



### クエリ結果の変更の確認: `HashStable`と`Fingerprint`

red-greenマーキングを行うためには、クエリの結果が
前回のコンパイルセッション中の結果と比較して変更されたかどうかを確認する必要があります。
ただし、これには2つのパフォーマンスの問題があります:

- 比較のためだけに、ディスクから前の結果をロードすることを避けたいと思います。
  すでに新しい結果を計算しており、それを使用します。また、ディスクから結果をロードすると、
  使用される可能性が低いデータでインターナーが「汚染」されます。
- すべての結果をオンディスクキャッシュに保存したくありません。たとえば、
  すでにアップストリームクレートで利用可能なものをディスクに永続化することは
  無駄な努力になります。

コンパイラは、いわゆる`Fingerprint`を使用してこれらの問題を回避します。
新しいクエリ結果が計算されるたびに、クエリエンジンは結果の128ビットハッシュ値を
計算します。このハッシュ値を「クエリ結果の`Fingerprint`」と呼びます。
ハッシュは(そしてそうである必要があります)「安定した方法」で行われます。これは、
コンパイルセッション間で変更される可能性のある何かをハッシュするときはいつでも
(例: `DefId`)、代わりに安定した同等物をハッシュすることを意味します
(例: 対応する`DefPath`)。これが`HashStable`
インフラストラクチャ全体の目的です。このようにして、2つの
異なるコンパイルセッションで計算された`Fingerprint`は依然として比較可能です。

次のステップは、これらのフィンガープリントを依存関係グラフとともに保存することです。
フィンガープリントは単にコピーされるバイトであるため、これは安価です。
依存関係グラフとともにフィンガープリントのセット全体をロードすることも安価です。

これで、red-greenマーキングが結果が変更されたかどうかを確認する必要がある
ポイントに到達すると、(すでにロードされた)前の
フィンガープリントを新しい結果のフィンガープリントと比較するだけです。

このアプローチはかなりうまく機能しますが、欠陥がないわけではありません:

- ハッシュの衝突の可能性はわずかです。つまり、2つの異なる
  結果が同じフィンガープリントを持つ可能性があり、システムは誤って
  結果が変更されていないと仮定し、見逃された更新につながります。

  高品質のハッシュ関数と128ビット幅のハッシュ値を使用することで、
  このリスクを軽減します。これらの対策により、ハッシュ衝突の実際のリスクは
  無視できます。

- フィンガープリントの計算はかなりコストがかかります。これは、インクリメンタル
  コンパイルが非インクリメンタルコンパイルよりも遅くなる可能性がある主な理由です。
  優れた、したがって高価なハッシュ関数を使用することを余儀なくされ、
  ハッシュ中に物事を安定した同等物にマッピングする必要があります。


### 2つの`DepGraph`の物語: 古いものと新しいもの

依存関係追跡の最初の説明では、実際に物事を実装しようとするときにすぐに
頭を悩ませるいくつかの詳細を省略しています。特に、実際には*2つ*の
依存関係グラフを扱っていることを見落としやすいです:前回のコンパイルセッション中に
構築したものと、現在のコンパイルセッション用に構築しているものです。

コンパイルセッションが開始されると、コンパイラは前の依存関係
グラフを不変のデータとしてメモリにロードします。次に、クエリが呼び出されると、
まず、グラフ内の対応するノードを緑色としてマークしようとします。これは
実際には、*現在の*セッションのクエリキーに対応する*前の* dep-graphのノードを
緑色としてマークしようとしていることを意味します。現在のクエリキーと前の`DepNode`の
間のこのマッピングをどのように行いますか?答えは再び`Fingerprint`です:
依存関係グラフ内のノードは、クエリキーのフィンガープリントによって識別されます。
フィンガープリントはコンパイルセッション間で安定しているため、
現在のセッションで1つを計算すると、前回のセッションの依存関係グラフで
ノードを見つけることができます。指定されたフィンガープリントを持つノードが見つからない場合は、
クエリキーが前回のセッションにまだ存在しなかった何かを参照していることを意味します。

したがって、前の依存関係グラフでdep-nodeを見つけたら、その依存関係
(つまり、前のグラフのdep-nodeも)を検索し、
try-mark-greenアルゴリズムの残りを続行できます。次に興味深いことが起こるのは、
ノードを緑色としてマークすることに成功したときです。その時点で、ノードと
その依存関係へのエッジを古いグラフから新しいグラフにコピーします。
新しいdep-graphは通常の依存関係追跡を介して
ノードとエッジを取得できないため、これを行う必要があります。追跡システムは、
クエリを実際に実行している間にのみエッジを記録できます -- しかし、結果が
すでにキャッシュされているにもかかわらず、クエリを実行することは、まさに避けたいことです。

コンパイルセッションが終了すると、変更されていない部分はすべて
古い依存関係グラフから新しい依存関係グラフにコピーされ、変更された部分は
追跡システムによって新しいグラフに追加されています。この時点で、
新しいグラフはクエリ結果キャッシュとともにディスクにシリアライズされ、
後続のコンパイルセッションで前のdep-graphとして機能できます。


### 何か忘れていませんか?: キャッシュプロモーション

これまでに説明したシステムには、やや微妙なプロパティがあります: dep-nodeの
すべての入力が緑色の場合、対応するクエリ結果を計算またはロードすることなく、
dep-node自体を緑色としてマークできます。このプロパティを推移的に適用すると、
次の例のように、一部の中間結果が実際にディスクからロードされない状況に
つながることがよくあります:

```ignore
   input(A) <-- intermediate_query(B) <-- leaf_query(C)
```

コンパイラは、何らかの出力アーティファクトを生成するために`leaf_query(C)`の値が
必要になる場合があります。`leaf_query(C)`を緑色としてマークできる場合、
オンディスクキャッシュから結果をロードします。ただし、`intermediate_query(B)`の結果は
決してロードされません。その結果、コンパイラがすべてのメモリ内クエリ結果を
ディスクに書き込むことによって*新しい*結果キャッシュを永続化すると、
`intermediate_query(B)`はメモリ内にないため、新しい結果キャッシュから欠落します。

その後、`intermediate_query(B)`の結果が実際に必要な別のコンパイルセッションがある場合、
直前のキャッシュに完全に有効な結果があったにもかかわらず、
再計算する必要があります。

これが起こらないようにするために、コンパイラは「キャッシュプロモーション」と呼ばれるものを
行います: 新しい結果キャッシュを発行する前に、すべての緑の
dep-nodeを歩いて、そのクエリ結果がメモリにロードされていることを確認します。そうすれば、
結果キャッシュが不必要に再び縮小することはありません。



# インクリメンタルコンパイルとコンパイラバックエンド

LLVMを含むコンパイラバックエンドは、クエリシステムを使用していますが、
クエリ自体の観点から実装されていません。その結果、依存関係追跡に
自動的に参加しません。ただし、追跡システムとの手動統合は
非常に簡単です。コンパイラは、各コード生成ユニット(CGU)の初期LLVMバージョンを生成するときに
呼び出されるクエリを単に追跡し、各CGUのdep-nodeが生成されます。後続の
コンパイルセッションでは、CGUのdep-nodeを緑色としてマークしようとします。
成功した場合、ディスク上の対応するオブジェクトおよびビットコードファイルが
まだ有効であることがわかります。成功しない場合は、CGU全体を再コンパイルする必要があります。

これは、通常のクエリに使用されるのと同じアプローチです。主な違いは
次のとおりです:

 - LLVMモジュールのフィンガープリントを簡単に計算できない
   (不透明なC++オブジェクトであるため)、

 - キャッシュされた値を処理するためのロジックは、通常のクエリとはかなり異なります。
   ここには、共通の結果キャッシュファイルのシリアライズされたRust値の代わりに、
   ビットコードおよびオブジェクトファイルがあるためです。

 - LLVMに関する操作は、計算時間とメモリ消費の観点から非常に高価であるため、
   何がいつ実行され、何がどのくらいメモリに留まるかを厳密に制御する必要があります。

クエリシステムは、上記のすべてを処理する汎用メカニズムで拡張できる可能性がありますが、
これまでのところ、それは節約するよりも面倒だと思われました。



## クエリ修飾子

クエリシステムでは、クエリに[修飾子][mod]を適用できます。これらの
修飾子は、インクリメンタルコンパイルに関してシステムがクエリを処理する方法の
特定の側面に影響します:

 - `eval_always` - `eval_always`属性を持つクエリは、インクリメンタルコンパイル中に
   無条件に再実行されます。つまり、システムはクエリのdep-nodeを緑色として
   マークしようとすらしません。この属性には2つのユースケースがあります:

    - `eval_always`クエリは入力(ファイルから、グローバル状態などから)を読み取ることができます。
      また、ファイルへの書き込みやグローバル状態の変更などの副作用を生成することもできます。

    - 一部のクエリは、その結果が
      ソースコード全体に依存しているため、再評価される可能性が非常に高いです。この場合、`eval_always`を
      最適化として使用できます。システムは最初から依存関係の記録をスキップできるためです。

 - `no_hash` - クエリに`no_hash`を適用すると、クエリの結果の
   フィンガープリントを計算しないようにシステムに指示します。これには2つの結果があります:

    - フィンガープリントを計算しないことで、かなりの時間を節約できます。
      フィンガープリントは、特に大きくて複雑な値の場合、高価です。

    - フィンガープリントがないと、システムはクエリの結果が
      変更されたと無条件に仮定する必要があります。その結果、`no_hash`クエリに依存する
      ものはすべて常に再実行されます。

   クエリに`no_hash`を使用することは、2つの状況で意味があります:

    - クエリの結果が、入力の1つが変更されるたびに変更される可能性が非常に高い場合、
      例えば`|a, b, c| -> (a * b * c)`のような関数。このような
      場合、クエリを再計算すると、入力の1つが赤の場合、常に赤いノードが生成されるため、
      トラブルを節約してすぐにデフォルトで赤にすることができます。
      反例は、`|a| -> (a == 42)`のような関数です。この場合、
      結果は`a`のほとんどの変更に対して変更されません。

    - クエリの結果が大きくてモノリシックなコレクション(例: `index_hir`)で、
      そのコレクションから読み取る「プロジェクションクエリ」がある場合
      (例: `hir_owner`)。このような場合、大きなコレクションは上記の
      条件を満たす可能性が高く(変更された入力は、コレクション全体の再計算を意味します)、
      プロジェクションクエリの結果はとにかくハッシュされます。
      コレクションクエリもハッシュする場合、同じデータを実質的に2回ハッシュすることになります:
      コレクションをハッシュするときに1回、すべての
      プロジェクションクエリ結果をハッシュするときにもう1回。`no_hash`を使用すると、
      その冗長性を回避でき、プロジェクションクエリは「ファイアウォール」として機能し、
      無条件に赤い`no_hash`ノードから依存者を保護します。

 - `cache_on_disk_if` - この属性は、インクリメンタルコンパイルクエリ結果
   キャッシュに永続化されるクエリ結果を決定するものです。
   属性は、クエリ呼び出しごとの
   決定を可能にする式を取ります。たとえば、アップストリーム
   クレートの値をキャッシュに保存しても意味がありません。これらはアップストリーム
   クレートのメタデータですでに利用可能だからです。

 - `anon` - この属性により、システムは
   特定のクエリに「匿名」dep-nodeを使用します。匿名dep-nodeは、対応する
   クエリキーによって識別されるのではなく、そのIDは依存関係のIDから計算されます。これにより、
   red-greenシステムは、特定のdep-nodeで利用可能なクエリキーがない場合でも
   変更検出を行うことができます -- これは、クエリに基づいていないため、
   トレイト選択の処理に必要です。

[mod]: ../query.html#adding-a-new-kind-of-query


## プロジェクションクエリパターン

`eval_always`と`no_hash`をいわゆる「プロジェクションクエリ」パターンで
一緒に使用できることは興味深いことです。多くの場合、コンパイラの入力全体に依存する
1つのクエリ(例: インデックス付きHIR)と、このモノリシックな値から
個々の値を投影する別のクエリがあります
(例: 特定の`DefId`を持つHIRアイテム)。これらのプロジェクションクエリは、
モノリシッククエリの結果が変更されたとしても(これは非常に可能性が高い)、
小さなプロジェクションは依然としてほとんど緑色としてマークできるため、
変更伝播「ファイアウォール」を構築できます。


```ignore
  +------------+
  |            |           +---------------+           +--------+
  |            | <---------| projection(x) | <---------| foo(a) |
  |            |           +---------------+           +--------+
  |            |
  | monolithic |           +---------------+           +--------+
  |   query    | <---------| projection(y) | <---------| bar(b) |
  |            |           +---------------+           +--------+
  |            |
  |            |           +---------------+           +--------+
  |            | <---------| projection(z) | <---------| baz(c) |
  |            |           +---------------+           +--------+
  +------------+
```

`monolithic_query`の結果が変更されて、`projection(x)`の結果も変更されたとします。
つまり、両方のdep-nodeが赤としてマークされます。その結果、`foo(a)`を再実行する必要があります。
しかし、`bar(b)`と`baz(c)`は緑色としてマークできます。ただし、`foo`、`bar`、`baz`が
`monolithic_query`に直接依存していた場合、それらすべてを
再評価する必要がありました。

このパターンは`eval_always`と`no_hash`なしでも機能しますが、
2つの修飾子を使用すると、不必要なオーバーヘッドを回避できます。モノリシッククエリが
コンパイラの入力のわずかな変更でも変更される可能性が高い場合、
`eval_always`としてマークすることは理にかなっており、依存関係追跡
コストを取り除くことができます。また、プロジェクションができるだけ多くのものを
緑色に保つように注意しているため、モノリシッククエリを`no_hash`として
マークすることは常に意味があります。


# 現在のシステムの欠点

改善できることはまだたくさんあります。

## オンディスクデータ構造のインクリメンタリティ

現在のシステムは、オンディスクキャッシュと依存関係グラフを
インプレースで更新できません。代わりに、各コンパイル
セッションで各ファイルを完全に書き直す必要があります。そうするオーバーヘッドは、
総コンパイル時間の数パーセントです。

## 不必要なデータ依存関係

クエリ結果として使用されるデータ構造は、依存関係グラフから
エッジを削除する方法で因数分解できます。特に「span」情報は非常に揮発性が高いため、
クエリ結果に含めると、結果が再利用できない可能性が高くなります。
詳細については、<https://github.com/rust-lang/rust/issues/47389>を参照してください。


[query-model]: ./query-evaluation-model-in-detail.html
[try_mark_green]: https://doc.rust-lang.org/nightly/nightly-rustc/src/rustc_query_system/dep_graph/graph.rs.html
