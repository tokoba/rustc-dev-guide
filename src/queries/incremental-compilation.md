# インクリメンタルコンパイル

インクリメンタルコンパイルスキームは、本質的には、全体的なクエリシステムへの驚くほど
シンプルな拡張です。実際のものの少し簡略化されたバリアント--「基本アルゴリズム」--を
説明することから始め、次にいくつかの可能な改善について説明します。

## 基本アルゴリズム

基本アルゴリズムは
**red-green**アルゴリズム[^salsa]と呼ばれています。高レベルのアイデアは、
コンパイラの各実行後に、実行したすべてのクエリの結果と**クエリDAG**を保存するということです。
**クエリDAG**は、どのクエリが他のどのクエリを実行したかをインデックス化する[DAG]です。
したがって、たとえば、Q1の計算にQ2の計算が必要だった場合、クエリQ1から
別のクエリQ2への[エッジ]があります(クエリは自分自身に依存できないため、
これは一般的なグラフではなくDAGになることに注意してください)。

[DAG]: https://en.wikipedia.org/wiki/Directed_acyclic_graph

> **注意**: クエリを単にクエリの定義として考えるかもしれません。
> 呼び出すことができるもの、関数のようなもので、
> キャッシュされた結果を返すか、実際にコードを実行します。
>
> クエリについてそのように考える場合、
> 以下のテキストでは、クエリには色があると言われることを知っておくと良いでしょう。
> ただし、ここでクエリという言葉は、特定の入力に対するクエリの特定の呼び出しも指すことを
> 覚えておいてください。後で読むように、クエリは引数に基づいてフィンガープリントされます。
> クエリの結果は、ある引数を与えたときに変更され、赤色になる可能性がありますが、
> 別の引数では同じままで、したがって緑色になります。
>
> 要するに、ここでクエリという言葉は、クエリの定義を意味するだけでなく、
> 特定の引数を持つそのクエリの特定のインスタンスに対しても使用されます。

コンパイラの次の実行では、クエリの再実行を避けるために、これらの
クエリ結果を再利用できる場合があります。これは、すべてのクエリに**色**を
割り当てることによって行います:

- クエリが**赤**色の場合、このコンパイル中のその結果が
  前回のコンパイルから**変更された**ことを意味します。
- クエリが**緑**色の場合、その結果が
  前回のコンパイルと**同じ**であることを意味します。

ここには2つの重要な洞察があります:

- まず、クエリQへのすべての入力が緑色の場合、
  クエリQは前回と同じ値を生成する**必要があり**、したがって
  再実行する必要はありません(そうでなければコンパイラは決定論的ではありません)。
- 次に、クエリへの一部の入力が変更されたとしても、
  前回のコンパイルと同じ結果を生成する**可能性があります**。
  特に、クエリは入力の一部のみを使用する場合があります。
  - したがって、クエリを実行した後、前回と同じ結果を生成したかどうかを
    常に確認します。**そうであれば**、クエリを緑色としてマークでき、
    したがって依存クエリの再実行を避けることができます。

### try-mark-greenアルゴリズム

インクリメンタルコンパイルの中核には、
「try-mark-green」というアルゴリズムがあります。これは、特定の
クエリQ(まだ実行されていない必要があります)の色を決定する役割があります。Qに
赤い入力がある場合、Qの色を決定するには、出力を比較できるようにQを再実行する必要が
ありますが、Qのすべての入力が緑色の場合、
Qを再実行したり、その値を調べたりすることなく、Qが緑色である必要があると
結論付けることができます。コンパイラでは、これにより、
必要ないときにディスクから結果をデシリアライズすることを避けることができ、実際には
結果の*シリアライズ*をスキップすることもできます
(以下の改善セクションを参照)。

Try-mark-greenは次のように機能します:

- まず、前回のコンパイル中にクエリQが実行されたかどうかを確認します。
  - そうでない場合、通常どおりクエリを再実行し、
    赤色を割り当てることができます。
- はいの場合、Qの「依存クエリ」をロードします。
- 保存された結果がある場合、クエリDAGから`reads(Q)`ベクトルをロードします。
  「reads」は、Qがその実行中に実行したクエリのセットです。
  - `reads(Q)`の各クエリRについて、try-mark-greenを使用して
    Rの色を再帰的に要求します。
    - 注意: `reads(Q)`の各ノードを元のコンパイルで発生したのと同じ順序で
      訪問することが重要です。[以下のクエリDAGのセクション](#dag)を参照してください。
    - `reads(Q)`のノードの**いずれか**が**赤**色になった場合、Qは
      ダーティです。
      - Qを再実行し、その結果のハッシュを前回のコンパイルの
        結果のハッシュと比較します。
      - ハッシュが変更されていない場合、Qを**緑**色としてマークして戻ることができます。
    - それ以外の場合、`reads(Q)`のノードの**すべて**が**緑**色である必要があります。その
      場合、Qを**緑**色として色付けして戻ることができます。

<a id="dag"></a>

### クエリDAG

クエリDAGコードは
[`compiler/rustc_middle/src/dep_graph`][dep_graph]に保存されています。DAGの構築は、
クエリの実行を計装することによって行われます。

重要な点の1つは、クエリDAGも順序を追跡することです。つまり、
各クエリQについて、Qが読み取るクエリを追跡するだけでなく、
それらが読み取られた**順序**も追跡します。これにより、try-mark-greenが
同じ順序でそれらのクエリを逆にたどることができます。これは、
サブクエリが赤として戻ってくると、Qが以前と同じパスに沿って続くかどうかを
確信できなくなるため重要です。つまり、次のようなクエリを想像してください:

```rust,ignore
fn main_query(tcx) {
    if tcx.subquery1() {
        tcx.subquery2()
    } else {
        tcx.subquery3()
    }
}
```

最初のコンパイルで、`main_query`が`subquery1`の実行から始まり、
これがtrueを返すとします。その場合、次に`main_query`が実行するクエリは`subquery2`で、
`subquery3`はまったく実行されません。

しかし、**次の**コンパイルで、入力が変更されて
`subquery1`が**false**を返すとします。この場合、`subquery2`は
決して実行されません。ただし、try-mark-greenが`reads(main_query)`を順序外で訪問した場合、
`subquery1`の前に`subquery2`を訪問し、したがって
実行する可能性があります。
これにより、コンパイラでICEやその他の問題が発生する可能性があります。

[dep_graph]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/dep_graph/index.html

## 基本アルゴリズムの改善

基本アルゴリズムの説明では、コンパイルの最後に
実行されたすべてのクエリの結果を保存すると述べました。実際には、これは非常に無駄になる可能性があります
-- それらの結果の多くは再計算するのが非常に安価であり、
それらをシリアライズおよびデシリアライズすることは特に有益ではありません。実際には、
実行したすべてのサブクエリの**ハッシュ**を保存します。次に、特定のケースで、
結果も**保存**します。

これが、インクリメンタルアルゴリズムがノードの
**色**の計算を、多くの場合その値を必要としないことから、
ノードの**結果**の計算から分離する理由です。結果の計算は、次のような単純な
アルゴリズムを介して行われます:

- Qの保存された結果が利用可能かどうかを確認します。ある場合、Qの色を計算します。
  Qが緑色の場合、保存された結果をデシリアライズして返します。
- それ以外の場合、Qを実行します。
  - その後、結果のハッシュを比較し、変更されていない場合はQを緑色として色付けできます。

## リソース

初期設計ドキュメントは[こちら][initial-design]にあり、
メモ化の詳細を拡張し、このシステムの高レベルの概要と動機を提供します。

# 脚注

[^salsa]: 私は長い間、これをSalsaアルゴリズムに名前を変更したいと思っていましたが、普及しませんでした。-@nikomatsakis

[エッジ]: https://en.wikipedia.org/wiki/Glossary_of_graph_theory_terms#edge
[initial-design]: https://github.com/nikomatsakis/rustc-on-demand-incremental-design-doc/blob/master/0000-rustc-on-demand-and-incremental.md
