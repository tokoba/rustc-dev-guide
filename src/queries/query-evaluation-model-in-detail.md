# クエリ評価モデルの詳細

この章では、クエリが構築される抽象モデルについてより深く掘り下げます。
実装の詳細には触れませんが、基礎となるロジックを
説明しようとします。したがって、ここでの例は、簡略化されており、
コンパイラの内部APIを直接反映していません。

## クエリとは何ですか?

抽象的に言えば、特定のクレートに関するコンパイラの知識を「データベース」として見なし、
クエリはコンパイラにそれについて質問する方法です。つまり、
コンパイラの「データベース」に事実を「クエリ」します。

ただし、このコンパイラデータベースには特別なものがあります: 空の状態から始まり、
クエリが実行されるときにオンデマンドで埋められます。その結果、クエリは、
データベースにまだ含まれていない場合、その結果を計算する方法を知っている必要があります。
そのために、他のクエリとデータベースが作成時に事前に埋められている特定の入力値に
アクセスできます。

したがって、クエリは次のもので構成されます:

 - クエリを識別する名前
 - 何を検索したいかを指定する「キー」
 - どのような結果を生成するかを指定する結果の型
 - 「プロバイダー」。これは、結果がまだデータベースに存在しない場合に
   結果を計算する方法を指定する関数です。

例として、`type_of`クエリの名前は`type_of`で、クエリキーは
型を知りたいアイテムを識別する`DefId`で、結果の型は
`Ty<'tcx>`で、プロバイダーは、クエリキーと
データベースの残りの部分へのアクセスが与えられると、キーによって識別されるアイテムの型を
計算できる関数です。

したがって、ある意味では、クエリは単にクエリキーを対応する
結果にマッピングする関数です。ただし、これが健全であるためには、
いくつかの制限を適用する必要があります:

 - キーと結果は不変の値でなければなりません。
 - プロバイダー関数は、同じキーに対して常に同じ結果を生成するという意味で
   純粋関数でなければなりません。
 - プロバイダー関数が取る唯一のパラメーターは、キーと
   「クエリコンテキスト」への参照(「データベース」の残りの部分へのアクセスを提供します)です。

データベースは、クエリを呼び出すことによって遅延的に構築されます。クエリプロバイダーは
他のクエリを呼び出し、その結果はすでにキャッシュされているか、
別のクエリプロバイダーを呼び出すことによって計算されます。これらのクエリプロバイダー呼び出しは、
概念的には、葉がクエリコンテキストの作成時にすでにわかっている
入力値である有向非循環グラフ(DAG)を形成します。



## キャッシング/メモ化

クエリ呼び出しの結果は「メモ化」されます。これは、クエリコンテキストが
結果を内部テーブルにキャッシュし、同じクエリキーで再度クエリが呼び出されると、
プロバイダーを再度実行する代わりにキャッシュから結果を返すことを意味します。

このキャッシングは、クエリエンジンを効率的にするために重要です。メモ化がないと、
システムは依然として健全です(つまり、同じ結果を生成します)が、
同じ計算が何度も行われます。

メモ化は、クエリプロバイダーが純粋関数でなければならない主な理由の1つです。
プロバイダー関数を呼び出すと、呼び出しごとに異なる結果を生成できる場合
(グローバルな可変状態にアクセスするため)、結果をメモ化することはできません。



## 入力データ

クエリコンテキストが作成されると、まだ空です: クエリは実行されておらず、
結果はキャッシュされていません。ただし、コンテキストは、
コンテキストが作成される前に計算された不変データである「入力」データへの
アクセスをすでに提供しています。クエリは、計算を実行するためにアクセスできます。

<!-- date-check --> 2021年1月時点では、この入力データは主に
HIRマップ、アップストリームクレートメタデータ、コンパイラが呼び出されたコマンドライン
オプションで構成されています。ただし、将来的には、入力はコマンドライン
オプションとソースファイルのリストだけで構成されます -- HIRマップ自体は、
これらのソースファイルを処理するクエリによって提供されます。

入力がないと、クエリは結果を計算するものがない空間に住むことになります
(クエリプロバイダーは他のクエリと
コンテキストへのアクセスしかなく、他の外部状態や情報はありません)。

クエリプロバイダーにとって、入力データと他のクエリの結果は
まったく同じに見えます: コンテキストに「Xの値を教えてください」と伝えるだけです。
入力データは不変であるため、プロバイダーは、クエリ結果の場合と同様に、
異なるクエリ呼び出しにわたって同じであることを信頼できます。



## いくつかのクエリの実行トレースの例

このクエリ呼び出しのDAGはどのようにして存在するのでしょうか? ある時点で、
コンパイラドライバーは、まだ空のクエリコンテキストを作成します。次に、
クエリシステムの外部から、タスクを実行するために必要なクエリを呼び出します。
これは次のようになります:

```rust,ignore
fn compile_crate() {
    let cli_options = ...;
    let hir_map = ...;

    // クエリコンテキスト`tcx`を作成します
    let tcx = TyCtxt::new(cli_options, hir_map);

    // 型チェッククエリを呼び出して型チェックを実行します
    tcx.type_check_crate();
}
```

`type_check_crate`クエリプロバイダーは次のようになります:

```rust,ignore
fn type_check_crate_provider(tcx, _key: ()) {
    let list_of_hir_items = tcx.hir_map.list_of_items();

    for item_def_id in list_of_hir_items {
        tcx.type_check_item(item_def_id);
    }
}
```

`type_check_crate`クエリが入力データ
(`tcx.hir_map.list_of_items()`)にアクセスし、他のクエリ
(`type_check_item`)を呼び出すことがわかります。`type_check_item`
呼び出し自体は、入力データにアクセスしたり、他のクエリを呼び出したりするため、
最終的には、最初に実行されたノードから逆方向に、
クエリ呼び出しのDAGが構築されます:

```ignore
         (2)                                                 (1)
  list_of_all_hir_items <----------------------------- type_check_crate()
                                                               |
    (5)             (4)                  (3)                   |
  Hir(foo) <--- type_of(foo) <--- type_check_item(foo) <-------+
                                      |                        |
                    +-----------------+                        |
                    |                                          |
    (7)             v  (6)                  (8)                |
  Hir(bar) <--- type_of(bar) <--- type_check_item(bar) <-------+

// (x) は呼び出し順序を示します
```

また、多くの場合、クエリ結果をキャッシュから読み取ることができることもわかります:
`type_of(bar)`は`type_check_item(foo)`に対して計算されたため、
`type_check_item(bar)`が必要とするときには、すでにキャッシュにあります。

クエリ結果は、コンテキストが存続する限り、クエリコンテキストにキャッシュされたままです。
したがって、コンパイラドライバーが後で別のクエリを呼び出した場合、
上記のグラフは依然として存在し、すでに実行されたクエリを再度実行する必要はありません。



## サイクル

前述のように、クエリ呼び出しはDAGを形成すると述べました。ただし、たとえば次のような
クエリプロバイダーを持つことによって、循環グラフを形成するのは簡単です:

```rust,ignore
fn cyclic_query_provider(tcx, key) -> u32 {
  // 同じキーで同じクエリを再度呼び出します
  tcx.cyclic_query(key)
}
```

クエリプロバイダーは通常の関数であるため、これは期待どおりに動作します:
評価は無限再帰でスタックします。このようなクエリはあまり有用ではありません。
ただし、特定の種類の無効なユーザー入力により、クエリが循環的に呼び出される
場合があります。クエリエンジンには、同じ入力引数を持つクエリの循環呼び出しの
チェックが含まれています。また、サイクルは回復不可能なエラーであるため、
人間が読めるようにしようとする「サイクルエラー」メッセージで実行を中止します。

ある時点で、コンパイラには「サイクルリカバリ」の概念がありました。つまり、
クエリの実行を「試行」でき、サイクルを引き起こすことになった場合は、
他の方法で進むことができました。ただし、これは後で削除されました。
特にインクリメンタルコンパイルに関して、これの理論的な結果が完全に
明確ではないためです。


## 「Steal」クエリ

一部のクエリには、結果が`Steal<T>`構造体でラップされています。これらのクエリは、
1つの例外を除いて、通常のクエリとまったく同じように動作します: その結果は、
ある時点でキャッシュから「盗まれる」ことが予想されます。つまり、プログラムの
他の部分がその所有権を取得し、結果にアクセスできなくなります。

この盗み取りメカニズムは、純粋にパフォーマンスの最適化として存在します。
一部の結果値はクローンするのが非常にコストがかかるためです(例: 関数のMIR)。
結果の盗み取りは、クエリ結果が不変でなければならないという条件に違反するように
見えますが(結局のところ、結果値をキャッシュから移動しています)、
変異が観察可能でない限り、問題ありません。これは2つのことによって達成されます:

- 結果が盗まれる前に、その結果を読み取る必要がある可能性のあるすべてのクエリを
  積極的に実行します。これは、それらのクエリを呼び出すことによって手動で行う必要があります。
- クエリが盗まれた結果にアクセスしようとすると、ICE
  (Internal Compiler Error)を作成して、そのような状態が気付かれないようにします。

これは、手動介入が必要なため、理想的なセットアップではありません。したがって、
控えめに使用し、特定のクエリがどの結果にアクセスする可能性があるかがよくわかっている
場合にのみ使用する必要があります。ただし、実際には、盗み取りは
メンテナンスの負担にはなっていません。

要約すると: 「Stealクエリ」は、制御された方法でいくつかのルールを破ります。
何も静かに間違いが起こらないようにするためのチェックがあります。
