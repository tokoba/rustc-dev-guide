# Salsaの仕組み

この章は、Niko Matsakisによる
[ビデオ](https://www.youtube.com/watch?v=_muY4HjSqVw)での
[Salsa](https://github.com/salsa-rs/salsa)についての説明に基づいています。詳細については、
Niko Matsakisによる[Salsa In More
Depth](https://www.youtube.com/watch?v=i_IhACacPRY)も視聴してください。

> <!-- date-check --> 2022年11月時点では、Salsaは(他のものの中でも)rustcのクエリシステムに
> 触発されていますが、rustcで直接使用されていません。
> [chalk](Rustのトレイトシステムの実装)で*使用*され、
> Rustの言語サーバープロトコルの公式実装である[`rust-analyzer`]で
> 広範に使用されていますが、コンパイラに統合するための中期または長期の具体的な
> 計画はありません。

[`rust-analyzer`]: https://rust-analyzer.github.io/
[chalk]: https://rust-lang.github.io/chalk/book/what_is_chalk.html

## Salsaとは何ですか?

Salsaは、インクリメンタル再計算のためのライブラリです。これは、
将来の計算の効率を高めるために、過去に既に行われた計算を再利用できることを意味します。

Salsaの目的は:
 * その機能を自動的に提供すること。したがって、古い計算の再利用は
   ライブラリによって自動的に行われます。
 * これを「健全」または「正しい」方法で行うこと。したがって、
   スクラッチから行われたかのように同じ結果につながります。

Salsaの実際のモデルははるかに豊かで、多くの種類の入力と多くの異なる出力を可能にします。
たとえば、SalsaをIDEと統合すると、
入力はマニフェスト(`Cargo.toml`、`rust-toolchain.toml`)、
ソースファイル全体(`foo.rs`)、スニペットなどになる可能性があります。このような統合の
出力は、バイナリ実行可能ファイルから、リント、型(たとえば、ユーザーが
特定の変数を選択してその型を確認したい場合)、補完などにまで及ぶ可能性があります。

## 仕組みは?

Salsaが最初に行う必要があるのは、計算されたものではなく、
入力として与えられる「ベース入力」を識別することです。

次に、Salsaは中間の「派生」値も識別する必要があります。これは
ライブラリが生成するものですが、各派生値について、
派生値を計算する「純粋な」関数があります。

たとえば、`ast(x: Path) -> AST`という関数がある場合があります。生成された
抽象構文木(`AST`)は最終的な値ではなく、ライブラリが
計算に使用する中間値です。

これは、ライブラリで計算しようとすると、Salsaが
様々な派生値を計算し、最終的に入力を読み取って、要求された計算の
結果を生成することを意味します。

計算の過程で、Salsaは、どの入力がアクセスされたか、どの
値が派生されたかを追跡します。この情報は、入力が変更されたときに何が
起こるかを決定するために使用されます: 派生値はまだ有効ですか?

これは、入力からの各計算のダウンストリームが
チェックされることを必ずしも意味しません。これはコストがかかる可能性があります。Salsaは、
変更されていないものを見つけるまで、各ダウンストリーム計算をチェックするだけです。
その時点で、それらは変更する必要がないため、他の派生計算を
チェックしません。

これをノードを持つグラフとして考えると役立ちます。各派生値は
他の値に依存しており、それら自体がベースまたは
派生である可能性があります。ベース値には依存関係がありません。

```ignore
I <- A <- C ...
          |
J <- B <--+
```

入力`I`が変更されると、派生値`A`が変更される可能性があります。派生
値`B`は、`I`、`A`、または`A`や
`I`から派生した値に依存しないため、変更の対象にはなりません。したがって、Salsaは、
再度計算することなく、過去に`B`に対して行った計算を再利用できます。

計算は早期に終了することもできます。以前と同じグラフを維持し、
入力`I`が何らかの方法で変更されたとします(入力`J`は変更されていません)が、
`A`を再度計算すると、`A`が前回の計算から
変更されていないことがわかります。これは「早期終了」につながります。`C`の両方の直接入力である`A`と`B`が
変更されていないため、`C`が変更する必要があるかどうかをチェックする必要はないためです。

## Salsaの主要な概念

### クエリ

クエリは、Salsaが計算の過程でアクセスできる何らかの値です。各
クエリには、いくつかのキー(0から多数まで)を持つことができ、すべてのクエリには
結果があり、関数に似ています。`0-key`クエリは「入力」クエリと呼ばれます。

### データベース

データベースは基本的に、計算全体のコンテキストです。Salsaの内部状態、
各クエリのすべての中間値、計算が必要とするその他のものを保存することを目的としています。
データベースは、ライブラリが実行するすべてのクエリを
構築される前に知っている必要がありますが、同じ場所で指定する必要はありません。

データベースが形成されると、関数に非常に
類似したクエリでアクセスできます。各クエリの結果はデータベースに保存されるため、
クエリが`N`回呼び出されると、入力がそのような方法で変更されて
再計算が必要にならない限り、再計算することなく、`N`個の**クローン**された結果を返します。

各入力クエリ(`0-key`)に対して、「set」メソッドが生成され、ユーザーが
そのようなクエリの出力を変更し、以前にメモ化された値が
無効化される可能性があることをトリガーできます。

### クエリグループ

クエリグループは、ユニットとして一緒に定義されたクエリのセットです。
データベースは、クエリグループを組み合わせることによって形成されます。クエリグループは、
「Salsaモジュール」に似ています。

クエリグループ内のクエリのセットは、トレート内のメソッドのセットです。

クエリグループを作成するには、特定の属性
(`#[salsa::query_group(...)]`)で注釈が付けられたトレートを作成する必要があります。

また、引数を前記属性に提供する必要があります。これは、Salsaが
データベースが作成されるときに後で使用される`struct`を作成するために使用されるためです。

入力クエリグループの例:

```rust,ignore
/// この属性は、このツリーを処理し、このツリーを出力として生成し、Salsaも使用する
/// 中間的なものの束を生成します。これらのうちの1つは
/// 「StorageStruct」で、その名前を属性で指定しました。
///
/// このクエリグループは、派生入力に依存しない**入力**クエリの束です。
#[salsa::query_group(InputsStorage)]
pub trait Inputs {
    /// この属性(`#[salsa::input]`)は、このクエリがベース
    /// 入力であることを示すため、`set_manifest`が自動生成されます
    #[salsa::input]
    fn manifest(&self) -> Manifest;

    #[salsa::input]
    fn source_text(&self, name: String) -> String;
}
```

**派生**クエリグループを作成するには、このグループが依存する他のクエリグループを
スーパートレートとして指定することによって指定する必要があります。次の
例を参照してください:

```rust,ignore
/// このクエリグループには、派生値に依存するクエリが含まれます。
/// クエリグループは、
/// 依存関係をスーパートレートとして指定することによって、別のクエリグループのクエリにアクセスできます。
/// クエリグループは、そのパターンを使用して必要なだけスタックできます。
#[salsa::query_group(ParserStorage)]
pub trait Parser: Inputs {
    /// このクエリ`ast`は入力クエリではなく、派生クエリです。これは
    /// 定義が必要であることを意味します。
    fn ast(&self, name: String) -> String;
}
```

派生クエリを作成するときは、そのクエリの実装を
トレートの外部で定義する必要があります。定義は、他のキーに加えて、
`impl Trait`(または`dyn Trait`)としてデータベースパラメーターを取る必要があります。ここで、トレートは、
定義が属するクエリグループです。

```rust,ignore
/// これは、`Parser`トレートの`ast`クエリの定義になります。
/// したがって、クエリ`ast`が呼び出され、再計算する必要がある場合、Salsaは
/// この関数を呼び出し、データベースを`impl
/// Parser`として与えます。この関数は、すべてのクエリグループのすべてのクエリを
/// 認識している必要はありません
fn ast(db: &impl Parser, name: String) -> String {
    //! 注意、`impl Parser`はここで使用されていますが、`dyn Parser`も同様に機能します
    /* code */
    ///`impl Parser`を渡すことで、これが許可されます
    let source_text = db.input_file(name);
    /* do the actual parsing */
    return ast;
}
```

最終的に、すべてのクエリグループが定義された後、
`struct`を宣言することによってデータベースを作成できます。

データベースの一部になるクエリグループを指定するには、`attribute`
(`#[salsa::database(...)]`)を追加する必要があります。前記`attribute`の引数は、
クエリグループ**ストレージ**を指定する`identifier`のリストです。

```rust,ignore
///この属性は、データベースに含まれるクエリグループを指定します
#[salsa::database(InputsStorage, ParserStorage)]
#[derive(Default)] //optional!
struct MyDatabase {
    ///このフィールドも必要です
    runtime : salsa::Runtime<MyDatabase>,
}
///このトレートを実装する必要があります
impl salsa::Database for MyDatabase {
    fn salsa_runtime(&self) -> &salsa::Runtime<MyDatabase> {
        &self.runtime
    }
}
```

使用例:

```rust,ignore
fn main() {
    let db = MyDatabase::default();
    db.set_manifest(...);
    db.set_source_text(...);
    loop {
        db.ast(...); //will reuse results
        db.set_source_text(...);
    }
}
```
