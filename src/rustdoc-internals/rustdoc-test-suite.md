# `rustdoc`テストスイート

このページは、`rustdoc`のHTML出力をテストするために使用される`rustdoc`という名前のテストスイートについて説明します。
他のrustdoc固有のテストスイートについては、[Rustdocテストスイート]を参照してください。

このテストスイートの各テストファイルは、通常のRustコードコメント内に配置された
いわゆる*ディレクティブ*が散りばめられた単純なRustソースファイル`file.rs`です。
これらには2つの種類があります：*Compiletest*と*HtmlDocCk*です。

前者について詳しく学ぶには、[Compiletestディレクティブ]をお読みください。
後者については、読み続けてください。

内部的には、[`compiletest`]は補助チェッカースクリプト[`htmldocck.py`]を呼び出します。

[Rustdocテストスイート]: ../tests/compiletest.md#rustdoc-test-suites
[`compiletest`]: ../tests/compiletest.md
[`htmldocck.py`]: https://github.com/rust-lang/rust/blob/HEAD/src/etc/htmldocck.py

## HtmlDocCkディレクティブ

HtmlDocCkへのディレクティブは、生成されたHTMLに制約を課すアサーションです。
これらは、`//@`コメントの形式を取るという点で`compiletest`に与えられるものと似ていますが、
最終的には完全に異なり、異なるプログラムによって処理されます。

[XPath]は、HTMLドキュメントツリーの一部をクエリするために使用されます。

**入門例**：

```rust,ignore (illustrative)
//@ has file/type.Alias.html
//@ has - '//*[@class="rust item-decl"]//code' 'type Alias = Option<i32>;'
pub type Alias = Option<i32>;
```

ここでは、クレート`file`用に生成されたドキュメントに、
パブリック型エイリアス`Alias`のページが含まれており、
上部にあるコードブロックにアイテムの期待されるレンダリングが含まれていることをチェックします。
`//*[@class="rust item-decl"]//code`はXPath式です。

慣例的には、これらのディレクティブをテストする対象の直前に配置します。
しかし、技術的には、HtmlDocCkはディレクティブのみを探すため、その必要はありません。

すべてのディレクティブは`PATH`引数を取ります。
繰り返しを避けるために、`-`を渡して前の`PATH`引数を再利用できます。
パスにはクレートの名前が含まれるため、慣例的にクレートルートに
`#![crate_name = "foo"]`属性を追加して、結果のパスを短縮します。

すべての引数は、シェルスタイルの（単一または二重の）引用符で囲まれた文字列の形式を取ります。
ただし、`COUNT`と特別な`-`形式の`PATH`は除きます。

すべてのディレクティブ（`files`を除く）は、名前の前に`!`を置くことで*否定*できます。
否定されたディレクティブを追加する前に、[その注意点](#caveats)をお読みください。

シェルコマンドと同様に、
最後の文字が`\`の場合、ディレクティブは複数行にわたることができます。
この場合、次の行の開始は`//`である必要があり、`@`は不要です。

compiletestディレクティブと同様に、スペースの他にコロン`:`を使用して
ディレクティブ名と引数を区切ることもできますが、HtmlDocCkディレクティブにはスペースが推奨されます。

現在のリリースチャネル（例：`stable`または`nightly`）を参照する`https://doc.rust-lang.org/CHANNEL`というURLを参照したい場合は、
XPath、`PATTERN`引数、[スナップショットファイル](#snapshot)で特別な文字列`{{channel}}`を使用してください。

以下にリストされているのは、可能なすべてのディレクティブです：

[XPath]: https://en.wikipedia.org/wiki/XPath

### `has`

> 使用法1: `//@ has PATH`

`PATH`で指定されたファイルが存在することをチェックします。

> 使用法2: `//@ has PATH XPATH PATTERN`

`PATH`で指定された空白正規化された[^1]ファイル内の`XPATH`によって選択された
各要素/属性/テキストのテキストが、
（同様に空白正規化された）文字列`PATTERN`と一致することをチェックします。

**ヒント**: 空白の正規化を避けたい場合や、正規表現で一致させたい場合は、
代わりに`matches`を使用してください。

### `hasraw`

> 使用法: `//@ hasraw PATH PATTERN`

`PATH`で指定された空白正規化された[^1]ファイルの内容が、
（同様に空白正規化された）文字列`PATTERN`と一致することをチェックします。

**ヒント**: 空白の正規化を避けたい場合や、正規表現で一致させたい場合は、
代わりに`matchesraw`を使用してください。

### `matches`

> 使用法: `//@ matches PATH XPATH PATTERN`

`PATH`で指定されたファイル内の`XPATH`によって選択された
各要素/属性/テキストのテキストが、
Python風の[^2]正規表現`PATTERN`と一致することをチェックします。

### `matchesraw`

> 使用法: `//@ matchesraw PATH PATTERN`

`PATH`で指定されたファイルの内容が、
Python風の[^2]正規表現`PATTERN`と一致することをチェックします。

### `count`

> 使用法: `//@ count PATH XPATH COUNT`

`PATH`で指定されたファイル内の`XPATH`の一致が正確に`COUNT`個であることをチェックします。

### `snapshot`

> 使用法: `//@ snapshot NAME PATH XPATH`

`PATH`で指定されたファイル内の`XPATH`によって選択された要素/テキストが、
ファイル`FILE_STEM.NAME.html`内の事前記録されたサブツリーまたはテキスト（「スナップショット」）と一致することをチェックします。
ここで、`FILE_STEM`はテストファイルのファイルステムです。

現在のサブツリー/テキストを期待されるものとして受け入れるには、`compiletest`に`--bless`オプションを渡します。
これにより、前述のファイルが上書きされます（存在しない場合は作成されます）。チャネル依存のURL `https://doc.rust-lang.org/CHANNEL`を
特別な文字列`{{channel}}`に自動的に正規化します。

### `has-dir`

> 使用法: `//@ has-dir PATH`

`PATH`で指定されたディレクトリの存在をチェックします。

### `files`

> 使用法: `//@ files PATH ENTRIES`

`PATH`で指定されたディレクトリに正確に`ENTRIES`が含まれていることをチェックします。
`ENTRIES`は、引用符で囲まれた文字列内のPython風の文字列のリストです。

**例**: `//@ files "foo/bar" '["index.html", "sidebar-items.js"]'`

[^1]: 空白の正規化とは、連続する空白のすべてのスパンが単一のスペースに置き換えられることを意味します。
[^2]: Unicode対応（`UNICODE`フラグが設定）、大文字小文字を区別し、単一行モードで一致します。

## Compiletestディレクティブ（簡単に）

冒頭で述べたように、[compiletestディレクティブ]にもアクセスできます。
最も重要なのは、補助クレートを登録したり、
テスト対象の`rustdoc`バイナリにフラグを渡したりできることです。
まだ何も知らない場合は、その章を読むことを*強くお勧め*します。

このテストスイートに特に関連する詳細は次のとおりです：

* `//@ compile-flags`と`//@ doc-flags`の両方を使用して`rustdoc`にフラグを渡すことができますが、
  意図を示すために後者を使用することをお勧めします。前者は`rustc`向けです。
* 補助クレートを持つテストファイルに`//@ build-aux-docs`を追加して、
  補助クレートを`rustc`でコンパイルするだけでなく、`rustdoc`でドキュメント化することもできます。

## 注意点

要素やテキストの不在をテストすることは、非常に脆弱で、将来の証拠にはなりません。

生成されたHTMLドキュメントツリーの*形状*は、時々変わることは珍しくありません。
これには、たとえばCSSクラスの名前変更が含まれます。

そのようなことが起こるたびに、*肯定的な*チェックは、
意図された要素/属性/テキストに一致し続けるか（XPath式が十分に一般的/緩い場合）、
したがって正しいことをテストし続けるか、一致しない場合は失敗し、
変更の作成者にそれらを見るように強制します。

それを*否定的な*チェック（例：`//@ !has PATH XPATH PATTERN`）と比較すると、
XPath式が「もはや」一致しない場合、失敗しません。したがって、「形状」を変更した作成者は通知されず、
その結果、元の否定的なチェックが失敗することなく、
誰かが誤って`PATTERN`を生成されたドキュメントに再導入する可能性があります。

**注意**: *否定された*チェックの使用を避けてください！

**ヒント**: それを避けられない場合は、**常に**同様の肯定的なチェックと
すぐ近くでペアにしてください。そうすれば、「形状」を変更する人が気づいて
否定されたチェックを更新する機会があります！

## 制限事項

HtmlDocCkは、Python標準ライブラリのXPath実装を使用します。
これにより、いくつかの制限があります：

* 実装の欠陥により、すべての`XPATH`引数は`//`で始まる必要があります。
* 多くのXPath機能（関数、軸など）はサポートされていません。
* 整形式のHTMLのみが解析できます（うまくいけば、rustdocは不一致のタグを出力しません）。

さらに、compiletest[リビジョン]はサポートされていません。

[リビジョン]: ../tests/compiletest.md#revisions
[compiletestディレクティブ]: ../tests/directives.md
[Compiletestディレクティブ]: ../tests/directives.md
