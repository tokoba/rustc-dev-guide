# Rustdoc検索

Rustdoc検索は2つのプログラムです：`search_index.rs`と`search.js`です。
最初のものは、ドキュメントバンドル内のクレートにある
アイテムと関数シグネチャの完全なリストを含む厄介なJSONファイルを生成し、
2番目のものはそれを読み込み、いくつかのインメモリ構造に変換し、
それらを線形にスキャンして検索します。

## 検索インデックス形式

`search.js`は、読み込み後にそれをより通常のオブジェクトツリーに変換するため、
これをRawと呼びます。
スペースを節約するために、改行やスペースなしで書かれています。

```json
[
    [ "crate_name", {
        // name
        "n": ["function_name", "Data"],
        // type
        "t": "HF",
        // parent module
        "q": [[0, "crate_name"]],
        // parent type
        "i": [2, 0],
        // type dictionary
        "p": [[1, "i32"], [1, "str"], [5, "Data", 0]],
        // function signature
        "f": "{{gb}{d}}`", // [[3, 1], [2]]
        // impl disambiguator
        "b": [],
        // deprecated flag
        "c": "OjAAAAAAAAA=", // empty bitmap
        // empty description flag
        "e": "OjAAAAAAAAA=", // empty bitmap
        // aliases
        "a": [["get_name", 0]],
        // description shards
        "D": "g", // 3
        // inlined re-exports
        "r": [],
    }]
]
```

[`src/librustdoc/html/static/js/rustdoc.d.ts`]は、
TypeScript `type`で実際のスキーマを定義しています。

| キー | 名前                 | 説明  |
| --- | -------------------- | ------------ |
| `n` | 名前                | アイテム名   |
| `t` | アイテムタイプ            | 1文字のアイテムタイプコード |
| `q` | 親モジュール        | `Map<index, path>` |
| `i` | 親タイプ          | インデックスのリスト |
| `f` | 関数シグネチャ   | [エンコード済み](#i-f-and-p) |
| `b` | impl曖昧性除去   | `Map<index, string>` |
| `c` | 非推奨フラグ     | [roaringビットマップ](#roaring-bitmaps) |
| `e` | 説明は空 | [roaringビットマップ](#roaring-bitmaps) |
| `p` | 型辞書      | `[[item type, path]]` |
| `a` | エイリアス                | `Map<string, index>` |
| `D` | 説明シャード   | [エンコード済み](#how-descriptions-are-stored) |

上記のインデックスは、`crate_name`というクレートを定義し、
`function_name`というfree関数と`Data`という構造体を持ち、
型シグネチャは`Data, i32 -> str`で、
`get_name`というエイリアスがあり、これは`function_name`と等価に参照します。

[`src/librustdoc/html/static/js/rustdoc.d.ts`]: https://github.com/rust-lang/rust/blob/2f92f050e83bf3312ce4ba73c31fe843ad3cbc60/src/librustdoc/html/static/js/rustdoc.d.ts#L344-L390

検索インデックスは、`rustdoc`コンパイラのニーズ、
`search.js`フロントエンドのニーズ、
そしてコンパクトで高速にデコードできる必要性に合わせる必要があります。
多くの妥協をしています：

* `rustdoc`コンパイラは一度に1つのクレートで実行されるため、
  各クレートには本質的に別々の検索インデックスがあります。
  各クレートを1行に配置し、
  最初の引用符で囲まれた文字列を見ることで、それらを[マージ]します。
* 検索インデックス内の名前は、
  元の大文字小文字とアンダースコア付きで与えられます。
  検索インデックスが読み込まれると、
  `search.js`は表示用に元の名前を保存しますが、
  検索用に小文字に変換してアンダースコアを削除します。
  これらは`normalized`と呼ばれます。
* `f`配列は、`p`配列へのオフセットとして型を格納します。
  これらの型は実際には別のクレートからのものである可能性があるため、
  `search.js`は番号を名前に変換し、次に
  番号に戻して、同じインデックス内の複数のクレートが
  同じ型に言及している場合に重複を除去する必要があります。
* JSONファイルですが、人間が読めるように設計されていません。
  ブラウザにはすでに最適化されたJSONデコーダーが含まれているため、
  これにより`search.js`のコードが節約され、小さなクレートのパフォーマンスが向上しますが、
  通常のJSON形式のようにオブジェクトを使用する代わりに、
  [DEFLATE]で使用されるスライディングウィンドウが冗長性を見つけられるように、
  同じ型のデータを隣り合わせに配置しようとします。
  `search.js`が独自の圧縮を行う場合、
  ファイルがついに読み込まれたときにメモリを節約するように設計されており、
  ディスクやネットワーク転送のサイズだけではありません。

[マージ]: https://github.com/rust-lang/rust/blob/79b710c13968a1a48d94431d024d2b1677940866/src/librustdoc/html/render/write_shared.rs#L151-L164
[DEFLATE]: https://en.wikipedia.org/wiki/Deflate

### 並列配列とインデックス付きマップ

抽象的には、Rustdoc検索データはテーブルであり、列優先形式で保存されます。
インデックス内のほとんどのデータは、並列配列のセット
（「列」）を表し、同じ位置にある場合は同じデータを参照します。

たとえば、
上記の検索インデックスは次のテーブルに変換できます：

|   | n | t | [d] | q | i | f | b | c |
|---|---|---|-----|---|---|---|---|---|
| 0 | `crate_name`    | `D` | Documentation | NULL | 0 | NULL | NULL | 0 |
| 1 | `function_name` | `H` | This function gets the name of an integer with Data | `crate_name` | 2 | `{{gb}{d}}` | NULL | 0 |
| 2 | `Data` | `F` | The data struct | `crate_name` | 0 | `` ` `` | NULL | 0 |

[d]: #how-descriptions-are-stored

クレート行は、そのタイプが既知であるため（クレートです）、
親を持つことができないため（クレートはモジュールツリーのルートを形成します）、
名前はマップキーとして指定されているため、
impl曖昧性除去のような関数固有のデータも適用できないため、
ほとんどの列で暗黙的です。
ただし、説明を持つことができ、非推奨にすることもできます。
したがって、クレートには主キー`0`があります。

上記のコードは、非推奨のインデックスを保持する`c`や、
インデックスを文字列にマップする`b`を使用していません。
`crate_name::function_name`が両方を使用する場合、次のようになります。

```json
        "b": [[0, "impl-Foo-for-Bar"]],
        "c": "OjAAAAEAAAAAAAIAEAAAABUAbgZYCQ==",
```

これにより、インデックス1に曖昧性除去器がアタッチされ、非推奨としてマークされます。

このレイアウトの利点は、これらのAPIにDEFLATEが利用できる暗黙的な構造があることが多いことですが、
rustdocは仮定できません。
名前は通常CamelCaseまたはsnake_caseですが、
説明はそうではありません。
また、ブール値フラグのようなものにスパースデータを使用しやすくなります。

`q`は、*最初に適用可能な*IDから親モジュールパスへのマップです。
これは奇妙なトリックですが、擬似コードでより理にかなっています：

```rust
let mut parent_module = "";
for (i, entry) in search_index.iter().enumerate() {
    if q.contains(i) {
        parent_module = q.get(i);
    }
    // ... `entry`で他のことをする ...
}
```

すべてに親モジュールがあるため（クレート自体だけでも）、
これは有効であり、
rustdocジェネレータがシリアル化する前にパスでソートするため、
組み立てやすいです。
これにより、rustdocは検索インデックスを小さくするだけでなく、
複数のメモリ内アイテムで親パスを表す同じ文字列を再利用できます。

### スパース列の表現

#### VLQ 16進数

この形式は、私が知る限り、rustdoc以外ではどこでも使用されていません。
次の文法に従います：

```ebnf
VLQHex = { VHItem | VHBackref }
VHItem = VHNumber | ( '{', {VHItem}, '}' )
VHNumber = { '@' | 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I' | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' }, ( '`' | 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i' | 'j' | 'k ' | 'l' | 'm' | 'n' | 'o' )
VHBackref = ( '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' | ':' | ';' | '<' | '=' | '>' | '?' )
```

VHNumberは、可変長、自己終端の16進数です
（最後の16進数字が小文字で、他のすべてが大文字であるため、終端されます）。
符号ビットは[ジグザグエンコーディング]を使用して表されます。

このアルファベットが選ばれたのは、
ASCIIエンコーディングの最後の4ビットをマスクオフすることで、
文字を16進数字に変換できるためです。

rustdocで行われるすべての「圧縮」と同様に、
この形式の主要な機能は、*実行時にメモリ内でも圧縮形式のままでいられる*ことです。
これが、`HBackref`がトップレベルでのみ使用される理由であり、
すべてに[Flate]を使用しない理由です：search.jsのデコーダーは、
backrefが表示されるたびにデコードされたオブジェクト全体を再利用し、
デコード作業とメモリを節約します。

[ジグザグエンコーディング]: https://en.wikipedia.org/wiki/Variable-length_quantity#Zigzag_encoding
[Flate]: https://en.wikipedia.org/wiki/Deflate

#### Roaringビットマップ

非推奨や空の説明などのフラグスタイルのデータは、
[ランを含む標準のRoaringビットマップシリアル化形式]を使用して格納されます。
データは書き込み時にbase64エンコードされます。

簡単な概要：roaringビットマップは、
[この論文]で説明されている、ビットのチャンク化された配列です。
チャンクは、整数のリスト、ビットフィールド、またはランのリストのいずれかです。
いずれの場合も、検索エンジンはbase64デコードし、
チャンクインデックス自体を読み取る必要がありますが、
ペイロードデータはそのままです。

rustdocのすべてのroaringビットマップは、現在、各アイテムインデックスのフラグを格納します。
クレートはアイテム0で、他のすべては1から始まります。

[ランを含む標準のRoaringビットマップシリアル化形式]: https://github.com/RoaringBitmap/RoaringFormatSpec
[この論文]: https://arxiv.org/pdf/1603.06549.pdf

### 説明の保存方法

最大量のデータ、
そしてRustdoc検索が扱う主なもので、
実際には検索に使用されないものは、説明です。
SERPテーブルでは、これは右端の列に表示されるものです。

> | アイテムタイプ | アイテムパス             | ***説明*** (この部分)                       |
> | --------- | --------------------- | --------------------------------------------------- |
> | 関数  | my_crate::my_function | This function gets the name of an integer with Data |

誰かが初めてrustdocで検索を実行すると、ブラウザは
3つのステップの「サンドイッチワークロード」を処理します：

1. search-index.jsとsearch.jsファイルをダウンロードする（ネットワークボトルネック）。
2. 実際の検索を実行する（CPUとメモリ帯域幅のボトルネック）。
3. 説明データをダウンロードする（別のネットワークボトルネック）。

ここでダウンロードされるデータ量を削減すると、ほぼ常にレイテンシが増加し、
他の作業の背後にダウンロードする内容の決定を遅らせたり、
何かをダウンロードする前に最初に何かをダウンロードしなければならない
データ依存関係を追加したりします。この場合、
検索が完了するまで説明のダウンロードを開始できません。なぜなら、
それにより*どの*説明をダウンロードするかを決定できるからです（結果をソートしてから200に切り捨てる必要があります）。

これを行うために、検索インデックスに2つの列が格納され、
Roaringビットマップとvlq hexの両方に基づいています。

* `e`は**空**の説明のインデックスです。これは、
  各アイテム（クレート自体はアイテム0、残りは1から始まります）の[roaringビットマップ]です。
* `D`はシャードリストで、整数のフラットリストとして[VLQ hex]に格納されます。
  各整数は、シャード内の説明の数を示します。
  デコーダがインデックスを歩くと、説明が空かどうかをチェックします。
  空でない場合、「現在の」シャードにあります。すべてのアイテムが
  使い果たされると、次のシャードに移ります。

各シャード内には、改行で区切られた説明のリストがあり、
JSONP スタイルの関数呼び出しでラップされています。

[roaringビットマップ]: #roaring-bitmaps
[VLQ hex]: #vlq-hex

### `i`、`f`、`p`

`i`と`f`は両方とも、親アイテムの配列`p`にインデックスを付けます。

`i`は単なる1インデックス番号です
（0インデックスではなく、`0`は親アイテムを持たないアイテムに使用されます）。
`q`とは異なります。なぜなら、`q`は親*モジュールまたはクレート*を表し、
すべてに存在しますが、
`i`/`q`は、メソッドなどの*型およびトレイト関連アイテム*に使用されます。

`f`、関数シグネチャは、[VLQ hex]ツリーを使用します。
数値は、`p`への1インデックス参照、
ジェネリックを表す負の数、
またはnullの0のいずれかです。

（内部オブジェクト表現は、
デコード後でも負の数を使用して、
ジェネリックを表します）。

たとえば、`{{gb}{d}}`はjson `[[3, 1], [2]]`と同等です。
ジグザグエンコーディングのため、`` ` ``は+0、`a`は-0（使用されません）、
`b`は+1、`c`は-1です。

## 名前による検索

名前による検索は、検索インデックスをループして、
それぞれに対してこれらの関数を実行することで機能します：

* [`editDistance`]は、一致を判定するために常に使用されます
  （引用符が指定されている場合を除き、単純な等価性が使用されます）。
  クエリ名をエントリ名に変換するために必要な
  スワップ、挿入、削除の数を計算します。
  たとえば、`foo`は自身から距離0ですが、
  `ofo`（1つのスワップ）と`foob`（1つの挿入）からは距離1です。
  これはヒューリスティックしきい値に対してチェックされ、
  しきい値内にある場合、距離はランキングのために保存されます。
* [`String.prototype.indexOf`]は、一致を判定するために常に使用されます。
  -1以外を返す場合、結果が追加されます。
  `editDistance`がしきい値を超えていても、
  インデックスはランキングのために保存されます。
* [`checkPath`]は、親パスがクエリで指定されている場合にのみ使用されます。
  たとえば、`vec`には親パスがありませんが、`vec::vec`にはあります。
  checkPath内では、editDistanceとindexOfが使用され、
  パスクエリには独自のヒューリスティックしきい値もあります。
  しきい値内にない場合、エントリは拒否されます。
  最初の2つがパスしても同様です。
  しきい値内にある場合、パス距離は
  ランキングのために保存されます。
* [`checkType`]は、タイプフィルタがある場合にのみ使用されます。
  `struct:vec`の構造体のようなものです。失敗すると、
  エントリは拒否されます。

4つの基準すべてがパスした場合
（クレートフィルターに加えて、これは技術的にはクエリの一部ではありません）、
結果は[`sortResults`]によってソートされます。

[`editDistance`]: https://github.com/rust-lang/rust/blob/79b710c13968a1a48d94431d024d2b1677940866/src/librustdoc/html/static/js/search.js#L137
[`String.prototype.indexOf`]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/indexOf
[`checkPath`]: https://github.com/rust-lang/rust/blob/79b710c13968a1a48d94431d024d2b1677940866/src/librustdoc/html/static/js/search.js#L1814
[`checkType`]: https://github.com/rust-lang/rust/blob/79b710c13968a1a48d94431d024d2b1677940866/src/librustdoc/html/static/js/search.js#L1787
[`sortResults`]: https://github.com/rust-lang/rust/blob/79b710c13968a1a48d94431d024d2b1677940866/src/librustdoc/html/static/js/search.js#L1229

## 型による検索

型による検索は、2つのフェーズに分けることができ、
2番目のフェーズには2つのサブフェーズがあります。

* クエリ内の名前を数値に変換する。
* 検索インデックスの各エントリをループする：
  * ブルームフィルターを使用した高速拒否。
  * 再帰的型統一アルゴリズムを使用した低速拒否。

名前->数値フェーズでは、クエリに名前が1つしかない場合、
完全一致が失敗した場合、editDistance関数を使用してほぼ一致を見つけますが、
クエリに複数のアイテムがある場合、
一致しないアイテムは代わりにジェネリックとして扱われます。
これは、`hahsmap`が単独でhashmapと一致することを意味しますが、`hahsmap, u32`は
`T, u32`が一致するものと同じものと一致します
（ただし、rustdocはこの特定の問題を検出し、警告します）。

次に、実際に各アイテムをループする際、
ブルームフィルターは、クエリで言及されているすべての型を持たない
エントリをおそらく拒否します。
たとえば、ブルームクエリは、`i32 -> u32`のクエリが
`i32, u32 -> bool`の型を持つ関数と一致することを許可しますが、
統一は後でそれを拒否します。

統一フィルターは、次のことを保証します：

* バッグセマンティクスが尊重されます。クエリが`i32, i32`と言う場合、
  関数は*2つの* i32を言及する必要があり、1つだけではありません。
* ネストセマンティクスが尊重されます。クエリが`vec<option>`と言う場合、
  `vec<option<i32>>`は問題ありませんが、`option<vec<i32>>`は一致*しません*。
* 戻り値型とパラメータの間の区別が尊重されます。
  `i32 -> u32`と`u32 -> i32`は完全に異なります。

ブルームフィルターは、これらのいずれもチェックせず、
さらに、誤検出がある可能性があります。
しかし、高速で非常に少ないメモリを使用するため、ブルームフィルターが役立ちます。

## 再エクスポート

[再エクスポートのインライン化]により、同じアイテムを複数の名前で見つけることができます。
検索は、同じアイテムに複数のエントリを与え、
与えられたパスと異なる正規パスを追跡することで、これをサポートします。

たとえば、このサンプルインデックスには、2つのパスからエクスポートされた単一の構造体があります：

```json
[
    [ "crate_name", {
        "doc": "Documentation",
        "n": ["Data", "Data"],
        "t": "FF",
        "d": ["The data struct", "The data struct"],
        "q": [[0, "crate_name"], [1, "crate_name::submodule"]],
        "i": [0, 0],
        "p": [],
        "f": "``",
        "b": [],
        "c": [],
        "a": [],
        "r": [[0, 1]],
    }]
]
```

この例の重要な部分は`r`配列で、
`q`配列のパスエントリ1が
アイテム0の正規パスであることを示しています。
つまり、`crate_name::Data`の正規パスは`crate_name::submodule::Data`です。

これは奇妙な設計のように聞こえるかもしれませんが、重複データがあるためです。
インライン化はクレート間で発生する可能性があり、
これらは別々にコンパイルされ、すべてがドキュメントに存在するとは限らないため、
そのように行われます。

```json
[
  [ "crate_name", ... ],
  [ "crate_name_2", { "q": [[0, "crate_name::submodule"], [5, "core::option"]], ... }]
]
```

上記の例では、正規パスは実際には依存関係から来ており、
別のパスはインライン化された標準ライブラリアイテムから来ています：
正規パスはインデックスにさえありません！
正規パスは非公開の場合もあります。
いずれの場合も、ユーザーに表示されることはなく、重複排除にのみ使用されます。

メソッドなどの関連型は、異なる方法で保存されます。
これらの型は、`p`（その「親」）のエントリに接続され、
それぞれにオプションの3番目のタプル要素があります：

    "p": [[5, "Data", 0, 1]]

つまり：

* 5: 構造体です
* "Data": その名前
* 0: その表示パス、"crate_name"
* 1: その正規パス、"crate_name::submodule"

どちらの場合も、正規パスは全く公開されていない可能性があり、
または別のクレートからのもので、ドキュメントにない可能性があるため、
ユーザーに表示されることはありませんが、重複排除に使用されます。

[再エクスポートのインライン化]: https://doc.rust-lang.org/nightly/rustdoc/write-documentation/re-exports.html

## 検索エンジンのテスト

生成されたUIは`rustdoc-gui`テストを使用してテストされていますが、
検索エンジンをテストする主な方法は、`rustdoc-js`と
`rustdoc-js-std`テストです。これらはNodeJSで実行されます。

`rustdoc-js`テストには、`.rs`と`.js`ファイルがあり、同じ名前を持ちます。
`.rs`ファイルは、検索を実行する仮想ライブラリクレートを指定します
（見つける必要があるものはすべて`pub`としてマークしてください）。
`.js`ファイルは、実際の検索を指定します。
`rustdoc-js-std`テストは同じですが、`.rs`ファイルは必要ありません。
標準ライブラリを使用するためです。

`.js`ファイルはモジュールのようなものです（ただし、ローダーが
`exports`を処理します）。これらの変数を使用します：

|      名前      |              タイプ              | 説明
| -------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------------
| `FILTER_CRATE` | `string`                       | 指定されたクレートからの結果のみを含めます。GUIでは、これは「結果 in <kbd>crate</kbd>」ドロップダウンメニューです。
| `EXPECTED`     | `[ResultsTable]\|ResultsTable` | 実行するテストのリストで、仮想ユーザーが検索ボックスに入力し、タブに表示されるものを指定します
| `PARSED`       | `[ParsedQuery]\|ParsedQuery`   | 実行するパーサーテストのリストで、実際の検索を実行せずに

`FILTER_CRATE`は省略できます（「すべてのクレート」を検索するのと同等）が、
`EXPECTED`または`PARSED`を指定する必要があります。

デフォルトでは、テストケースで指定された結果のいずれかが
検索の実行後に見つからない場合、または検索の実行後に見つかった結果が
テストに表示されるのと同じ順序で表示されない場合、テストは失敗します。
ただし、実際の検索結果には、テストに含まれていない結果が含まれる場合があります。
これをオーバーライドするには、次の魔法のコメントのいずれかを指定します。
独自の行に配置し、インデントしないでください。

* `// exact-check`: テストケースの一部ではない検索結果が表示された場合、
  失敗します。
* `// ignore-order`: 検索結果が任意の順序で表示されることを許可します。
* `// should-fail`: 否定的なテストを書くために使用されます。

標準ライブラリテストは通常、`// exact-check`を指定すべきではありません。なぜなら、
libsチームが無関係なテストを失敗させずに新しいアイテムを追加できるようにしたいからです。
しかし、スタンドアロンテストはそれをより頻繁に使用します。

`ResultsTable`と`ParsedQuery`型は、
[`rustdoc.d.ts`](https://github.com/rust-lang/rust/blob/HEAD/src/librustdoc/html/static/js/rustdoc.d.ts)で指定されています。

たとえば、`constructor`という名前の関数が見つからないバグを修正する必要があるとします。これを行うには、2つのファイルを書きます：

```rust
// tests/rustdoc-js/constructor_search.rs
// テストケースはこの結果を見つける必要があります。
pub fn constructor(_input: &str) -> i32 { 1 }
```

```js
// tests/rustdoc-js/constructor_search.js
// exact-check
// このテストは独自のクレートに対して実行されるため、
// 新しいアイテムは検索結果に表示されないはずです。
const EXPECTED = [
  // この最初のテストは、名前ベースの検索を対象としています。
  {
    query: "constructor",
    others: [
      { path: "constructor_search", name: "constructor" },
    ],
    in_args: [],
    returned: [],
  },
  // このテストは2番目のタブを対象としています。
  {
    query: "str",
    others: [],
    in_args: [
      { path: "constructor_search", name: "constructor" },
    ],
    returned: [],
  },
  // このテストは3番目のタブを対象としています。
  {
    query: "i32",
    others: [],
    in_args: [],
    returned: [
      { path: "constructor_search", name: "constructor" },
    ],
  },
  // このテストは高度な型駆動検索を対象としています。
  {
    query: "str -> i32",
    others: [
      { path: "constructor_search", name: "constructor" },
    ],
    in_args: [],
    returned: [],
  },
]
```

[`//@ revisions`]ディレクティブが使用されている場合、JSファイルは
`REVISION`という変数にアクセスできます。

```js
const EXPECTED = [
  // この最初のテストは、名前ベースの検索を対象としています。
  {
    query: "constructor",
    others: REVISION === "has_constructor" ?
      [
        { path: "constructor_search", name: "constructor" },
      ] :
      [],
    in_args: [],
    returned: [],
  },
];
```

[`//@ revisions`]: ../tests/compiletest.md#revisions
