# 型システムの不変条件

FIXME: このファイルは、ソルバーだけでなく、型システム全体の不変条件について説明しています

多くの不変条件があります - 型システムが常に真であることを保証するもの -
これらは他の言語や型システムから望ましいまたは期待されるものです。残念ながら、かなり
多くのものが現在Rustでは成り立っていません。これは、その設計の基本的なものであるか、
バグによって引き起こされ、将来変更される可能性があるものです。

型システムの作業中および作業時に仮定できることを知ることは重要です。ここに、
コア型システムの不変条件の不完全で非公式なリストがあります：

- ✅: この不変条件はほとんど成り立ちますが、いくつかの奇妙な例外または現在のバグがあります
- ❌: この不変条件は成り立たず、将来的にそうなる可能性も低いです。健全性のためにこれに依存したり、そうする場合は非常に注意する必要があります

### `wf(X)`は`wf(normalize(X))`を意味する ✅

エイリアスを含む型がwell-formedである場合、
前記エイリアスを正規化した後もwell-formedであるべきです。これに依存しています。そうしないと、これらの
型に対してwell-formednessを再チェックする必要があるからです。

これは現在、型システムの健全性の欠如のため成り立っていません：[#84533](https://github.com/rust-lang/rust/issues/84533)。

### 領域を除いた構造的等価性は意味的等価性を意味する ✅

ある型があり、それを任意の領域を両方のlhsとrhsで一意の
推論変数で置き換えた後に自身と等しくする場合、現在潜在的に構造的に異なる
型は依然として互いに等しいべきです。

これは、HIR typeckでゴールが成功し、その後MIR borrowckで失敗することを防ぐために必要です。
この不変条件が破られた場合、MIR typeckはICEで失敗することになります。

### ゴールから推論結果を適用してもその結果は変わらない ❌

TODO: この不変条件は奇妙な方法で定式化されており、詳しく説明する必要があります。
かなり：このチェックがソルバーのバグがある場合にのみ失敗することを望みます：
<https://github.com/rust-lang/rust/blob/2ffeb4636b4ae376f716dc4378a7efb37632dc2d/compiler/rustc_trait_selection/src/solve/eval_ctxt.rs#L391-L407>。
このチェックを再追加し、どこで壊れるかを確認する必要があります :3

ゴールを証明したり、型を等しくしたり、何でもする場合、結果の推論制約を適用し、
次に元のアクションをやり直すと、結果は同じであるべきです。

これは残念ながら成り立ちません - 少なくとも新しいソルバーでは - いくつかの厄介な理由のためです。

### トレイトソルバーは*局所的に健全*である必要がある ✅

これは、`impl`が存在しないゴールに対して*成功*を返してはならないことを意味します。それは
トレイトが実装されていなくても実装されていると仮定することを意味し、実際の健全性の欠如を引き起こす可能性が非常に高いです。`where`境界を使用してゴールを証明する場合、`impl`はアイテムのユーザーによって提供されます。

この不変条件は、領域制約をチェックする場合にのみ成り立ちます。コヒーレンスの暗黙的な負のオーバーラップチェック中に領域制約をチェックしないため、この不変条件はそこで破られています。このチェックは
トレイトソルバーの*完全性*に依存するため、現在の領域制約
チェック - `InferCtxt::resolve_regions` - を使用できません。なぜなら、型outlives ゴールの処理が不完全だからです。

### 空の環境での意味的に等しいエイリアスの正規化は一意の型をもたらす ✅

エイリアス型/定数の正規化は一意の結果を持つ必要があります。そうしないと、安全なコードで簡単に
transmute を実装できます。次の関数を考えると、入力と出力の型が常に同じ具体的な型に正規化されることを確認する必要があります。

```rust
fn foo<T: Trait>(
    x: <T as Trait>::Assoc
) -> <T as Trait>::Assoc {
    x
}
```

現在知られている健全でない問題の多くは、この不変条件が破られることに依存しています。
しかし、この不変条件なしで健全な型システムを想像することは非常に困難なので、
問題は不変条件が破られていることであり、誤ってそれに依存していることではありません。

### 型システムは完全である ❌

型システムは完全ではありません。
しばしば不要な推論制約を追加し、ゴールが成り立つ可能性があってもエラーを出します。

- メソッド選択
- 不透明型推論
- 型outlives制約の処理
- トレイトソルバーの候補選択中に`Impl`候補よりも`ParamEnv`候補を優先

### ゴールはHIR typeckからその後も結果を保持する ✅

HIR typeck中に成功するゴールが、MIR borrowck中に再評価されたときに失敗するとICEを引き起こします。例：[#140211](https://github.com/rust-lang/rust/issues/140211)。

HIR typeck中に成功するゴールが、インスタンス化された後に失敗すると健全性の欠如です。例：[#140212](https://github.com/rust-lang/rust/issues/140212)。

トレイトソルバーでいくつかの不完全性を許容しながらも、この制限を維持することは興味深いです。「許可される不完全性」と、この不変条件を破る動作を分離する明確な方法があれば素晴らしいでしょう。

#### 正規化は結果を変更してはならない

この不変条件は、ジェネリックエイリアスの正規化を許可するために依存されています。これを破ると
簡単に健全性の欠如をもたらす可能性があります。例：[#57893](https://github.com/rust-lang/rust/issues/57893)。

#### ゴールはインスタンス化後もオーバーフローする可能性がある

これは、再帰制限に達し始めたときに発生します。
また、乱雑な発散エイリアスもあります。
これらをどのように処理すべきかは不明です :3

### 空の環境でのトレイトゴールは一意のimplによって証明される ✅

トレイトゴールが空の環境で成り立つ場合、ユーザー定義または
ビルトインのいずれかで、そのゴールを証明するために使用される一意の`impl`があるべきです。これは、
一意のメソッドと関連アイテムを選択するために必要です。

ただし、いくつかのケースでこの不変条件を破ります。そのうちのいくつかはバグによるもので、いくつかは設計によるものです：

- *マーカートレイト*は関連アイテムを持たないため、オーバーラップが許可されています
- *特殊化*により、特殊化implがその親とオーバーラップすることが許可されます
- ビルトイントレイトオブジェクトのトレイト実装は、ユーザー定義のimplとオーバーラップする可能性があります：
[#57893](https://github.com/rust-lang/rust/issues/57893)

#### コヒーレンスの暗黙的な負のオーバーラップチェック中、型システムは完全である ✅

オーバーラップチェックの詳細については、[コヒーレンスの章]を参照してください。

コヒーレンスの暗黙的な負のオーバーラップチェック中、
証明できるゴールに対して*エラー*を返してはなりません。
これにより、潜在的に異なる関連アイテムを持つimplがオーバーラップすることが許可され、
他の多くの不変条件が破られます。

この不変条件は現在、多くの異なる方法で破られていますが、実際に依存しているものです。
簡単に破ることができるので、注意する必要があります：

- エイリアスの一般化
- バインダーをサブタイプする際の一般化（幸いコヒーレンスでは悪用できません）

### トレイト解決はライフタイムが異なることに依存してはならない ✅

ライフタイムが異なるときにゴールが成り立つ場合、これらのライフタイムが同じであってもゴールは成り立つ必要があります。そうしないと、codegen中またはvtableが無効なため、ポストモノモーフィゼーションエラーが発生します。

また、最初に異なるライフタイムでゴールを証明し、後で等しいと制約される場合、一貫性のない動作が発生する可能性があります。

### 本文でのトレイト解決はライフタイムが等しいことに依存してはならない ✅

トレイトソルバーで領域の等価性に依存することにも注意する必要があります。
これはcodegenでは問題ありません。すべての消去された領域を等しいものとして扱うためです。ただし、
HIRからMIR typeckへの等価性情報を失う可能性があります。

これは現在、新しいソルバーでは成り立っていません：[trait-system-refactor-initiative#27](https://github.com/rust-lang/trait-system-refactor-initiative/issues/27)。

### 曖昧性を削除すると、厳密により多くのものがコンパイルされる ❌

理想的には、コンパイルのために曖昧性に依存*すべきではありません*。
そうしないと、将来の改善が破壊的変更になります。

*不完全性*のため、これは当てはまらず、
推論の改善は推論の変更をもたらし、既存のプロジェクトを破壊する可能性があります。

### 意味的等価性は構造的等価性を意味する ✅

型システムで2つの型が等しいことは、それらのジェネリックパラメータを具体的な
引数でインスタンス化した後、同じ`TypeId`を持つことを意味する必要があります。そうしないと、異なる`TypeId`を使用してトレイト選択に影響を与えることができます。

codegen中に構造的等価性を使用して型を検索しますが、これは必ずしも健全でない必要はありません

- 冗長なメソッドのcodegenまたはバックエンドの型チェックエラーを引き起こす可能性があります
- CTFE アサーションでもこれに依存しています

### 意味的に異なる型は異なる`TypeId`を持つ ✅

意味的に異なる`'static`型は、transmuteを避けるために異なる`TypeId`を持つ必要があります。
たとえば、`for<'a> fn(&'a str)`対`fn(&'static str)`は異なる`TypeId`を持つ必要があります。
