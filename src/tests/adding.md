# 新しいテストの追加

**一般的に、rustcのバグを修正するすべてのPRには、何らかの種類の回帰テストが付随することを期待しています。** このテストは`main`ブランチでは失敗し、PRの後では成功する必要があります。これらのテストは、過去の過ちを繰り返さないために本当に役立ちます。

最初に決めるべきことは、どの種類のテストを追加するかです。これは変更の性質と何を実行したいかに依存します。大まかなガイドラインは次のとおりです：

- コンパイラテストの大部分は[compiletest]で行われます。
  - compiletestテストの大部分は[`tests/ui`]ディレクトリの[UI](ui.md)テストです。
- 標準ライブラリへの変更は、通常、標準ライブラリ自体内でテストされます。
  - 標準ライブラリテストの大部分は、典型的なAPIの動作を示し、実行するdoctestsとして書かれています。
  - 追加の[ユニットテスト](intro.md#package-tests)は`library/${crate}/tests`に配置する必要があります（`${crate}`は通常`core`、`alloc`、または`std`です）。
- コードが独立したシステムの一部であり、コンパイラの出力をテストしていない場合は、[ユニットテストまたは統合テスト](intro.md#package-tests)の使用を検討してください。
- rustdocを実行する必要がありますか？`rustdoc`または`rustdoc-ui`テストを優先してください。場合によっては`rustdoc-js`も必要になります。
- 他のcompiletestテストスイートは一般的に特別な目的で使用されます：
  - gdbまたはlldbを実行する必要がありますか？`debuginfo`テストスイートを使用してください。
  - LLVM IRまたはMIR IRを検査する必要がありますか？`codegen`または`mir-opt`テストスイートを使用してください。
  - 何らかの方法で結果のバイナリを検査する必要がありますか？または、他のすべてのテストスイートが目的に対して制限が多すぎる場合は？`run-make`を使用してください。
    - ツリー内の`cargo`とツリー内の`rustc`を組み合わせて実行する必要がある場合は、`run-make-cargo`を使用してください。
  - より専門的なテストスイートについては、[compiletest]章を確認してください。

追加するテストの種類を決定したら、作業しやすく時の試練に耐えるテストを作成する方法についてのガイダンスについては、[ベストプラクティス](best-practices.md)を参照してください（つまり、テストが失敗したり、数年後に変更する必要がある場合、どうすればそれらを簡単にできるでしょうか）。

[compiletest]: compiletest.md
[`tests/ui`]: https://github.com/rust-lang/rust/tree/HEAD/tests/ui/

## UIテストのウォークスルー

以下は、最も一般的なコンパイラテストの1つである[UIテスト](ui.md)を作成するための基本的なガイドです。このチュートリアルでは、非同期エラーメッセージのテストを追加します。

### ステップ1：テストファイルの追加

最初のステップは、[`tests/ui`]ツリーのどこかにRustソースファイルを作成することです。テストを作成するときは、適切な場所と名前を見つけるために最善を尽くしてください（詳細については[テストの整理](ui.md#test-organization)を参照してください）。命名は開発の最も難しい部分なので、ここからはすべて下り坂です！

非同期テストを`tests/ui/async-await/await-without-async.rs`に配置しましょう：

```rust,ignore
// Provide diagnostics when the user writes `await` in a non-`async` function.
//@ edition:2018

async fn foo() {}

fn bar() {
    foo().await
}

fn main() {}
```

テストについていくつか注意すべき点：

- 上部は[テストが何のためのものかを説明する](#explanatory_comment)短いコメントで始まる必要があります。
- `//@ edition:2018`コメントは[ディレクティブ](directives.md)と呼ばれ、テストの構築方法についてcompiletestに指示を提供します。ここでは、`async`が機能するようにエディションを設定する必要があります（デフォルトはedition 2015です）。
- それに続くのは、テストのソースです。テストを簡潔で要点を押さえたものにするよう努めてください。バグレポートの例を最小化しようとする場合、これにはいくらかの努力が必要になるかもしれません。
- このテストは空の`fn main`関数で終わります。これは、UIテストのデフォルトが`bin`クレートタイプであり、テストで「main not found」エラーが発生しないようにするためです。あるいは、`#![crate_type="lib"]`を追加することもできます。

### ステップ2：期待される出力の生成

次のステップは、コンパイラからの期待される出力スナップショットを作成することです。これは`--bless`オプションで実行できます：

```sh
./x test tests/ui/async-await/await-without-async.rs --bless
```

これにより、コンパイラがビルドされ（まだビルドされていない場合）、テストがコンパイルされ、コンパイラの出力が`tests/ui/async-await/await-without-async.stderr`というファイルに配置されます。

ただし、このステップは失敗します！次のようなエラーメッセージが表示されるはずです：

> error: /rust/tests/ui/async-await/await-without-async.rs:7: unexpected
> error: '7:10: 7:16: `await` is only allowed inside `async` functions and
> blocks E0728'

これは、stderrにソースファイルのエラーアノテーションで一致しないエラーが含まれているためです。

### ステップ3：エラーアノテーションの追加

すべてのエラーは、エラーのテキストを含むソース内のコメントで注釈を付ける必要があります。この場合、テストファイルに次のコメントを追加できます：

```rust,ignore
fn bar() {
    foo().await
    //~^ ERROR `await` is only allowed inside `async` functions and blocks
}
```

`//~^`波線キャレットコメントは、エラーが*前の*行に属することをcompiletestに伝えます（これについての詳細は、[エラーアノテーション](ui.md#error-annotations)セクションにあります）。

それを保存して、テストを再度実行します：

```sh
./x test tests/ui/async-await/await-without-async.rs
```

これで成功するはずです、やった！

### ステップ4：出力のレビュー

前のステップとやや手を取り合って、作成された`.stderr`ファイルを検査して、期待どおりに見えるかどうかを確認する必要があります。新しい診断メッセージを追加している場合、今はメッセージ全体がどのように見えるか、特にRustに不慣れな人にとって読みやすいかどうかを検討する良い機会です。

この例の`tests/ui/async-await/await-without-async.stderr`ファイルは次のようになるはずです：

```text
error[E0728]: `await` is only allowed inside `async` functions and blocks
  --> $DIR/await-without-async.rs:7:10
   |
 LL | fn bar() {
   |    --- this is not `async`
 LL |     foo().await
   |          ^^^^^^ only allowed inside `async` functions and blocks

error: aborting due to previous error

For more information about this error, try `rustc --explain E0728`.
```

通常のコンパイラ出力とは少し異なるものがあることに気付くかもしれません。

- `$DIR`はシステム間で異なるパス情報を削除します。
- `LL`値は行番号を置き換えます。これにより、ソースの小さな変更が大きな差分をトリガーするのを避けられます。詳細については、[正規化](ui.md#normalization)セクションを参照してください。

この段階で、テストを微調整し、テストを再祝福し、出力を再レビューするために、最後のいくつかのステップを何度か繰り返す必要があるかもしれません。

### ステップ5：他のテストの確認

診断メッセージを追加または変更すると、テストスイートの他のテストに影響を与えることがあります。PRを投稿する前の最後のステップは、他に何かに影響を与えたかどうかを確認することです。UIスイートを実行することは通常良い出発点です：

```sh
./x test tests/ui
```

他のテストが失敗し始めた場合は、何が変わったのか、新しい出力が意味をなすのかを調査する必要があります。

また、`--bless`フラグで出力を再祝福する必要があるかもしれません。

<a id="explanatory_comment"></a>

## テストが何についてのものかを説明するコメント

テストファイルの最初のコメントは、**テストの要点を要約し**、それについて重要なことを強調する必要があります。テストに関連する問題番号がある場合は、問題番号を含めてください。

このコメントは非常に広範囲である必要はありません。「#18060の回帰テスト：マッチアームが間違った順序でマッチしていました。」のようなものですでに十分かもしれません。

これらのコメントは、テストが壊れたときに他の人にとって非常に役立ちます。問題が何であるかを強調できることが多いためです。また、何らかの理由でテストをリファクタリングする必要がある場合にも役立ちます。テストのどの部分が重要だったかを他の人に知らせるためです。多くの場合、テストはもはや意図したものをテストしなくなったために書き直す必要があり、そのときに*何を*テストすることを意図していたかを正確に知ることが役立ちます。
