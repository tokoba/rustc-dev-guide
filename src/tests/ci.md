# CIでのテスト

CIシステムの主な目標は、`rust-lang/rust`の`main`ブランチがテストスイートに合格することで常に有効な状態にあることを保証することです。

ハイレベルな視点から見ると、`rust-lang/rust`でプルリクエストを開くと、次のことが起こります：

- PRへの各プッシュ後に、テストとチェックの小さな[サブセット](#pull-request-builds)が実行されます。
  これは一般的なエラーを早期に捕捉するのに役立ちます。
- PRが承認されると、[bors]ボットがPRを[マージキュー]にエンキューします。
- PRがキューの先頭に到達すると、borsはマージコミットを作成し、その上で[完全なテストスイート](#auto-builds)を実行します。
  マージコミットには、1つの特定のPRのみが含まれる場合もあれば、CIコストとマージ遅延を削減するために複数のPRをまとめた["ロールアップ"](#rollups)の場合もあります。
- 完全なテストスイートが終了すると、2つのことが起こります。開発者が対処する必要があるエラーでCIが失敗するか、CIが成功してマージコミットが`main`ブランチにプッシュされます。

CIで実行される内容を変更したい場合は、[CIジョブの変更](#modifying-ci-jobs)を参照してください。

## CIワークフロー

<!-- date-check: Oct 2024 -->

CIは主に[GitHub Actions]上で実行され、[`.github/workflows/ci.yml`]で定義された単一のワークフローがあります。これには、実行するすべてのCIジョブに統一された多数のステップが含まれています。
コミットが対応するブランチまたはPRにプッシュされると、ワークフローは[`src/ci/citool`]クレートを実行し、実行する特定のCIジョブを動的に生成します。
このスクリプトは、すべてのCIジョブの宣言的な設定を含む[`jobs.yml`]ファイルを入力として使用します。

> ほとんどすべてのビルドステップは別々のスクリプトにシェルアウトします。これにより、CIはかなりプラットフォームに依存しません（つまり、GitHub Actionsに過度に依存していません）。
> GitHub Actionsは、CIプロセスのブートストラップとプロセスを駆動するスクリプトのオーケストレーションにのみ依存されています。

本質的に、すべてのCIジョブは、さまざまなオペレーティングシステム、ターゲット、およびプラットフォームで、異なる構成で`./x test`、`./x dist`、またはその他のコマンドを実行します。
実行されるジョブには、`dist`ジョブと非`dist`ジョブの2つの広いカテゴリーがあります。

- distジョブは、特定のプラットフォーム用のコンパイラの完全なリリースをビルドします。これには、rustupを介して出荷するすべてのツールが含まれます。
  これらのビルドは`rust-lang-ci2` S3バケットにアップロードされ、[rustup-toolchain-install-master]ツールでローカルにインストールできます。
  同じビルドは実際のリリースにも使用されます：リリースプロセスは基本的に、これらのアーティファクトを`rust-lang-ci2`から本番エンドポイントにコピーして署名することで構成されます。
- 非distジョブは、プラットフォーム上で完全なテストスイートを実行し、rustupを介して出荷するすべてのツールのテストスイートを実行します。
  テストする内容の量はプラットフォームに依存します（たとえば、一部のテストはTier 1プラットフォームでのみ実行されます）、
  より高速なプラットフォームの一部は、CIリソースを無駄にしないように同じビルダー上でグループ化されます。

入力イベント（通常はブランチへのプッシュ）に基づいて、3種類のビルド（ジョブのセット）のいずれかを実行します。

1. PRビルド
2. Autoビルド
3. Tryビルド

[rustup-toolchain-install-master]: https://github.com/kennytm/rustup-toolchain-install-master

### プルリクエストビルド

プルリクエストへの各プッシュ後、`pr`ジョブのセットが実行されます。
現在、これらは`x86_64-gnu-llvm-X`、`x86_64-gnu-tools`、`pr-check-1`、`pr-check-2`、および`tidy`ジョブを実行します。すべてLinux上で実行されます。
これらは比較的短い（約40分）軽量なテストスイートを実行し、一般的な問題を捕捉する必要があります。
より具体的には、一連のlintを実行し、Windows mingwへのクロスコンパイルチェックビルドを実行し（アーティファクトを生成せず）、*システム*バージョンのLLVMを使用してコンパイラをテストします。
残念ながら、すべてのPRでコミットごとに完全なテストスイートを実行するには、リソースが多すぎます。

> **ドキュメントコメントに関する注意**
>
> 2024年10月時点<!-- datecheck -->のPR CIはデフォルトで`./x doc xxx`を実行しようとしないことに注意してください。これは、`./x doc xxx`の失敗につながる壊れたintradocリンクがある場合、完全なマージキューCIパイプラインの非常に遅い段階で発生することを意味します。
>
> したがって、ドキュメントコメントの変更については、これらを早期に捕捉するために、ローカルで`./x doc xxx`を実行することをお勧めします。

PRジョブは[`jobs.yml`]の`pr`セクションで定義されています。
結果は、PRページの下部の「CIチェック」セクションで、PR上で直接観察できます。

### Autoビルド

コミットが`main`ブランチにマージされる前に、完全なテストスイートに合格する必要があります。
これを`auto`ビルドと呼びます。
このビルドは、オペレーティングシステムとターゲット全体でさまざまなテストを実行する数十のCIジョブを実行します。
完全なテストスイートはかなり遅く、すべての`auto` CIジョブが終了するまでに数時間かかることがあります。

ほとんどのプラットフォームはビルドステップのみを実行し、一部は制限されたテストセットを実行します。
完全なテストスイートを実行するのはサブセットのみです（Rustの[platform tiers]を参照）。

Autoジョブは[`jobs.yml`]の`auto`セクションで定義されています。
`rust-lang/rust`リポジトリの`auto`ブランチで実行され、最終結果は対応するPRでborsによってコメントで報告されます。
ライブ結果は[the GitHub Actions workflows page]で見ることができます。

いつでも、最大で1つの`auto`ビルドのみが実行されます。
詳細については、[borsによるPRの連続マージ](#merging-prs-serially-with-bors)を参照してください。

[platform tiers]: https://forge.rust-lang.org/release/platform-support.html#rust-platform-support

### Tryビルド

特定のPRに対してCIでテストスイートのサブセットを実行したり、マージを試みることなくそのPRからコンパイラアーティファクトのセットをビルドしたりしたい場合があります。
これを「tryビルド」と呼びます。
tryビルドは、適切な権限を持つユーザーが`@bors try`コマンドでPRコメントを投稿した後に開始されます。

tryビルドにはいくつかのユースケースがあります：

- [rustc-perf]ベンチマークスイートを使用して、パフォーマンスベンチマークのセットを実行します。
  これには、作業中のコンパイラビルドが必要です。これは、Linux上でコンパイラの最適化バージョンをビルドする[dist-x86_64-linux] CIジョブを実行するtryビルドで生成できます（このジョブは現在、tryビルドを開始するときにデフォルトで実行されます）。
  tryビルドを作成してパフォーマンスベンチマークのスケジュールを設定するには、`@bors try @rust-timer queue`コマンドの組み合わせを使用できます。
- [Crater](crater.md)実行を使用して、Rustエコシステム全体でのPRの影響をチェックします。
  繰り返しになりますが、これには作業中のコンパイラビルドが必要です。これは[dist-x86_64-linux] CIジョブによって生成できます。
- PRで特定のCIジョブ（Windowsテストなど）を実行して、そのジョブによって実行されるテストスイートに合格するかどうかを迅速にテストします。

デフォルトでは、`@bors try`でコメントを送信すると、[`jobs.yml`]の`try`セクションで定義されたジョブが実行されます。
このモードを「高速tryビルド」と呼びます。
このようなtryビルドはテストを実行せず、コンパイル警告を許可します。
Crater実行またはパフォーマンスベンチマークのために、完全に正しく動作しない可能性があっても、できるだけ早く最適化されたツールチェーンを取得したい場合に役立ちます。
デフォルトのtryジョブの完全なビルドを実行したい場合は、ジョブパターン（以下で説明）でそのジョブ名を指定してください。

tryビルドでカスタムCIジョブを実行し、すべてのテストに合格し、コンパイル警告を生成しないことを確認したい場合は、*ジョブパターン*を指定してCIジョブを選択できます。
これは2つの方法のいずれかで使用できます：

- PR説明に`try-job: <job pattern>`ディレクティブのセットを追加し（以下で説明）、`@bors try`を実行するだけです。
  CIはこれらのディレクティブを読み取り、指定したジョブを実行します。
  これは、PRを段階的に変更した後、同じtryジョブのセットを複数回再実行したい場合に役立ちます。
- tryコマンドの`jobs`パラメータを使用してジョブパターンを指定できます：`@bors try jobs=<job pattern>`。
  これは、特定のジョブを使用した1回限りのtryビルドに役立ちます。
  `jobs`パラメータはPR説明ディレクティブよりも優先度が高いことに注意してください。
  - 複数のパターンを指定することもできます。例：`@bors try jobs=job1,job2,job3`。

各ジョブパターンは、ジョブの正確な名前、または複数のジョブに一致するglobパターンのいずれかです。
たとえば、`*msvc*`または`*-alt`です。
1つのtryビルドで最大20個のジョブを開始できます。
PR説明でglobパターンを使用する場合、アスタリスクなどが含まれている場合にGitHubがパターンをMarkdownとしてレンダリングしないように、バッククォート(`` ` ``)でラップすることができます。このエスケープは`@bors jobs=`パラメータを使用するときには機能しないことに注意してください。

ジョブパターンは、[`jobs.yml`]の`auto`または`optional`セクションで定義された1つ以上のジョブと一致する必要があります：

- `auto`ジョブは、コミットが`main`ブランチにマージされる前に実行されます。
- `optional`ジョブは、tryビルドを介して明示的にリクエストされた場合にのみ実行されます。
  これらは通常、tier 2およびtier 3ターゲットに使用されます。

tryビルドを行う理由の1つは、上記のように`@rust-timer queue`でパフォーマンス実行を行うことです。
このパフォーマンスビルドは、main上のいくつかのコミットと比較されます。
`@bors try parent=<sha>`を使用すると、特定の`main`上のコミットに基づいてtryビルドとその後のパフォーマンス実行を行うことができ、パフォーマンス比較をできるだけ公平にするのに役立ちます。

> **`try-job` PR説明ディレクティブの使用**
>
> 1. 実行したいtryジョブのセットを特定します。CIジョブの名前は[`jobs.yml`]で見つけることができます。
>
> 2. PR説明を修正して、パターンのセット（通常はPR説明の最後）を含めます。例：
>
>    ```text
>    This PR fixes #123456.
>
>    try-job: x86_64-msvc
>    try-job: test-various
>    try-job: `*-alt`
>    ```
>
>    各`try-job`パターンは独自の行にある必要があります。
>
> 3. `@bors try`で指定されたtryジョブを実行します。前述のように、これにはユーザーが（1）`try`権限を持っているか、（2）`try`権限を持っている人による`@bors delegate`で`try`権限を委任されている必要があります。
>
> これは通常、[`jobs.yml`]を手動で編集するよりも簡単です。
> ただし、この方法では実行されるテストのセットを調整できないため、柔軟性が低くなる可能性があります。

Tryビルドは`rust-lang/rust`リポジトリの`try`ブランチで実行され、
結果は[the GitHub Actions workflows page]で見ることができますが、
通常は対応するPRでborsによって作成されたコメントで結果が通知されます。

複数のtryビルドは異なるPR間で同時に実行できますが、単一のPRで一度に実行できるtryビルドは最大1つです。

tryビルドは[new bors]実装を使用して処理されることに注意してください。

[rustc-perf]: https://github.com/rust-lang/rustc-perf
[new bors]: https://github.com/rust-lang/bors

### CIジョブの変更

CIで実行される内容を変更したい場合は、[`jobs.yml`]ファイルの`pr`、`auto`、または`try`セクションを変更するだけです。

また、ローカルでテストすることが困難な特定のプラットフォームまたは構成をテストするために、実行される内容を一時的に変更することもできます（たとえば、Windowsビルドが失敗したが、Windowsマシンにアクセスできない場合）。
このような状況ではCIリソースの使用をためらわないでください。

任意のCIジョブを実行するには、2つの方法があります：

- [tryビルド](#try-builds)機能を使用し、PR説明でtryビルドで実行するCIジョブを指定します。
- `jobs.yml`の[`pr`](#pull-request-builds)セクションを変更して、PRへの各プッシュ後に実行するCIジョブを指定します。
  これは、繰り返しtryビルドを開始するよりも高速である可能性があります。

PRへの各プッシュ後に実行されるジョブを変更するには、`auto`セクションからジョブ定義の1つを`pr`セクションにコピーするだけです。
たとえば、`x86_64-msvc`ジョブは64ビットMSVCテストの実行を担当します。
次のように、PRにコミットがプッシュされた後に実行されるように`pr`セクションにコピーできます：

```yaml
pr:
  ...
  - image: x86_64-gnu-tools
    <<: *job-linux-16c
  # this item was copied from the `auto` section
  # vvvvvvvvvvvvvvvvvv
  - image: x86_64-msvc
    env:
      RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler
      SCRIPT: make ci-msvc
    <<: *job-windows-8c
```

その後、ファイルをコミットしてGitHub上のPRブランチにプッシュできます。
GitHub ActionsはPRへの各プッシュ後にこのCIジョブを実行するはずです。

<div class="warning">

**実験が終了したら、一時的であると想定されていた場合は、`jobs.yml`に加えた変更を削除することを忘れないでください！**

tryジョブをまだ実行している間はPRタイトルに`[WIP]`プレフィックスを付け、テスト目的でCIジョブを変更するコミットに`[DO NOT MERGE]`を付けるのが良い習慣です。
</div>

CIを使用することは歓迎されますが、これは同時実行性が制限された共有リソースであることを意識してください。
一度に有効にするジョブが多すぎないようにしてください。
ほとんどの場合、1つまたは2つで十分です。

## borsによるPRの連続マージ

CIサービスは通常、ブランチの最後のコミットと`main`の最後のコミットをマージしてテストします。これは、機能が単独で機能するかどうかを確認するのに最適ですが、マージされた後にコードが機能するという保証はありません。
このような破壊は通常、ビルドが発生した後に別の互換性のないPRがマージされたときに発生します。

常に機能する`main`ブランチを保証するために、手動マージを禁止しています。
代わりに、すべてのPRは、ボット[bors]を介して承認される必要があります（その背後にあるソフトウェアは[homu]と呼ばれます）。
承認されたすべてのPRは[マージキュー]に入れられ（優先度と作成日でソートされ）、一度に1つずつ自動的にテストされます。
すべてのビルダーがグリーンの場合、PRはマージされます。それ以外の場合、失敗が記録され、PRは再度承認される必要があります。

Borsは、CIサービスと直接対話するのではなく、テストしたいマージコミットを特定のブランチ（`auto`や`try`など）にプッシュすることで機能します。これらのブランチはCIチェックを実行するように構成されています。
次に、BorsはCommit StatusesまたはCheck Runsをリッスンすることでビルドの結果を検出します。
マージコミットは最新の`main`に基づいており、一度に1つしかテストできないため、結果がグリーンの場合、`main`はそのマージコミットに早送りされます。

残念ながら、一度に1つのPRをテストすることと、長いCI（完全実行で約2時間）を組み合わせると、1日に多くのPRをマージできず、単一の失敗がスループットに大きく影響します。
1日にマージできるPRの最大数は約10です。

長いCI実行時間と大規模なビルダープールの要件は、主に`dist-`ビルダーで完全なリリースアーティファクトがビルドされているという事実によるものです。
これらのリリースアーティファクトは次の理由で価値があります：

- 後日でもパフォーマンステストを可能にします。
- 後でバグが発見されたときにバイセクションを可能にします。
- 常にリリースしている場合、問題を早期に捕捉できるため、リリース品質を保証します。

### ロールアップ

一部のPRは完全なテストスイートを実行する必要がありません：タイプミス修正やREADME改善のような些細な変更はビルドを壊すべきではなく、それらすべてを2時間以上テストすることは無駄です。
これを解決するために、いくつかの保留中の些細なPRをマージして一緒にテストできる「ロールアップ」と呼ばれるPRを定期的に作成します。
ロールアップは、[マージキュー]の「ロールアップを作成」ボタンを使用してチームメンバーが手動で作成します。
チームメンバーは、PRがリスクがあるかどうかを判断するために判断を使用します。

## Docker

macOSとWindows上のものを除くすべてのCIジョブは、そのプラットフォームのカスタム[Dockerコンテナ]内で実行されます。
これには多くの利点があります：

- ビルド環境は、基盤となるイメージの変更に関係なく一貫しています（trustyイメージからxenialへの切り替えは、私たちにとって痛みのないものでした）。
- 最大のバイナリ互換性を保証するために、古いビルド環境を使用できます。たとえば、Linuxビルダーで[古いCentOSリリースを使用][dist-x86_64-linux]します。
- Dockerイメージキャッシングのおかげで、ツール（QEMUやAndroidエミュレータなど）を毎回再インストールする必要がありません。
- ユーザーは、次のコマンドを実行するだけで、同じ環境で同じテストをローカルで実行できます：

      cargo run --manifest-path src/ci/citool/Cargo.toml run-local <job-name>

  これは、失敗のデバッグに役立ちます。
  ライセンスやその他の制限により、Linux Dockerイメージのみがローカルで利用可能であることに注意してください。

`dist-`プレフィックスが付いたDockerイメージはアーティファクトのビルドに使用され、
そのプレフィックスがないものはテストとチェックを実行します。

また、CIで一般的でないアーキテクチャ（主にTier 2およびTier 3プラットフォーム）のテストも実行します。
これらのプラットフォームはx86ではないため、QEMU内ですべてを実行するか、そのプラットフォームのテストを実行したくない場合はクロスコンパイルするだけです。

これらのビルダーは、GitHubによって設定および維持されている特別なビルダープールで実行されています。

[Dockerコンテナ]: https://github.com/rust-lang/rust/tree/HEAD/src/ci/docker

## キャッシング

CIワークフローは、主に2つのことのためにさまざまなキャッシングメカニズムを使用します：

### Dockerイメージのキャッシング

ほとんどのLinuxベースのビルダーを実行するために使用するDockerイメージは、完全にビルドするのに*長い*時間がかかります。
ビルドを高速化するために、[Dockerレジストリキャッシング]を使用してキャッシュし、中間アーティファクトを[ghcr.io]に保存します。
また、ビルドされたDockerイメージをghcrにプッシュして、他のツール（rustup）やローカルでDockerビルドを実行する開発者が再利用できるようにします（ビルドを高速化するため）。

複数の分岐したブランチ（`main`、`beta`、`stable`）をテストするため、イメージに対して単一のキャッシュに依存することはできません。そうしないと、あるブランチでのビルドが他のブランチのキャッシュを上書きしてしまいます。
代わりに、すべてのDockerfilesと関連スクリプトの内容から作成されたカスタムハッシュでイメージを識別し、異なるタグの下にイメージを保存します。

CIはハッシュキーを計算して、次のいずれかが変更された場合にDockerイメージのキャッシュが無効化されるようにします：

- Dockerfile
- Dockerfileでdockerイメージにコピーされたファイル
- GitHubランナーのアーキテクチャ（x86またはARM）

[ghcr.io]: https://github.com/rust-lang/rust/pkgs/container/rust-ci
[Dockerレジストリキャッシング]: https://docs.docker.com/build/cache/backends/registry/

### SccacheによるLLVMキャッシング

さまざまなCIジョブでいくつかのC/C++のものをビルドし、中間LLVMアーティファクトをキャッシュするために[Sccache]に依存しています。
SccacheはMozillaによって開発された分散ccacheで、オブジェクトストレージバケットをストレージバックエンドとして使用できます。

Sccacheでは、ハッシュキーを自分で計算する必要はありません。
Sccacheは、ソースコード、コンパイラのバージョン、重要な環境変数などの関連する入力の変更を検出すると、自動的にキャッシュを無効化します。
したがって、CargoのトップにSccacheラッパーを渡すだけで、Sccacheが残りを行います。

永続的なアーティファクトをS3バケット`rust-lang-ci-sccache2`に保存します。
したがって、CIが実行されると、SccacheがLLVMが同じC/C++コンパイラでコンパイルされており、LLVMソースコードが同じであることを確認した場合、SccacheはS3から個々のコンパイル済み翻訳ユニットを取得します。

[sccache]: https://github.com/mozilla/sccache

## CI周辺のカスタムツール

長年にわたり、CI体験を向上させるためにいくつかのカスタムツールを開発しました。

### PRにエラーメッセージを表示するRust Log Analyzer

`rust-lang/rust`のビルドログは巨大で、ログを見てビルドが失敗した原因を見つけることは現実的ではありません。
したがって、失敗時にビルドログを受信し、エラーメッセージを自動的に抽出してPRスレッドに投稿する[Rust Log Analyzer][rla]（RLA）と呼ばれるボットを開発しました。

ボットはエラー文字列を探すようにハードコードされているのではなく、多数のビルド失敗でトレーニングされて、ビルド間で共通する行と共通しない行を認識します。
生成されたスニペットは時々奇妙になることがありますが、ボットは以前に見たことがないエラーであっても、関連する行を識別するのにかなり優れています。

[rla]: https://github.com/rust-lang/rust-log-analyzer

### 許可された失敗をサポートするToolstate

`rust-lang/rust`リポジトリは、CIでコンパイラをテストするだけでなく、さまざまなツールとドキュメンテーションもテストします。
一部のドキュメンテーションはgitサブモジュールを介してプルされます。
ドキュメンテーションが修正されることでrustc PRのマージをブロックした場合、卵が先か鶏が先かという問題に陥ります。ドキュメンテーションのCIは、まだマージされていないバージョンのrustcに対してテストする必要があるため、更新しても合格しないためです（通常、CIが合格することを要求します）。

問題を回避するために、サブモジュールは失敗が許可され、そのステータスは[rust-toolstate]に記録されます。
サブモジュールが壊れると、ボットは自動的にメンテナーにpingして破壊を知らせ、toolstateリポジトリに失敗を記録します。
リリースプロセスは、nightlyで壊れたツールを無視し、出荷されるnightlyからそれらを削除します。

ツールの失敗はほとんどの場合許可されますが、リリースの1週間前に自動的に禁止されます：nightlyでツールが壊れていても構いませんが、betaとstableで機能する必要があるため、nightlyをbetaに昇格する数日前にnightlyでも機能する必要があります。

詳細については、[toolstate documentation]を参照してください。

[rust-toolstate]: https://rust-lang-nursery.github.io/rust-toolstate
[toolstate documentation]: https://forge.rust-lang.org/infra/toolstate.html

## パブリックCIダッシュボード

Rust CIを監視するために、infraチームが維持している[public dashboard]を見ることができます。

ダッシュボードからの有用なパネルのいくつか：

- Pipeline duration：autoビルドの実行にかかる時間を確認します。
- Top slowest jobs：最も時間がかかっているジョブを確認します。
- Change in median job duration：以前より遅いジョブを確認します。回帰を検出するのに役立ちます。
- Top failed jobs：最も失敗しているジョブを確認します。

ダッシュボードの詳細については、[Datadog CI docs]を参照してください。

[Datadog CI docs]: https://docs.datadoghq.com/continuous_integration/
[public dashboard]: https://p.datadoghq.com/sb/3a172e20-e9e1-11ed-80e3-da7ad0900002-b5f7bb7e08b664a06b08527da85f7e30

## CI構成の決定

特定のジョブでCIで使用される`bootstrap.toml`設定を決定したい場合は、ビルドログを見るのがおそらく最も簡単です。
これを行うには：

1. <https://github.com/rust-lang/rust/actions?query=branch%3Aauto+is%3Asuccess>にアクセスして、最近成功したビルドを見つけてクリックします。
2. 左側で興味のあるジョブを選択します。
3. 歯車アイコンをクリックして「View raw logs」を選択します。
4. 文字列「Configure the build」を検索します。
5. すべてのビルド設定は、テキスト`build.configure-args`を含む行にリストされています。

[GitHub Actions]: https://github.com/rust-lang/rust/actions
[`jobs.yml`]: https://github.com/rust-lang/rust/blob/HEAD/src/ci/github-actions/jobs.yml
[`.github/workflows/ci.yml`]: https://github.com/rust-lang/rust/blob/HEAD/.github/workflows/ci.yml
[`src/ci/citool`]: https://github.com/rust-lang/rust/blob/HEAD/src/ci/citool
[bors]: https://github.com/bors
[homu]: https://github.com/rust-lang/homu
[マージキュー]: https://bors.rust-lang.org/queue/rust
[dist-x86_64-linux]: https://github.com/rust-lang/rust/blob/HEAD/src/ci/docker/host-x86_64/dist-x86_64-linux/Dockerfile
[the GitHub Actions workflows page]: https://github.com/rust-lang/rust/actions
