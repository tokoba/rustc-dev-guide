# Dockerでのテスト

[`src/ci/docker`]ディレクトリには、GitHub Actions上で実行されるLinuxベースのジョブのための[Docker]イメージ定義が含まれています（非Linuxジョブはdocker外で実行されます）。ローカル開発マシンでこれらのジョブを実行できます。これは、ローカルシステムとは異なる環境をテストするのに役立ちます。Linux、Windows、またはmacOSシステムにDockerをインストールする必要があります（通常、LinuxはWindowsまたはmacOSよりもはるかに高速です。後者はLinux環境をエミュレートするために仮想マシンを使用するためです）。

CIで実行されるジョブは、一連のbashスクリプトを介して設定されており、その動作をローカルで再現することは必ずしも簡単ではありません。可能な限り簡単な方法でCIジョブをローカルで実行したい場合は、CIで発生することをできるだけ忠実に再現しようとする提供されたヘルパー`citool`を使用できます：

```bash
cargo run --manifest-path src/ci/citool/Cargo.toml run-local <job-name>
# 例：
cargo run --manifest-path src/ci/citool/Cargo.toml run-local dist-x86_64-linux-alt
```

上記のスクリプトがうまくいかない場合、Dockerイメージの実行をより詳細に制御したい場合、またはDockerジョブの実行中に正確に何が起こるかを理解したい場合は、以下を読み続けてください。

## `run.sh`スクリプト

[`src/ci/docker/run.sh`]スクリプトは、特定のDockerイメージをビルドし、実行し、イメージ内でRustをビルドし、テストを実行するか、配布用に設計された一連のアーカイブを準備するために使用されます。スクリプトは、ローカルのRustソースツリーを読み取り専用モードでマウントし、`obj`ディレクトリを読み書きモードでマウントします。すべてのコンパイラアーティファクトは`obj`ディレクトリに保存されます。シェルは`obj`ディレクトリから開始されます。そこから、Dockerイメージによって定義されたビルドを開始する`../src/ci/run.sh`を実行します。

`src/ci/docker/run.sh <image-name>`を直接実行できます。`run.sh`スクリプトに関するいくつかの重要な注意事項：

- CIで実行されるとき、スクリプトはすべてのサブモジュールがチェックアウトされていることを期待します。ジョブによってアクセスされる一部のサブモジュールが利用できない場合、ビルドはエラーになります。したがって、必要なすべてのサブモジュールがローカルにチェックアウトされていることを確認する必要があります。git経由で手動で行うか、`bootstrap.toml`に`submodules = true`を設定し、`x build`のようなコマンドを実行してbootstrapに最も重要なサブモジュールをダウンロードさせることができます（ただし、実行しようとしている特定のCIジョブには十分でない可能性があります）。
- `<image-name>`は、`src/ci/docker/host-*`ディレクトリのいずれかに配置された単一のディレクトリに対応します。イメージ名は必ずしもジョブ名に対応しないことに注意してください。一部のジョブは同じイメージを実行しますが、異なる環境変数またはDockerビルド引数を使用します（これは、CIジョブをローカルで実行することを困難にする複雑さの一部です）。
- 「dist」ジョブ（`dist-`で始まるジョブ）を実行している場合は、`DEPLOY=1`環境変数を設定する必要があります。
- 「代替dist」ジョブ（`dist-`で始まり`-alt`で終わるジョブ）を実行している場合は、`DEPLOY_ALT=1`環境変数を設定する必要があります。
- stdテストの一部にはIPv6サポートが必要です。LinuxのDockerはデフォルトで無効になっているようです。コンテナを作成する前に、[`enable-docker-ipv6.sh`]のコマンドを実行してIPv6を有効にしてください。これは一度だけ実行する必要があります。

### インタラクティブモード

場合によっては、特定のDockerイメージをビルドしてから、その中でカスタムコマンドを実行して、特定のシステムがどのように動作するかを実験できると便利です。インタラクティブモードを使用してこれを行うことができます。これにより、`src/ci/docker/run.sh --dev <image-name>`を使用してコンテナ内でbashシェルが起動されます。

Dockerコンテナ内では、個々のコマンドを実行して特定のタスクを実行できます。たとえば、`../x test tests/ui`を実行してUIテストのみを実行できます。

インタラクティブモードの使用に関する追加の注意事項：

- シェルを終了すると、コンテナは自動的に削除されますが、ビルドアーティファクトは`obj`ディレクトリに保持されます。異なるDockerイメージを切り替える場合、`obj`ディレクトリに保存されている以前の環境からのアーティファクトがビルドシステムを混乱させる可能性があります。コンテナ内でビルドする前に、`obj`ディレクトリの一部またはすべてを削除する必要がある場合があります。
- コンテナは最小限のパッケージのみを備えたベアボーンです。`apt install less vim`のようなものをインストールしたい場合があります。
- コンテナ内で複数のシェルを開くことができます。まず、コンテナ名（短いハッシュ）が必要です。これはシェルプロンプトに表示されるか、コンテナの外で`docker container ls`を実行して利用可能なコンテナをリストできます。コンテナ名を使用して、`docker exec -it <CONTAINER> /bin/bash`を実行します。`<CONTAINER>`は`4ba195e95cef`のようなコンテナ名です。

[Docker]: https://www.docker.com/
[`src/ci/docker`]: https://github.com/rust-lang/rust/tree/HEAD/src/ci/docker
[`src/ci/docker/run.sh`]: https://github.com/rust-lang/rust/blob/HEAD/src/ci/docker/run.sh
[`enable-docker-ipv6.sh`]: https://github.com/rust-lang/rust/blob/HEAD/src/ci/scripts/enable-docker-ipv6.sh
