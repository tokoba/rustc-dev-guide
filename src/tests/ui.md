# UI テスト

UI テストは compiletest の特定の[テストスイート](compiletest.md#test-suites)です。

## はじめに

[`tests/ui`] のテストは、主にコンパイラのコンソール出力の検証に焦点を当てた汎用テストのコレクションですが、他の多くの目的にも使用できます。例えば、テストは結果として得られるプログラムを[実行](#controlling-passfail-expectations)してその動作を検証するように構成することもできます。

`tests/ui` 配下の各サブディレクトリの目的の調査については、[SUMMARY.md](https://github.com/rust-lang/rust/tree/HEAD/tests/ui/SUMMARY.md) を参照してください。
新しいテストを書く場合、それを配置するカテゴリを探す際に便利です。

`#![no_std]` クロスコンパイルテストを扱う必要がある場合は、[`minicore` テスト補助](./minicore.md) の章を参照してください。

[`tests/ui`]: https://github.com/rust-lang/rust/blob/HEAD/tests/ui

## テストの一般的な構造

テストは `tests/ui` ディレクトリに配置された Rust ソースファイルで構成されます。
**テストは目的とテストカテゴリに基づいて適切なサブディレクトリに配置する必要があります** - `tests/ui` に直接テストを配置することは許可されていません。

Compiletest は `rustc` を使用してテストをコンパイルし、出力をテストの隣に配置された `.stdout` または `.stderr` ファイルに保存された期待される出力と比較します。詳細については、[出力の比較](#output-comparison) を参照してください。

さらに、エラーと警告はソースファイル内のコメントでアノテーションする必要があります。詳細については、[エラーアノテーション](#error-annotations) を参照してください。

`//@` で始まる特別なコメントの形式の Compiletest [ディレクティブ](directives.md) は、テストのコンパイル方法と期待される動作を制御します。

テストはコンパイルに失敗することが期待されます。ほとんどのテストはコンパイラエラーをテストしているためです。ディレクティブでその動作を変更できます。[pass/fail 期待値の制御](#controlling-passfail-expectations) を参照してください。

デフォルトでは、テストは実行可能バイナリとしてビルドされます。異なるクレートタイプが必要な場合は、必要に応じて `#![crate_type]` 属性を使用して設定できます。

## 出力の比較

UI テストは、コンパイラからの期待される出力を、テストの隣にある `.stderr` および `.stdout` スナップショットに保存します。通常、これらのファイルは `--bless` CLI オプションで生成し、それらが期待するものを含んでいるかを手動で検証します。

出力は不要な差異を無視するために正規化されます。[正規化](#normalization) セクションを参照してください。ファイルが欠けている場合、compiletest は対応する出力が空であることを期待します。

正規化、リビジョン、およびその他のほとんどのツールを使用する一般的な理由は、プラットフォームの違いを考慮することです。これらのツールの代替案を検討してください。例えば、クロスコンパイルを使用してすべての可能性のある無効な ABI をテストする代わりに、すべてのプラットフォームで無効な `extern "rust-invalid"` ABI を使用することなどです。

複数の stdout/stderr ファイルが存在する可能性があります。一般的な形式は次のとおりです：

```text
*test-name*`.`*revision*`.`*compare_mode*`.`*extension*
```

- *test-name* にはドットを含めることができません。これにより、テスト出力ファイル名の一般的な形式が予測可能なパターンマッチングが可能になり、迷子のテスト出力ファイルを追跡できます。
- *revision* は[リビジョン](#cfg-revisions) 名です。リビジョンを使用していない場合は含まれません。
- *compare_mode* は[比較モード](#compare-modes)です。これは、指定された比較モードがアクティブな場合にのみチェックされます。ファイルが存在しない場合、compiletest は比較モードなしのファイルをチェックします。
- *extension* はチェックされる出力の種類です：
  - `stderr` — コンパイラの stderr
  - `stdout` — コンパイラの stdout
  - `run.stderr` — テスト実行時の stderr
  - `run.stdout` — テスト実行時の stdout
  - `64bit.stderr` — 64 ビットターゲットでの `stderr-per-bitwidth` ディレクティブを持つコンパイラの stderr
  - `32bit.stderr` — 32 ビットターゲットでの `stderr-per-bitwidth` ディレクティブを持つコンパイラの stderr

簡単な例は、`foo.rs` テストの隣にある `foo.stderr` です。
より複雑な例は `foo.my-revision.polonius.stderr` です。

compiletest が出力ファイルをチェックする方法を変更するいくつかの[ディレクティブ](directives.md) があります：

- `stderr-per-bitwidth` — ターゲットポインタ幅に基づいて個別の出力ファイルをチェックします。代わりに `normalize-stderr` ディレクティブの使用を検討してください（[正規化](#normalization) を参照）。
- `dont-check-compiler-stderr` — コンパイラからの stderr を無視します。
- `dont-check-compiler-stdout` — コンパイラからの stdout を無視します。
- `compare-output-by-lines` — 一部のテストには非決定的な出力順序があるため、行ごとに比較する必要があります。

UI テストは、rustc の組み込み診断重複排除メカニズムを無効にする `-Zdeduplicate-diagnostics=no` フラグで実行されます。これは、出力に重複メッセージが表示される可能性があることを意味します。これは、重複診断が生成されている状況を明らかにするのに役立ちます。

### 正規化

コンパイラ出力は、プラットフォーム間の出力差異（主にファイル名について）を排除するために正規化されます。

Compiletest は、コンパイラ出力に対して次の置換を行います：

- テストが定義されているディレクトリは `$DIR` に置き換えられます。例：
  `/path/to/rust/tests/ui/error-codes`
- 標準ライブラリソースへのディレクトリは `$SRC_DIR` に置き換えられます。
  例：`/path/to/rust/library`
- `$SRC_DIR` のパスの行番号と列番号は `LL:COL` に置き換えられます。
  これにより、標準ライブラリのレイアウトへの変更が `.stderr` ファイルへの広範な変更を引き起こさないようにします。例：
  `$SRC_DIR/alloc/src/sync.rs:53:46`
- テストの出力が行く基本ディレクトリは `$TEST_BUILD_DIR` に置き換えられます。これはまれな状況でのみ発生します。例：
  `/path/to/rust/build/x86_64-unknown-linux-gnu/test/ui`
- 標準ライブラリソースへの実際のディレクトリは `$SRC_DIR_REAL` に置き換えられます。
- コンパイラソースへの実際のディレクトリは `$COMPILER_DIR_REAL` に置き換えられます。
- タブは `\t` に置き換えられます。
- パス内のバックスラッシュ（`\`）は（ヒューリスティックを使用して）フォワードスラッシュ（`/`）に変換されます。これにより、Windows スタイルのパスとの違いを正規化するのに役立ちます。
- CRLF 改行は LF に変換されます。
- `//~ ERROR some message` のようなエラー行アノテーションは削除されます。
- 様々な v0 および legacy シンボルハッシュは、`[HASH]` や `<SYMBOL_HASH>` のようなプレースホルダーに置き換えられます。

さらに、コンパイラは `-Z ui-testing` フラグで実行されます。これにより、
コンパイラ自体が診断出力に一部の変更を適用し、UI テストにより適したものにします。

例えば、出力の行番号を匿名化します（各ソース行の先頭にある行番号は `LL` に置き換えられます）。極めてまれな状況では、このモードはディレクティブ `//@
compile-flags: -Z ui-testing=no` で無効にできます。

注意：テストを指す `-->` 行の行番号と列番号は正規化*されず*、そのまま残されます。これにより、コンパイラが正しい場所を指し続け、stderr ファイルが読みやすく保たれます。理想的には、すべての行/列情報が保持されますが、ソースへの小さな変更が大きな差分を引き起こし、より頻繁なマージコンフリクトとテストエラーを引き起こします。

時には、これらの組み込み正規化では十分でない場合があります。そのような場合、`normalize-*` ディレクティブを使用してカスタム正規化ルールを提供できます。例えば：

```rust,ignore
//@ normalize-stdout: "foo" -> "bar"
//@ normalize-stderr: "foo" -> "bar"
//@ normalize-stderr-32bit: "fn\(\) \(32 bits\)" -> "fn\(\) \($$PTR bits\)"
//@ normalize-stderr-64bit: "fn\(\) \(64 bits\)" -> "fn\(\) \($$PTR bits\)"
```

これは、32 ビットプラットフォームで、コンパイラが stderr に `fn() (32
bits)` を書き込むたびに、代わりに `fn() ($PTR bits)` と読むように正規化するようテストに指示します。
64 ビットも同様です。置換は、`regex` クレートが提供するデフォルトの正規表現フレーバーを使用する正規表現によって実行されます。

対応するリファレンスファイルは、正規化された出力を使用して 32 ビットと 64 ビットの両方のプラットフォームをテストします：

```text
...
   |
   = note: source type: fn() ($PTR bits)
   = note: target type: u16 (16 bits)
...
```

具体的な使用例については、[`ui/transmute/main.rs`][mrs] および [`main.stderr`] を参照してください。

[mrs]: https://github.com/rust-lang/rust/blob/HEAD/tests/ui/transmute/main.rs
[`main.stderr`]: https://github.com/rust-lang/rust/blob/HEAD/tests/ui/transmute/main.stderr

## エラーアノテーション

エラーアノテーションは、コンパイラが発行することが期待されるエラーを指定します。
エラーが発生するソースの行に「添付」されます。

```rust,ignore
fn main() {
    boom  //~ ERROR cannot find value `boom` in this scope [E0425]
}
```

UI テストにはコンパイラの出力全体を含む `.stderr` ファイルがありますが、UI テストではエラーがソース内でもアノテーションされている必要があります。この冗長性は、通常は自動生成される `.stderr` ファイルのミスを避けるのに役立ちます。また、`.stderr` ファイルとソースを比較する代わりに、1つのファイルを見るだけでエラースパンがどこを指すことが期待されているかを直接確認できます。最後に、追加の予期しないエラーが生成されないことを保証します。

複数の形式がありますが、一般的には診断レベル（`ERROR` など）と期待されるエラー出力のサブストリングを含むコメントです。メッセージ全体を書き出す必要はありません。メッセージの重要な部分を含めて自己文書化するようにしてください。

ほとんどのエラーアノテーションは診断の行と一致する必要があります。メッセージを行と一致させる方法はいくつかあります（以下の例を参照）：

- `~`: エラーレベルとメッセージを*現在*の行に関連付けます
- `~^`: エラーレベルとメッセージを*前の*エラーアノテーション行に関連付けます。キャレット（`^`）を追加するたびに、行が追加されるため、`~^^^` はエラーアノテーション行の3行上です。
- `~|`: エラーレベルとメッセージを*前のコメント*と*同じ*行に関連付けます。これは、同じ行に関連付けられた複数のメッセージがある場合、複数のキャレットを使用するよりも便利です。
- `~v`: エラーレベルとメッセージを*次の*エラーアノテーション行に関連付けます。各記号（`v`）を追加するたびに、行が追加されるため、`~vvv` はエラーアノテーション行の3行下です。

例：

```rust,ignore
let _ = same_line; //~ ERROR undeclared variable
fn meow(_: [u8]) {}
//~^ ERROR unsized
//~| ERROR anonymous parameters
```

`//~`（または他のバリアント）とそれに続くテキストの間のスペース文字は無視されます（つまり、`//~ ERROR` と `//~ERROR` の間に意味上の違いはありませんが、前者がコードベースでより一般的です）。

`~? <診断種類>`（例：`~? ERROR`）は、
行情報が全くない診断、またはメインテストファイル[^main test file]の外に行情報がある診断に一致するために使用されます。
これらのアノテーションは、テストファイルの任意の行に配置できます。

[^main test file]: これは `~?` アノテーションを持つファイルであり、
aux ファイルや、制御できないソースとは異なります。

### エラーアノテーションの例

UI テストソースの異なる行のエラーアノテーションの例を示します。

#### エラー行に配置

`//~ ERROR` イディオムを使用します：

```rust,ignore
fn main() {
    let x = (1, 2, 3);
    match x {
        (_a, _x @ ..) => {} //~ ERROR `_x @` is not allowed in a tuple
        _ => {}
    }
}
```

#### エラー行の下に配置

`//~^` イディオムを使用し、文字列内のキャレットの数で上の行数を示します。以下の例では、エラー行はエラーアノテーション行の4行上なので、アノテーションに4つのキャレットが含まれています。

```rust,ignore
fn main() {
    let x = (1, 2, 3);
    match x {
        (_a, _x @ ..) => {}  // <- エラーはこの行にあります
        _ => {}
    }
}
//~^^^^ ERROR `_x @` is not allowed in a tuple
```

#### 上のエラーアノテーション行で定義したのと同じエラー行を使用

`//~|` イディオムを使用して、上のエラーアノテーション行と同じエラー行を定義します：

```rust,ignore
struct Binder(i32, i32, i32);

fn main() {
    let x = Binder(1, 2, 3);
    match x {
        Binder(_a, _x @ ..) => {}  // <- エラーはこの行にあります
        _ => {}
    }
}
//~^^^^ ERROR `_x @` is not allowed in a tuple struct
//~| ERROR this pattern has 1 field, but the corresponding tuple struct has 3 fields [E0023]
```

#### エラー行の上に配置

`//~v` イディオムを使用し、文字列内の v の数で下の行数を示します。これは通常、ファイル末尾で発生する閉じられていないデリミタや閉じられていないリテラルなどのエラーに一致するレクサーまたはパーサーテストで使用されます。

```rust,ignore
// ignore-tidy-trailing-newlines
//~v ERROR this file contains an unclosed delimiter
fn main((ؼ
```

#### 行情報のないエラー

`//~?` を使用して、行情報のないエラーに一致させます。
`//~?` は正確で、行情報が利用可能な場合はエラーに一致しません。
コンパイラ診断に対して一致させたいテストでは、
`//@ error-pattern` が不正確で非網羅的であるため、これを優先する必要があります。

```rust,ignore
//@ compile-flags: --print yyyy

//~? ERROR unknown print request: `yyyy`
```

### `error-pattern`

`error-pattern` [ディレクティブ](directives.md) は、特定のスパンを持たないランタイムメッセージ、または例外的な場合にはコンパイル時メッセージに使用できます。

このテストについて考えてみましょう：

```rust,ignore
fn main() {
    let a: *const [_] = &[1, 2, 3];
    unsafe {
        let _b = (*a)[3];
    }
}
```

「index out of bounds」が表示されることを保証したいのですが、ランタイムエラーにはスパンがないため、`ERROR` アノテーションを使用できません。その場合は、`error-pattern` ディレクティブを使用します：

```rust,ignore
//@ error-pattern: index out of bounds
fn main() {
    let a: *const [_] = &[1, 2, 3];
    unsafe {
        let _b = (*a)[3];
    }
}
```

コンパイル時出力の厳密なテストには、`//~?` アノテーションを含め、できるだけ行アノテーション `//~` を使用するようにしてください。

コンパイル時出力がターゲット依存または冗長すぎる場合は、ディレクティブ
`//@ dont-require-annotations: <diagnostic-kind>` を使用して行アノテーションチェックを
非網羅的にします。
このモードでは、一部のコンパイラメッセージはアノテーションでカバーされなくても構いません。

ランタイム出力をチェックする場合は、`//@ check-run-results` の方が望ましい場合があります。

上記のいずれも機能しない場合にのみ `error-pattern` を使用してください。例えば、ランタイムパニック出力で特定の文字列パターンを見つける場合などです。

行アノテーション `//~` と `error-pattern` は互換性があり、同じテストで使用できます。

### 診断の種類（エラーレベル）

使用できる診断の種類は次のとおりです：

- `ERROR`
- `WARN`（または `WARNING`）
- `NOTE`
- `HELP`
- `SUGGESTION`
- `RAW`

`SUGGESTION` の種類は、診断提案の期待される置換テキストがどうあるべきかを指定するために使用されます。
`RAW` の種類は、構造化 json の代わりにまたはそれに加えてコンパイラが時々発行する非構造化出力の行に一致させるために使用できます。

`ERROR` および `WARN` の種類は、デフォルトで行アノテーション `//~` によって網羅的にカバーされる必要があります。

他の種類は、その種類のアノテーションが少なくとも1つテストファイルに現れる場合にのみ、行アノテーションが必要です。例えば、1つの `//~ NOTE` があれば、ファイル内の他のすべての `//~ NOTE` も明示的に書き出す必要があります。

ディレクティブ `//@ dont-require-annotations` を使用して、網羅的なアノテーションをオプトアウトします。
例えば、`//@ dont-require-annotations: NOTE` を使用してノートを選択的にアノテーションします。
`ERROR` と `WARN` にこのディレクティブを使用することは避けてください。ターゲット依存のコンパイラ出力など、深刻な理由がない限りです。

一部の診断は、その種類やディレクティブに関係なく、行アノテーションが決して必要ありません。
例えば、複数行診断のセカンダリ行や、
`aborting due to N previous errors` のような遍在する診断などです。

UI テストはデフォルトで `-A unused` フラグを使用してすべての未使用警告を無視します。
未使用警告は通常テストの焦点ではないためです。ただし、単純なコードサンプルには未使用警告がよくあります。テストが特に未使用警告をテストしている場合は、必要に応じて適切な `#![warn(unused)]` 属性を追加するだけです。

### `cfg` リビジョン

[リビジョン](compiletest.md#revisions) を使用する場合、現在のリビジョンに基づいて異なるメッセージを条件付きでチェックできます。これは、次のようにリビジョン cfg 名をブラケットに入れることによって行われます：

```rust,ignore
//@ edition:2018
//@ revisions: mir thir
//@[thir] compile-flags: -Z thir-unsafeck

async unsafe fn f() {}

async fn g() {
    f(); //~ ERROR call to unsafe function is unsafe
}

fn main() {
    f(); //[mir]~ ERROR call to unsafe function is unsafe
}
```

この例では、2番目のエラーメッセージは `mir` リビジョンでのみ発行されます。
`thir` リビジョンは最初のエラーのみを発行します。

`cfg` がコンパイラに異なる出力を発行させる場合、テストには異なる出力用の複数の `.stderr` ファイルを持つことができます。上記の例では、異なるリビジョンの異なる出力を含む `.mir.stderr` および `.thir.stderr` ファイルがあります。

> 注意：cfg リビジョンは `#[cfg]` 属性を使用してソースコード内でも機能します。
>
> 慣例により、`FALSE` cfg は常に false の設定を持つために使用されます。

## pass/fail 期待値の制御

デフォルトでは、UI テストは**コンパイルエラーを生成する**ことが期待されます。ほとんどのテストは無効な入力とエラー診断をチェックしているためです。ただし、コンパイルが成功することが期待される UI テストを作成することもできますし、結果として得られるプログラムを実行することさえできます。次の[ディレクティブ](directives.md) のいずれかを追加するだけです：

- Pass ディレクティブ：
  - `//@ check-pass` — コンパイルは成功するがコード生成をスキップする必要があります
    （コード生成は高価で、ほとんどの場合失敗しないはずです）。
  - `//@ build-pass` — コンパイルとリンクは成功するが、
    結果のバイナリは実行しません。
  - `//@ run-pass` — コンパイルは成功し、結果のバイナリを実行するとコード 0 で終了する必要があります（成功を示します）。
- Fail ディレクティブ：
  - `//@ check-fail` — コンパイルは失敗する必要があります（コード生成フェーズはスキップされます）。
    これは UI テストのデフォルトです。
  - `//@ build-fail` — コンパイルはコード生成フェーズ中に失敗する必要があります。
    これは `rustc` を2回実行します：
    - 1回目はコード生成フェーズなしでコンパイルが成功することを確認します
    - 2回目は完全なコンパイルが失敗することを確認します
  - `//@ run-fail` — コンパイルは成功するが、結果のバイナリを実行すると
    `1..=127` の範囲のコードで終了する必要があります（通常の失敗を示します）。unwind サポートのないターゲットでは、
    クラッシュも受け入れられます。
  - `//@ run-crash` — コンパイルは成功するが、結果のバイナリを実行すると
    クラッシュで失敗する必要があります。クラッシュは「`0..=127` の範囲のコードで終了しない」と定義されます。Linux での例：`SIGABRT`
    または `SIGSEGV` による終了。Windows での例：`STATUS_ILLEGAL_INSTRUCTION`（`0xC000001D`）のコードで終了。
  - `//@ run-fail-or-crash` — コンパイルは成功するが、結果のバイナリを実行すると
    `run-fail` または `run-crash` のいずれかになる必要があります。一部のターゲットでクラッシュするが、他のターゲットでは失敗するだけのテストに便利です。

`run-pass`、`run-fail`、`run-crash`、`run-fail-or-crash` テストの場合、
デフォルトではプログラム自体の出力はチェックされません。

プログラムを実行した出力をチェックしたい場合は、
`check-run-results` ディレクティブを含めてください。これにより、プログラムの実際の出力と比較する `.run.stderr` および
`.run.stdout` ファイルがチェックされます。

`*-pass` ディレクティブを持つテストは、`--pass` コマンドラインオプションでオーバーライドできます：

```sh
./x test tests/ui --pass check
```

`--pass` オプションは UI テストにのみ影響します。`--pass check` を使用すると、UI テストスイートをはるかに高速に（私のシステムでは約2倍高速に）実行できますが、明らかにそれほど多くは実行されません。

`ignore-pass` ディレクティブを使用して、テストがそのオーバーライドで正しく機能しない場合に `--pass` CLI フラグを無視できます。

## 既知のバグ

`known-bug` ディレクティブは、まだ修正されていない既知のバグを示すテストに使用できます。既知のバグのテストを追加すると、いくつかの理由で役立ちます：

1. バグが修正されたときに便利に再利用できる機能テストを維持します。
2. バグが偶然修正された場合に失敗するセンチネルを提供します。これにより、開発者はバグが修正されたことを知り、関連する issue をクローズできる可能性があります。

このディレクティブは、カンマ区切りの issue 番号を引数として取るか、`"unknown"` を取ります：

- `//@ known-bug: #123, #456`（issue が rust-lang/rust にある場合）
- `//@ known-bug: rust-lang/chalk#123456`
  （`#` の前に任意のテキストを許可します。これは issue が別のリポジトリにある場合に便利です）
- `//@ known-bug: unknown`
  （既知の issue がまだない場合。可能であれば、まだ存在しない場合は開いてください）

`known-bug` を持つテストには[エラーアノテーション](#error-annotations) を含めないでください。テストには他の通常のディレクティブと stdout/stderr ファイルを含める必要があります。

## テストの整理

テストファイルを配置する場所を決定するときは、何をテストしようとしているかに最も適合するサブディレクトリを見つけるようにしてください。できる限り整理された状態を保つようにしてください。一部のテストは異なるカテゴリにまたがる可能性があり、既存のレイアウトがうまく適合しない可能性があるため、難しい場合があることは認めます。

テストがチェックしている内容の簡潔な説明でテストに名前を付けてください。テスト名に issue 番号を含めることは避けてください。これについての詳細な議論については、[ベストプラクティス](best-practices.md) を参照してください。

理想的には、テストはここでテストされているコードの部分を識別するのに役立つディレクトリに追加する必要があります（例：
`tests/ui/borrowck/reject-move-out-of-borrow-via-pat.rs`）

新しい機能を書くときは、**テストを保存するサブディレクトリを作成する**ことをお勧めします。例えば、RFC 1234（「Widgets」）を実装している場合、
`tests/ui/rfc1234-widgets/` のようなディレクトリにテストを配置するのが理にかなっているかもしれません。

他の場合には、既に適切なディレクトリがあるかもしれません。

時間の経過とともに、[`tests/ui`] ディレクトリは非常に速く成長しました。[tidy](intro.md#tidy) には、サブディレクトリのいずれかが 1000 以上のエントリを持たないことを保証するチェックがあります。ファイルが多すぎると、エディタ/IDE に優しくなく、GitHub UI が 1000 以上のエントリを表示しないため、問題が発生します。ただし、`tests/ui`（UI テストルートディレクトリ）と `tests/ui/issues` ディレクトリには 1000 以上のエントリがあるため、これらのディレクトリには異なる制限を設定しています。したがって、新しいテストをそこに配置することは避け、より関連性の高い場所を見つけるようにしてください。

例えば、テストがクロージャに関連している場合は、`tests/ui/closures` に配置する必要があります。制限に達したら、[ここ][ui test tidy]を調整して増やすことができます。

[ui test tidy]: https://github.com/rust-lang/rust/blob/HEAD/src/tools/tidy/src/ui_tests.rs

## Rustfix テスト

UI テストは、診断提案が正しく適用され、結果の変更が正しくコンパイルされることを検証できます。これは `run-rustfix` ディレクティブで行うことができます：

```rust,ignore
//@ run-rustfix
//@ check-pass
#![crate_type = "lib"]

pub struct not_camel_case {}
//~^ WARN `not_camel_case` should have an upper camel case name
//~| HELP convert the identifier to upper camel case
//~| SUGGESTION NotCamelCase
```

Rustfix テストには、提案が適用された後のソースファイルを含む `.fixed` 拡張子のファイルが必要です。

- テストが実行されると、compiletest は最初に正しい lint/警告が
  生成されることをチェックします。
- 次に、提案を適用して `.fixed` と比較します（一致する必要があります）。
- 最後に、修正されたソースがコンパイルされ、このコンパイルは
  成功する必要があります。

通常、rustfix テストを作成するときは、`x test --bless` オプションで `.fixed` ファイルを自動的に生成します。

`run-rustfix` ディレクティブは、[`MachineApplicable`](../diagnostics.md#suggestions) でなくても、*すべての*提案を適用します。これが問題である場合は、`run-rustfix` に加えて `rustfix-only-machine-applicable` ディレクティブを追加できます。これは、異なる提案レベルが混在しており、一部の非機械適用可能なものがきれいに適用されない場合に使用する必要があります。

## 比較モード

[比較モード](compiletest.md#compare-modes) を使用すると、通常とは異なるフラグですべてのテストを実行できます。場合によっては、これによりコンパイラからの出力が異なる可能性があります。これをサポートするために、比較モードに基づいた出力を含む異なる出力ファイルを保存できます。

例えば、Polonius モードを使用する場合、テスト `foo.rs` はまず期待される出力を `foo.polonius.stderr` で探し、見つからない場合は通常の `foo.stderr` にフォールバックします。これは、異なるモードが時々異なる診断と動作をもたらす可能性があるため便利です。これにより、モード間で違いのあるテストを追跡し、それらの診断の違いを視覚的に検査するのに役立ちます。

まれにテストが異なる動作をする場合は、次のようなものを実行して代替 stderr ファイルを生成できます：

```sh
./x test tests/ui --compare-mode=polonius --bless
```

現在、UI テストの比較モードのいずれも CI でチェックされていません。

## `rustc_*` TEST 属性

コンパイラは、内部機能 `rustc_attrs` の背後にゲートされた、コンパイラ内部の
追加情報をダンプするいくつかの perma-unstable `#[rustc_*]` 属性を定義しています。詳細については、[コンパイラデバッグ] の対応するサブセクションを参照してください。

これらは、「ユーザー向け」の Rust だけでは同じことを行うのが非常に困難な場合に、内部コンパイラの状態をより正確に、読みやすく、簡単にテストするためにテストで使用できます。実際、これは「UI」（*ユーザー*インターフェース）という用語を若干悪用し、そのような UI テストをブラックボックステストからホワイトボックステストに変えます。慎重かつ控えめに使用してください。

[コンパイラデバッグ]: ../compiler-debugging.md#rustc_-test-attributes

## UI テストモードのプリセット lint レベル

デフォルトでは、UI テストモード配下のテストスイート（`tests/ui`、`tests/ui-fulldeps`、
ただし `tests/rustdoc-ui` は除く）は次を指定します：

- `-A unused`
- `-A internal_features`

次の場合：

- ui テストの pass モードが `run` より下（つまり check または build）。
- 比較モードが指定されていない。

UI テストでは非常にノイジーになる可能性があるためです。

必要に応じて、`compile-flags` lint レベルフラグまたは
ソース内 lint レベル属性でこれらをオーバーライドできます。

`rustfix` バージョンには `-A unused` が渡*されない*ことに注意してください。
つまり、rustfix されたファイル（`unused` lint 自体で rustfix をテストしている可能性があるため）で `unused` lint を抑制するために `#[allow(unused)]` が必要になる場合があります。
