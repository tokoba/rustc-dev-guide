# キャッシュとそれに伴う微妙な考慮事項

一般に、トレイト選択の結果をキャッシュすることを試みます。これは
やや複雑なプロセスです。その理由の一部は、トレイト参照内の
すべての型が完全に判明していない場合でも、結果をキャッシュできるように
したいからです。その場合、トレイト選択プロセスも型変数に影響を与えている
可能性があるため、選択プロセスの*結果*だけでなく、型変数への
その*影響を再現*できる必要があります。

## 例

キャッシュがどのように動作するかの高レベルなアイデアは、まず
すべての未束縛の推論変数をプレースホルダーバージョンに置き換える
ことです。したがって、トレイト参照 `usize : Foo<$t>` があり、`$t` が未束縛の
推論変数である場合、それを `usize : Foo<$0>` に置き換えることができます。ここで
`$0` はプレースホルダー型です。その後、これをキャッシュで検索します。

ヒットが見つかった場合、ヒットは選択プロセスで次に取るべき
ステップを教えてくれます（例：impl #22 を適用する、または
where 句 `X : Foo<Y>` を適用する）。

一方、ヒットがない場合は、[選択プロセス]を最初から実行する
必要があります。例えば、次の唯一可能な impl が def-id 22 の
ものであるという結論に達したとします：

```rust,ignore
impl Foo<isize> for usize { ... } // Impl #22
```

次に、キャッシュに `usize : Foo<$0> => ImplCandidate(22)` を記録します。次に
`ImplCandidate(22)` を[確認]し、それが（副作用として）`$t` を
`isize` に単一化します。

さて、後でいつか、`usize : Foo<$u>` を見かけることがあります。プレースホルダーに
置き換えると、これは以前と同じように `usize : Foo<$0>` になり、
したがってキャッシュ検索は成功し、`ImplCandidate(22)` が得られます。
`ImplCandidate(22)` を確認すると、（副作用として）`$u` が `isize` に
単一化されます。

## Where 句とローカルキャッシュ vs グローバルキャッシュ

微妙な相互作用の1つは、トレイト検索の結果がスコープ内にある
where 句によって変わることです。したがって、実際には*2つ*のキャッシュ、
ローカルとグローバルのキャッシュがあります。ローカルキャッシュは
[`ParamEnv`] に、グローバルキャッシュは [`tcx`] に添付されています。
結果がスコープ内の where 句に依存する可能性がある場合は常に、
ローカルキャッシュを使用します。どのキャッシュを使用するかの決定は、
`select.rs` の `pick_candidate_cache` メソッドによって行われます。
現時点では、非常にシンプルで保守的なルールを使用しています：スコープ内に
where 句がある場合は、ローカルキャッシュを使用します。以前は
より細かい区別を試みていましたが、それは [#22019] や [#18290] のような
一連の厄介で奇妙なバグにつながりました。このシンプルなルールは
非常に明確に安全であり、非常に高いヒット率（rustc をコンパイルするときに
約95%）を維持しているようです。

**TODO**: `pick_candidate_cache` はもう存在しないようです。一般的に、
このセクションはまだ正確ですか？

[`ParamEnv`]: ../typing_parameter_envs.html
[`tcx`]: ../ty.html
[#18290]: https://github.com/rust-lang/rust/issues/18290
[#22019]: https://github.com/rust-lang/rust/issues/22019
