# 正準クエリ

トレイトシステムの「開始点」は**正準クエリ**です（これらは
より一般的な意味での両方のクエリ、つまり知りたいことに対する
問いかけと、[rustc 固有の意味](../query.html)でのクエリです）。
アイデアは、型チェッカーやシステムの他の部分が、
何らかのトレイトが何らかの型に対して実装されているかどうかを
知りたい場合がある（例：`u32: Debug` は真か？）、または
関連型を正規化したい場合があるということです。

このセクションでは、かなり高いレベルの抽象化でクエリを扱います。
サブセクションでは、これらのアイデアが rustc でどのように実装されているかを
もう少し詳しく見ていきます。

## 伝統的な対話型 Prolog クエリ

伝統的な Prolog システムでは、クエリを開始すると、ソルバーは
実行を開始し、見つけられるすべての可能な答えを提供し始めます。
したがって、次のようなものがあるとします：

```text
?- Vec<i32>: AsRef<?U>
```

ソルバーは次のように答えるかもしれません：

```text
Vec<i32>: AsRef<[i32]>
    continue? (y/n)
```

この `continue` ビットは興味深いものです。Prolog のアイデアは、
ソルバーがクエリの真となる**すべての可能な**インスタンス化を
見つけていることです。この場合、`?U = [i32]` をインスタンス化すると、
クエリは真になります（伝統的な Prolog インターフェースは直接 `?U` の
値を教えてくれませんが、レスポンスを元のクエリと単一化することで
推論できます - Rust のソルバーは代わりに置換を返します）。`y` を
押すと、ソルバーは別の可能な答えを提供するかもしれません：

```text
Vec<i32>: AsRef<Vec<i32>>
    continue? (y/n)
```

この答えは、`AsRef` に対する再帰的な impl（`impl<T> AsRef<T> for T`）が
存在するという事実から導かれます。再び `y` を押すと、否定的な
レスポンスが返ってくるかもしれません：

```text
no
```

当然、場合によっては可能な答えがない場合もあり、その場合
ソルバーはすぐに `no` を返します：

```text
?- Box<i32>: Copy
    no
```

場合によっては、無限の数のレスポンスがある可能性があります。したがって、
例えば、このクエリを与えて、`y` を押し続けると、ソルバーは
答えを返し続けることを決してやめません：

```text
?- Vec<?U>: Clone
    Vec<i32>: Clone
        continue? (y/n)
    Vec<Box<i32>>: Clone
        continue? (y/n)
    Vec<Box<Box<i32>>>: Clone
        continue? (y/n)
    Vec<Box<Box<Box<i32>>>>: Clone
        continue? (y/n)
```

想像できるように、ソルバーは停止を求められるか、メモリが
なくなるまで、喜んで `Box` の別のレイヤーを追加し続けます。

もう1つの興味深い点は、クエリにまだ変数が含まれている可能性が
あることです。例えば：

```text
?- Rc<?T>: Clone
```

は次の答えを生成するかもしれません：

```text
Rc<?T>: Clone
    continue? (y/n)
```

結局のところ、`Rc<?T>` は**`?T` がどんな型であっても**真です。

<a id="query-response"></a>

## rustc のトレイトクエリ

rustc のトレイトクエリは少し異なる動作をします。**すべての可能な**答えを
列挙しようとする代わりに、**明確な**答えを探しています。特に、
型変数の値を教えてくれるとき、それは現在の impl と where 句の
セットを考えると、使用できる**唯一可能なインスタンス化**であることを
意味します。

rustc のトレイトクエリへのレスポンスは通常
`Result<QueryResult<T>, NoSolution>` です（`T` はクエリ自体によって
少し異なります）。`Err(NoSolution)` ケースは、クエリが偽であり
答えがないことを示します（例：`Box<i32>: Copy`）。
そうでなければ、`QueryResult` は見つかった可能な答えに関する情報を
返します。これは4つの部分で構成されています：

- **Certainty（確実性）：** この答えにどれだけ確信があるかを示します。2つの
  値を持つことができます：
  - `Proven` は結果が真であることが知られていることを意味します。
    - これは `Vec<i32>: Clone` や `Rc<?T>: Clone` を証明しようとした
      結果かもしれません。
  - `Ambiguous` は、まだ真*または*偽のいずれかを証明できなかった
    ものがあることを意味します。通常、より多くの型情報が必要だったためです。
    （すぐに例を見ます。）
    - これは `Vec<?T>: Clone` を証明しようとした結果かもしれません。
- **Var values（変数値）：** 元のクエリに現れた各未束縛推論変数（`?T` など）の
  値。（Prolog では、これらを推論する必要がありました。）
  - 以下の例で見るように、`Ambiguous` ケースでも変数値を
    取得できます。
- **Region constraints（領域制約）：** 入力として提供したライフタイムの間に
  成り立つ必要がある関係。ここでは無視します。
- **Value（値）：** クエリ結果には `T` 型の値も付属しています。
  関連型の正規化などの特殊なクエリの場合、これは追加の結果を
  返すために使用されますが、多くの場合は単に `()` です。

### 例

例のクエリを通して、すべての部分が何を意味するかを見てみましょう。
[`Borrow` トレイト][borrow]を考えてみましょう。このトレイトには
多数の impl があります。その中には、これらの2つがあります（明確性のため、
`Sized` 境界を明示的に書きました）：

[borrow]: https://doc.rust-lang.org/std/borrow/trait.Borrow.html

```rust,ignore
impl<T> Borrow<T> for T where T: ?Sized
impl<T> Borrow<[T]> for Vec<T> where T: Sized
```

**例 1。** この（かなり人為的な）コードの型チェックをしているとします：

```rust,ignore
fn foo<A, B>(a: A, vec_b: Option<B>) where A: Borrow<B> { }

fn main() {
    let mut t: Vec<_> = vec![]; // Type: Vec<?T>
    let mut u: Option<_> = None; // Type: Option<?U>
    foo(t, u); // 例 1: `Vec<?T>: Borrow<?U>` が必要
    ...
}
```

コメントが示すように、最初に2つの変数 `t` と `u` を作成します。
`t` は空のベクトルで、`u` は `None` オプションです。これらの変数の両方は、
型に未束縛の推論変数があります：`?T` はベクトル `t` の要素を表し、
`?U` はオプション `u` に格納されている値を表します。次に、`foo` を呼び出します。
`foo` のシグネチャをその引数と比較すると、`A = Vec<?T>` と
`B = ?U` になります。したがって、`foo` の where 句は `Vec<?T>:
Borrow<?U>` を必要とします。これが最初の例のトレイトクエリです。

クエリ `Vec<?T>: Borrow<?U>` には多くの可能な解決策があります。
例えば：

- `?U = Vec<?T>`、
- `?U = [?T]`、
- `?T = u32, ?U = [u32]`
- など。

したがって、得られる結果は次のようになります（領域制約と「値」は
無視します）：

- Certainty: `Ambiguous` - これが成り立つかどうかまだわかりません
- Var values: `[?T = ?T, ?U = ?U]` - 変数の値については何も学びませんでした

要するに、クエリ結果は、このトレイトが証明されたかどうかについて
何かを言うのは時期尚早だと言っています。型チェック中、これは
即座のエラーではありません：代わりに、型チェッカーはこの要件
（`Vec<?T>: Borrow<?U>`）を保持して待機します。次の例で見るように、
`?T` と `?U` が他のソースから制約されることがあり、その場合、
トレイトクエリを再試行できます。

**例 2。** 前の例を少し拡張して、`u` に値を割り当てることができます：

```rust,ignore
fn foo<A, B>(a: A, vec_b: Option<B>) where A: Borrow<B> { }

fn main() {
    // 前に見たもの：
    let mut t: Vec<_> = vec![]; // Type: Vec<?T>
    let mut u: Option<_> = None; // Type: Option<?U>
    foo(t, u); // `Vec<?T>: Borrow<?U>` => ambiguous

    // 新しいもの：
    u = Some(vec![]); // ?U = Vec<?V>
}
```

この割り当ての結果、`u` の型は `Option<Vec<?V>>` になることが強制され、
ここで `?V` はベクトルの要素型を表します。これは順番に `?U` が
`Vec<?V>` に[単一化]されることを意味します。

[unified]: ../type-checking.html

型チェッカーが前に見た「まだ証明されていない」トレイト義務
`Vec<?T>: Borrow<?U>` を再検討することを決定したとします。`?U` は
もはや未束縛の推論変数ではありません。今は値 `Vec<?V>` を持っています。
したがって、その値でクエリを「リフレッシュ」すると、次のようになります：

```text
Vec<?T>: Borrow<Vec<?V>>
```

今回は、適用される impl は1つだけです。再帰的な impl です：

```text
impl<T> Borrow<T> for T where T: ?Sized
```

したがって、トレイトチェッカーは次のように答えます：

- Certainty: `Proven`
- Var values: `[?T = ?T, ?V = ?T]`

ここで、義務が実際に成り立つことを証明したこと、そして `?T` と `?V` が
同じ型であることがわかったこと（ただしその型がまだ何であるかは
わかりません！）を示しています。

（実際、関数はここで終了するので、型チェッカーはこの時点で
エラーを出します。なぜなら、`t` と `u` の要素型はまだ
わかっていないからです。同じであることはわかっていますが。）


