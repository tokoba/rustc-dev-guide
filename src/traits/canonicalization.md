# 正準化

> **注意**: FIXME: この章の内容は
> [次世代トレイト解決の正準化章](../solve/canonicalization.html)と
> 重複する部分があります。将来的にこれらの内容を再編成することが推奨されます。

正準化は、推論値をそのコンテキストから**分離**するプロセスです。
これは[正準クエリ][cq]を実装する上で重要な部分であり、
より多くのコンテキストを得るために親章を読むことをお勧めします。

正準化は、実際には非常にシンプルな概念に基づいています：すべての
[推論変数](../type-inference.html#vars)は常に2つの状態の
いずれかにあります：**未束縛**の場合、それがどの型であるかまだ
わからない、または**束縛**の場合、わかっています。したがって、
型/領域を含むデータ構造 T をその環境から分離するには、
T に現れる未束縛変数を見つけて歩いていくだけです。
これらの変数は「正準変数」に置き換えられ、ゼロから始まり、
固定された順序で番号が付けられます（ほとんどの場合左から右ですが、
一貫している限り実際には重要ではありません）。

[cq]: ./canonical-queries.html

したがって、例えば、型 `X = (?T, ?U)` があり、`?T` と `?U` が
異なる未束縛の推論変数である場合、`X` の正準形は `(?0, ?1)` になります。
ここで `?0` と `?1` はこれらの**正準プレースホルダー**を表します。
型 `Y = (?U, ?T)` も `(?0, ?1)` に正準化されることに注意してください。
しかし、型 `Z = (?T, ?T)` は `(?0, ?0)` に正準化されます（`(?U, ?U)` も同様）。
言い換えれば、推論変数の正確な識別は重要ではありません -
それらが繰り返されていない限り。

これを使用して、キャッシングを改善し、トレイト解決中にサイクルや
その他のことを検出します。大まかに言えば、アイデアは、2つのトレイト
クエリが同じ正準形を持つ場合、同じ答えを得るということです。
その答えは正準変数（`?0`、`?1`）の観点で表現され、それを元の
変数（`?T`、`?U`）にマッピングし直すことができます。

## クエリの正準化

どのように機能するかを見るために、次のトレイトクエリを解決しようと
しているとします：`?A: Foo<'static, ?B>`、ここで `?A` と `?B` は未束縛です。
このクエリには2つの未束縛変数が含まれていますが、ライフタイム `'static` も
含まれています。トレイトシステムは一般的にすべてのライフタイムを無視し、
同等に扱うため、正準化するときに、任意の[自由ライフタイム](../appendix/background.html#free-vs-bound)も
正準変数に置き換えます（`'static` は実際にはここでは_自由_ライフタイム
変数であることに注意してください。プログラム全体の型付けコンテキストで
考えているのではなく、このトレイト参照のコンテキストでのみ考えています。
数学的には、プログラム全体に対して量化しているのではなく、
この義務に対してのみ量化しています）。
したがって、次の結果が得られます：

```text
?0: Foo<'?1, ?2>
```

これを次のように別の方法で書くこともあります：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

この `for<>` は、各正準変数に関する情報を提供します。この場合、各 `T` は
型変数を示すため、`?0` と `?2` は型です。`L` はライフタイム変数を示すため、
`?1` はライフタイムです。`canonicalize` メソッドは、各正準化された変数の
「元の値」を持つ `CanonicalVarValues` 配列 OV も返します：

```text
[?A, 'static, ?B]
```

このベクトル OV は後でクエリレスポンスを処理するときに必要になります。

## クエリの実行

正準クエリを構築したら、それを解決しようとすることができます。
そのためには、新しい推論コンテキストを作成し、そのコンテキストで
正準クエリを**インスタンス化**することになります。アイデアは、
各正準変数に対して（適切な種類の）新しい推論変数を含む
正準形からの置換 S を作成することです。
したがって、例のクエリの場合：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

置換 S は次のようになるかもしれません：

```text
S = [?A, '?B, ?C]
```

次に、束縛された正準変数（`?0` など）をこれらの推論変数に置き換えて、
次の完全にインスタンス化されたクエリを得ることができます：

```text
?A: Foo<'?B, ?C>
```

ただし、置換 S を覚えておいてください！後で必要になります。

さて、新しい推論コンテキストとインスタンス化されたクエリができたので、
それを解決しようとすることができます。トレイトソルバー自体は
[別のセクション](../solve/the-solver.md)で詳しく説明されていますが、
[確実性値][cqqr]（`Proven` または `Ambiguous`）を計算し、
作成した推論変数に副作用を与えると言えば十分です。例えば、
次のような `Foo` の impl が1つだけあった場合：

[cqqr]: ./canonical-queries.html#query-response

```rust,ignore
impl<'a, X> Foo<'a, X> for Vec<X>
where X: 'a
{ ... }
```

確実性値 `Proven` になり、また新しい推論変数 `'?D` と `?E`（impl の
パラメータを表すため）を作成し、次のように単一化することになるかもしれません：

- `'?B = '?D`
- `?A = Vec<?E>`
- `?C = ?E`

また、where 句により、領域制約 `?E: '?D` を蓄積します。

最終的なクエリ結果を作成するには、これらの値をクエリの推論コンテキストから
「持ち上げて」、元の推論コンテキストで再適用できるものにする必要があります。
これは、**正準化を再適用**することによって行いますが、**クエリ結果**に対して
行います。

## クエリ結果の正準化

[親セクション][cqqr]で説明したように、ほとんどのトレイトクエリは、
「確実性値」`certainty`、結果置換 `var_values`、および
いくつかの領域制約をまとめた結果になります。これを作成するために、
クエリを最初にインスタンス化したときに作成した置換 S を再利用することになります。
記憶を新たにするために、次のクエリがありました

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

これに対して置換 S を作成しました：

```text
S = [?A, '?B, ?C]
```

次に、それらの変数の一部を他のものと単一化する作業を行いました。
S を最新の結果で「リフレッシュ」すると、次のようになります：

```text
S = [Vec<?E>, '?D, ?E]
```

これらは、元のクエリの3つの入力変数の新しい値です。ただし、
新しい変数（`?E` など）が含まれていることに注意してください。これらを
再び正準化することで消すことができます！ただし、S だけを正準化するのではなく、
クエリレスポンス QR 全体を正準化します：

```text
QR = {
    certainty: Proven,             // または他の何か
    var_values: [Vec<?E>, '?D, ?E] // これは S です
    region_constraints: [?E: '?D], // impl から
    value: (),                     // 我々の目的のために、単に () ですが、
                                   // 場合によっては型や他の情報があるかもしれません
}
```

結果は次のようになります：

```text
Canonical(QR) = for<T, L> {
    certainty: Proven,
    var_values: [Vec<?0>, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
```

（1つの微妙な点：クエリ**結果**を正準化するとき、自由ライフタイムに
特別な扱いは使用しません。例えば、`'?D` への両方の参照が
同じ正準変数（`?1`）に変換されたことに注意してください。これは、
すべての自由ライフタイムを新しい正準変数に正準化した元のクエリとは
対照的です。）

今、この結果は必要な各コンテキストで再適用される必要があります。

## 正準化されたクエリ結果の処理

前のセクションで、正準クエリ結果を生成しました。今、その結果を
元のコンテキストで適用する必要があります。思い出してください、
最初に、このクエリを証明しようとしていました：

```text
?A: Foo<'static, ?B>
```

これを次のように正準化しました：

```text
for<T,L,T> { ?0: Foo<'?1, ?2> }
```

そして、次の正準レスポンスを得ました：

```text
for<T, L> {
    certainty: Proven,
    var_values: [Vec<?0>, '?1, ?0]
    region_constraints: [?0: '?1],
    value: (),
}
```

今、このレスポンスをコンテキストに適用したいと考えています。概念的には、
(a) 結果の各正準変数を新しい推論変数でインスタンス化し、
(b) 結果の値を元の値と単一化し、次に (c) 領域制約を後で記録します。
ステップ (a) を実行すると、次の結果が得られます

```text
{
      certainty: Proven,
      var_values: [Vec<?C>, '?D, ?C]
                       ^^   ^^^ 新しい推論変数
      region_constraints: [?C: '?D],
      value: (),
}
```

ステップ (b) は次のように単一化します：

```text
?A を Vec<?C> と
'static を '?D と
?B を ?C と
```

そして最後に、`?C: 'static` の領域制約が後の検証のために記録されます。

（*実際に*行うことは、それの軽く最適化されたバリアントです：
結果内のすべての正準値を変数で即座にインスタンス化するのではなく、
値のベクトルを歩いて、値が単なる正準変数である場合を探します。
この例では、`values[2]` は `?C` なので、`?C := ?B` および
`'?D := 'static` であると推論できます。これにより、部分的な値のセットが得られます。
値が見つからないものについては、推論変数を作成します。）
