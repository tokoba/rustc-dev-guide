# 高階トレイト境界

トレイト解決におけるより微妙な概念の1つは*高階トレイト境界*です。
そのような境界の例は `for<'a> MyTrait<&'a isize>` です。
高階トレイト参照の選択がどのように機能するかを見ていきましょう。

## 基本的なマッチングとプレースホルダーリーク

トレイト `Foo` があるとします：

```rust
trait Foo<X> {
    fn foo(&self, x: X) { }
}
```

任意の `'a` に対して `Foo<&'a isize>` を実装する型を必要とする関数 `want_hrtb` が
あるとしましょう：

```rust,ignore
fn want_hrtb<T>() where T : for<'a> Foo<&'a isize> { ... }
```

さて、任意の `'a` に対して `Foo<&'a isize>` を実装する構造体 `AnyInt` が
あります：

```rust,ignore
struct AnyInt;
impl<'a> Foo<&'a isize> for AnyInt { }
```

そして、問題は `AnyInt : for<'a> Foo<&'a isize>` か？ということです。答えは
イエスであってほしいです。それを理解するためのアルゴリズムは、
高階型のサブタイピングと密接に関連しています（これは[ここ][hrsubtype]および
[SPJ による論文]で説明されています。高階サブタイピングを理解したい場合は、
論文を読むことをお勧めします）。いくつかの部分があります：

1. 義務内の束縛された領域をプレースホルダーに置き換える。
2. impl を[プレースホルダー]義務と照合する。
3. _プレースホルダーリーク_をチェックする。

[hrsubtype]: ./hrtb.md

では、例を通して作業しましょう。

1. 最初に行うことは、義務内の束縛された領域をプレースホルダーに
置き換えることです。これにより、`AnyInt : Foo<&'0 isize>` が得られます
（ここで `'0` はプレースホルダー領域 #0 を表します）。今、量化子が
なくなったことに注意してください。コンパイラの型の観点では、これは
`ty::PolyTraitRef` から `TraitRef` に変更されます。次に、impl から
`TraitRef` を作成し、その束縛された領域に新しい変数を使用します
（したがって、`Foo<&'$a isize>` が得られます。ここで `'$a` は `'a` の
推論変数です）。

2. 次に、2つのトレイト参照を関連付けて、`'0 == '$a` という制約を
持つグラフを生成します。

3. 最後に、プレースホルダー「リーク」をチェックします - リークは
基本的にプレースホルダー領域を別のプレースホルダー領域、または
impl マッチより前に存在した任意の領域に関連付けようとする試みです。
リークチェックは、プレースホルダー領域から検索して、何らかの方法で
関連している領域のセットを見つけることによって行われます。これは
「汚染」セットと呼ばれます。チェックに合格するには、そのセットは
*のみ*それ自体と impl の領域変数で構成されている必要があります。
汚染セットに他の領域が含まれている場合、マッチは失敗です。この場合、
`'0` の汚染セットは `{'0, '$a}` であり、したがってチェックは成功します。

失敗ケースを考えてみましょう。次のような構造体もあると想像してください

```rust,ignore
struct StaticInt;
impl Foo<&'static isize> for StaticInt;
```

義務 `StaticInt : for<'a> Foo<&'a isize>` が満たされないと見なされることを
望んでいます。チェックは以前と同じように始まります。`'a` はプレースホルダー
`'0` に置き換えられ、impl トレイト参照は `Foo<&'static isize>` に
インスタンス化されます。これら2つを関連付けると、`'static == '0` のような
制約が得られます。これは、`'0` の汚染セットが `{'0, 'static}` であることを
意味し、リークチェックに失敗します。

**TODO**: これは `'static` が領域変数ではなく、汚染セットに含まれているからですよね？

## 高階トレイト義務

基本的なマッチングが完了したら、別の興味深いトピックに入ります：
impl 義務の扱い方です。ここで簡単な例を通して作業します。
トレイト `Foo` と `Bar`、および関連する impl があると想像してください：

```rust
trait Foo<X> {
    fn foo(&self, x: X) { }
}

trait Bar<X> {
    fn bar(&self, x: X) { }
}

impl<X,F> Foo<X> for F
    where F : Bar<X>
{
}
```

さて、義務 `Baz: for<'a> Foo<&'a isize>` があり、この impl と
マッチさせるとしましょう。結果としてどのような義務が生成されますか？
`Baz: for<'a> Bar<&'a isize>` を取得したいのですが、それはどのように
起こるのでしょうか？

マッチング後、`X => &'0 isize` のようなプレースホルダー置換がある状態に
あります。この置換を impl 義務に適用すると、`F : Bar<&'0 isize>` が
得られます。明らかに、プレースホルダー領域 `'0` が計算から漏れ出すことが
できないため、これは直接使用できません。

私たちが行うことは、`'0` の汚染セットから、`'0` が導出された元の
束縛された領域（ここでは `'a`）への逆マッピングを作成することです。
（これは `higher_ranked::plug_leaks` で行われます。）リークチェックに
合格したことがわかっているので、この汚染セットはプレースホルダー領域自体と
さまざまな中間領域変数のみで構成されています。次に、トレイト参照を歩いて、
その汚染セット内のすべての領域を遅延束縛領域に戻します。この場合、
`Baz: for<'a> Bar<&'a isize>` になります。
