# 論理への降下

ここでの重要な観察は、Rust のトレイトシステムは基本的に一種の論理であり、
標準的な論理推論規則にマッピングできるということです。次に、例えば
[Prolog] ソルバーがどのように動作するかと非常に似た方法で、
これらの推論規則の解決策を探すことができます。*完全に* Prolog 規則
（ホーン節とも呼ばれる）を使用することはできませんが、やや表現力の高い
バリアントが必要であることがわかります。

[Prolog]: https://en.wikipedia.org/wiki/Prolog

## Rust トレイトと論理

最初の観察の1つは、Rust のトレイトシステムは基本的に一種の論理である
ということです。そのため、構造体、トレイト、impl 宣言を論理推論規則に
マッピングできます。ほとんどの場合、これらは基本的にホーン節ですが、
Rust の完全な豊かさを捉えるため、特にジェネリックプログラミングをサポート
するためには、標準的なホーン節よりも少し先に進む必要があることがわかります。

このマッピングがどのように機能するかを見るために、例から始めましょう。
次のようにトレイトといくつかの impl を宣言すると想像してください：

```rust
trait Clone { }
impl Clone for usize { }
impl<T> Clone for Vec<T> where T: Clone { }
```

これらの宣言を、Prolog のような表記法で書かれたホーン節にマッピングできます：

```text
Clone(usize).
Clone(Vec<?T>) :- Clone(?T).

// 表記法 `A :- B` は「B が真ならば A が真」を意味します。
// または、別の言い方をすれば、B は A を意味します。
```

Prolog の用語では、`Clone(Foo)` - ここで `Foo` は何らかの Rust 型 - は
型 `Foo` が `Clone` を実装するというアイデアを表す*述語*であると言えます。
これらの規則は**プログラム節**です。これらは、その述語が証明できる
（つまり、真と見なされる）条件を述べています。したがって、最初の規則は
単に「Clone は `usize` に対して実装されている」と言っています。次の規則は
「任意の型 `?T` に対して、Clone が `?T` に対して実装されている場合、
Clone は `Vec<?T>` に対して実装されている」と言っています。したがって、
例えば `Clone(Vec<Vec<usize>>)` を証明したい場合、規則を再帰的に適用することで
行います：

- `Clone(Vec<Vec<usize>>)` は次の場合に証明可能：
  - `Clone(Vec<usize>)` は次の場合に証明可能：
    - `Clone(usize)` は証明可能。（そして、それは証明可能なので、すべて問題ありません。）

しかし、今度は `Clone(Vec<Bar>)` を証明しようとすると、これは失敗します
（結局、`Bar` に対する `Clone` の impl を与えていません）：

- `Clone(Vec<Bar>)` は次の場合に証明可能：
  - `Clone(Bar)` は証明可能。（しかし、適用可能な規則がないため、証明できません。）

複数の入力型を持つジェネリックトレイトをカバーするように上記の例を簡単に
拡張できます。したがって、`Self` が型 `T` の値と等しいと宣言する `Eq<T>`
トレイトを想像してください：

```rust,ignore
trait Eq<T> { ... }
impl Eq<usize> for usize { }
impl<T: Eq<U>> Eq<Vec<U>> for Vec<T> { }
```

これは次のようにマッピングできます：

```text
Eq(usize, usize).
Eq(Vec<?T>, Vec<?U>) :- Eq(?T, ?U).
```

これまでのところ順調です。

## 通常の関数の型チェック

さて、トレイトが実装されているときを表現でき、関連型を処理できる論理規則を
定義したので、**型チェック**に少し焦点を移しましょう。型チェックが
興味深いのは、証明する必要があるゴールを提供してくれるからです。つまり、
これまで見てきたことはすべて、プログラム内のトレイトと impl からゴールを
証明できる規則を導出する方法についてでした。しかし、証明する必要がある
ゴールを導出する方法にも興味があり、それらは型チェックから来ます。

ここで関数 `foo()` の型チェックを考えてみましょう：

```rust,ignore
fn foo() { bar::<usize>() }
fn bar<U: Eq<U>>() { }
```

この関数は非常にシンプルです：やっていることは `bar::<usize>()` を
呼び出すことだけです。さて、`bar()` の定義を見ると、where 句 `U: Eq<U>` が
1つあることがわかります。したがって、`foo()` は `bar()` を型引数 `usize` で
呼び出せることを示すために、`usize: Eq<usize>` を証明する必要があることを
意味します。

必要に応じて、`bar()` を呼び出せる条件を定義する Prolog 述語を書くことが
できます。それらの条件を「整形式」と呼びます：

```text
barWellFormed(?U) :- Eq(?U, ?U).
```

次に、`bar::<usize>` への参照（つまり、型 `usize` に適用された `bar()`）が
整形式である場合、`foo()` は型チェックに成功すると言えます：

```text
fooTypeChecks :- barWellFormed(usize).
```

ゴール `fooTypeChecks` を証明しようとすると、成功します：

- `fooTypeChecks` は次の場合に証明可能：
  - `barWellFormed(usize)` は次の場合に証明可能：
    - `Eq(usize, usize)` は impl があるため証明可能。

さて、これまでのところ順調です。より複雑な関数の型チェックに移りましょう。

## ジェネリック関数の型チェック：ホーン節を超えて

前のセクションでは、標準的な Prolog ホーン節（Rust の型等価性の概念で
補強された）を使用して、いくつかのシンプルな Rust 関数を型チェックしました。
しかし、それは非ジェネリック関数を型チェックするときにのみ機能します。
ジェネリック関数を型チェックしたい場合、Prolog が提供できるものよりも
強力なゴールの概念が必要であることがわかります。何を言っているのかを見るために、
前の例を変更して `foo` をジェネリックにしましょう：

```rust,ignore
fn foo<T: Eq<T>>() { bar::<T>() }
fn bar<U: Eq<U>>() { }
```

`foo` の本体を型チェックするには、型 `T` を「抽象的」に保持できる必要が
あります。つまり、`foo` の本体が*すべての型 `T`*に対して型安全であることを
チェックする必要があります。特定の型だけではありません。次のように表現できます：

```text
fooTypeChecks :-
  // すべての型 T に対して...
  forall<T> {
    // ...Eq(T, T) が証明可能であると仮定すれば...
    if (Eq(T, T)) {
      // ...次に `barWellFormed(T)` が成り立つことを証明できる。
      barWellFormed(T)
    }
  }.
```

ここで使用している表記法は、プロトタイプ実装で使用してきた表記法です。
標準的な数学表記に似ていますが、少し Rust 化されています。とにかく、
問題は、標準的なホーン節がゴールでの全称量化（`forall`）や含意（`if`）を
許可しないことです（ただし、多くの Prolog エンジンは拡張としてそれらを
サポートしています）。このため、「一階遺伝的ハロップ」(FOHH) 節と呼ばれる
ものを受け入れる必要があります - この長い名前は基本的に「本体に `forall` と
`if` を持つ標準的なホーン節」を意味します。しかし、適切な名前を知っておくと
良いです。なぜなら、FOHH 節を効率的に処理する方法を説明する多くの研究が
あるからです。例えば、Gopalan Nadathur の優れた
["A Proof Procedure for the Logic of Hereditary Harrop Formulas"][pphhf]
を[Chalk Book の参考文献][bibliography]で参照してください。

[bibliography]: https://rust-lang.github.io/chalk/book/bibliography.html
[pphhf]: https://rust-lang.github.io/chalk/book/bibliography.html#pphhf

FOHH をサポートすることは、実際にはそれほど難しくありません。そして、
それができるようになれば、`foo` のようなジェネリック関数の型チェック規則を
論理で簡単に記述できます。

## ソース

このページは Nicholas Matsakis による[ブログ投稿][lrtl]を軽く修正したものです。

[lrtl]: http://smallcultfollowing.com/babysteps/blog/2017/01/26/lowering-rust-traits-to-logic/
