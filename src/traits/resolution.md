# トレイト解決（旧スタイル）

この章では、_トレイト解決_の一般的なプロセスについて説明し、
いくつかの自明ではないことを指摘します。

**注意：** この章（およびそのサブチャプター）は、トレイトソルバーが
**現在**どのように機能しているかを説明しています。しかし、新しい
トレイトソルバーを設計するプロセスの途中にあります。*それ*について
読みたい場合は、[*この*サブチャプター](./chalk.html)を参照してください。

## 主要な概念

トレイト解決は、トレイトへの各参照と impl をペアにするプロセスです。
したがって、例えば、次のようなジェネリック関数がある場合：

```rust,ignore
fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> { ... }
```

そして、その関数への呼び出しがある場合：

```rust,ignore
let v: Vec<isize> = clone_slice(&[1, 2, 3])
```

（この場合）`isize : Clone` の impl が存在するかどうかを理解するのが
トレイト解決の仕事です。

場合によっては、ジェネリック関数のように、特定の impl を見つけることが
できない場合もありますが、呼び出し元が impl を提供する必要があることを
理解できます。例えば、`clone_slice` の本体を考えてみましょう：

```rust,ignore
fn clone_slice<T:Clone>(x: &[T]) -> Vec<T> {
    let mut v = Vec::new();
    for e in &x {
        v.push((*e).clone()); // (*)
    }
}
```

マークされた行 `(*)` は、`T`（`*e` の型）が `Clone` トレイトを
実装している場合にのみ合法です。当然、`T` が何であるかわからないため、
特定の impl を見つけることはできません。しかし、境界 `T:Clone` に
基づいて、呼び出し元が提供する必要がある impl が存在すると言えます。

impl を必要とするトレイト参照を指すために、*義務*という用語を使用します。
基本的に、トレイト解決システムは、適切な impl が実際に存在することを
証明することによって義務を解決します。

型チェック中、トレイト選択の結果を保存しません。トレイト選択が成功する
ことを検証したいだけです。その後、コード生成時に、すべての具体的な型が
利用可能になったら、トレイト選択を繰り返して実際の実装を選択し、
出力バイナリに生成できます。

## 概要

トレイト解決は3つの主要な部分で構成されています：

- **選択**：特定の義務をどのように解決するかを決定します。例えば、
  選択は、特定の義務が `Self` 型に一致する impl を使用するか、
  パラメータ境界（例：`T: Trait`）を使用することによって解決できると
  決定するかもしれません。impl の場合、1つの義務を選択すると、
  impl 自体の where 句のために*ネストされた義務*が作成される可能性が
  あります。また、曖昧さを解決するために、それらのネストされた義務を
  評価する必要がある場合もあります。

- **履行**：履行コードは、義務が完全に履行されることを追跡するものです。
  基本的には、選択する義務のワークリストです：選択が成功すると、
  義務はワークリストから削除され、ネストされた義務がエンキューされます。
  履行は推論変数を制約します。

- **評価**：推論変数を制約せずに義務が成り立つかどうかをチェックします。
  選択によって使用されます。

## 選択

選択は、義務を解決できるかどうか、そしてもしそうなら、どのように解決するか
（impl、where 句などを介して）を決定するプロセスです。主なインターフェースは
`select()` 関数で、義務を受け取り、`SelectionResult` を返します。
3つの可能な結果があります：

- `Ok(Some(selection))` - はい、義務は解決でき、`selection` はその方法を
  示します。impl を介して解決された場合、`selection` は impl によって
  必要とされるネストされた義務も示す可能性があります。

- `Ok(None)` - 義務が解決できるかどうかまだわかりません。これは、
  義務に未束縛の型変数が含まれている場合に最もよく起こります。

- `Err(err)` - 型エラーのため、または適用される可能性のある impl が
  ないため、義務は確実に解決できません。

選択の基本的なアルゴリズムは、候補アセンブリと確認の2つの大きな
フェーズに分かれています。

ライフタイム推論がどのように機能するかのため、ライフタイム間の
単一化またはサブタイプ関係が成り立つかどうかについて即座のフィードバックを
返すことは不可能であることに注意してください。したがって、ライフタイム
マッチングは選択中に*考慮されません*。これは、サブ領域割り当てが
失敗しないという事実に反映されています。これにより、後でエラーが
見つかるライフタイム制約が生成される可能性があります（対照的に、
非ライフタイム制約は選択中にすでにチェックされており、エラーを
引き起こすことはありませんが、当然、他のエラーを下流で引き起こす
可能性があります）。

### 候補アセンブリ

**TODO**：なぜ異なる候補があるのか、そしてなぜそれがプローブで行われる必要が
あるのかについて話します。

義務を満たすために使用される可能性のある impl/where 句/などを検索します。
これらのそれぞれは候補と呼ばれます。曖昧さを避けるために、確実に適用可能な
正確に1つの候補を見つけたいと考えています。場合によっては、impl/where 句が
適用されるかどうかわからないことがあります - これは、義務に未束縛の推論変数が
含まれている場合に発生します。

特定の impl/where 句/などが特定の義務に適用されるかどうかを決定する
サブルーチンは、まとめて_マッチング_のプロセスと呼ばれます。`impl` 候補の場合
<!-- date-check: Oct 2022 -->、これはネストされた義務を無視しながら
impl ヘッダー（`Self` 型とトレイト引数）を単一化することになります。
マッチングが成功した場合、候補のセットに追加します。`Copy`、`Sized`、
`CoerceUnsized` などの組み込みトレイトの候補をアセンブルする際には、
他の規則があります。

この最初のパスが完了したら、候補のセットを調べることができます。
シングルトンセットである場合、完了です：これが適用される可能性のある
スコープ内の唯一の impl です。それ以外の場合は、where 句や他の条件を
使用して候補のセットを**絞り込む**ことができます。絞り込みは
`evaluate_candidate` を使用して、ネストされた義務が適用される可能性が
あるかどうかをチェックします。それでも1つ以上の候補が残っている場合、
`fn candidate_should_be_dropped_in_favor_of` を使用して、いくつかの
候補を他の候補よりも優先します。

この縮小されたセットが単一の明確なエントリを生成する場合、問題ありません。
そうでなければ、結果は曖昧と見なされます。

#### 絞り込み：曖昧さの解決

しかし、すべての型が単一化する複数の impl がある場合はどうなるでしょうか？
この例を考えてみましょう：

```rust,ignore
trait Get {
    fn get(&self) -> Self;
}

impl<T: Copy> Get for T {
    fn get(&self) -> T {
        *self
    }
}

impl<T: Get> Get for Box<T> {
    fn get(&self) -> Box<T> {
        Box::new(<T>::get(self))
    }
}
```

例えば、`get(&Box::new(1_u16))` を呼び出すとどうなりますか？この場合、
`Self` 型は `Box<u16>` です - これは両方の impl と単一化します。
なぜなら、最初はすべての型 `T` に適用され、2番目はすべての `Box<T>` に
適用されるからです。これが曖昧でないためには、コンパイラは `where` 句を
考慮し、候補を削除しようとする*絞り込み*パスを行います。この場合、
最初の impl は `Box<u16> : Copy` が成り立つ場合にのみ適用されますが、
これは成り立ちません。絞り込み後、1つの候補だけが残るため、
続行できます。

#### `where` 句

impl の他に、義務を解決する主な方法は where 句を介することです。
選択プロセスには常に[パラメータ環境]が与えられ、これには where 句の
リストが含まれています。これらは基本的に満たされると仮定できる義務です。
そのリストを反復処理し、現在の義務がそのリストに見つかるかどうかを
チェックします。見つかった場合、満たされていると見なされます。より
正確には、同じトレイト（または何らかのサブトレイト）に対する where 句義務が
あり、義務と一致できるかどうかをチェックしたいと考えています。


この簡単な例を考えてみましょう：

```rust,ignore
trait A1 {
    fn do_a1(&self);
}
trait A2 : A1 { ... }

trait B {
    fn do_b(&self);
}

fn foo<X:A2+B>(x: X) {
    x.do_a1(); // (*)
    x.do_b();  // (#)
}
```

`foo` の本体では、明らかに変数 `x` で `A1`、`A2`、または `B` の
メソッドを使用できます。マークされた行 `(*)` は義務 `X: A1` を
発生させ、マークされた行 `(#)` は義務 `X: B` を発生させます。一方、
パラメータ環境には2つの where 句が含まれます：`X : A2` と `X : B`。
各義務について、この where 句のリストを検索します。義務 `X: B` は
where 句 `X: B` と自明に一致します。義務 `X:A1` を解決するには、
`X:A2` が `X:A1` を意味することに注意します。

### 確認

_確認_は、トレイトの出力型パラメータを義務で見つかった値と単一化し、
場合によっては型エラーを生成します。

前のセクションの `Convert` 例の次のバリエーションがあるとします：

```rust,ignore
trait Convert<Target> {
    fn convert(&self) -> Target;
}

impl Convert<usize> for isize { ... } // isize -> usize
impl Convert<isize> for usize { ... } // usize -> isize

let x: isize = ...;
let y: char = x.convert(); // 注意：今は `y: char` です！
```

確認は、impl が `Target` が `usize` になると指定したが、義務が `char` を
報告したため、エラーが報告される場所です。したがって、選択の結果は
エラーになります。

候補 impl は `Self` 型に基づいて選択されますが、確認は（この場合）
`Target` 型パラメータに基づいて行われることに注意してください。

### コード生成時の選択

上述のように、型チェック中、トレイト選択の結果を保存しません。コード生成時に、
各メソッド呼び出しに対して特定の impl を選択するためにトレイト選択を繰り返します。
これは `fn codegen_select_candidate` を使用して行われます。この2番目の選択では、
各解決が特定の impl に解決されることがわかっているため、スコープ内にある
where 句は考慮しません。

興味深いひねりの1つは、ネストされた義務に関係しています。一般的に、コード生成では、
どの候補が適用されるかを理解する必要があるだけで、ネストされた義務については
気にしません。これらはすでに真であると仮定されているためです。それにもかかわらず、
現在、それらすべてを*実際に*履行しています。それは、時々型推論の結果を
知らせることができるからです。つまり、impl の型変数に関する完全な置換が
利用できないため、すべてを理解するためにトレイト選択を実行する必要があります。
