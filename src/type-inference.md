# 型推論

型推論は、式の型を自動的に検出するプロセスです。

これにより、Rustは型注釈をほとんど、またはまったく必要とせずに動作し、ユーザーにとって物事が簡単になります：

```rust
fn main() {
    let mut things = vec![];
    things.push("thing");
}
```

ここで、`things`の型は、`things`にプッシュする値のために`Vec<&str>`であると*推論*されます。

型推論は、標準のHindley-Milner（HM）型推論アルゴリズムに基づいていますが、サブタイピング、リージョン推論、および高ランク型に対応するためにさまざまな方法で拡張されています。

## 用語に関する注記

推論変数を参照するために`?T`という表記法を使用します。これは存在変数とも呼ばれます。

「リージョン」と「ライフタイム」という用語は同じ意味で使用します。どちらも`&'a T`の`'a`を指します。

「束縛リージョン」という用語は、`for<'a> fn(&'a u32)`の`'a`のように、関数シグネチャで束縛されたリージョンを指します。リージョンが束縛されていない場合、そのリージョンは「自由」です。

## 推論コンテキストの作成

次のようなことを行うことで、推論コンテキストを作成します：

```rust,ignore
let infcx = tcx.infer_ctxt().build();
// ここで推論コンテキスト`infcx`を使用します。
```

`infcx`には、`InferCtxt<'tcx>`という型があり、ビルド元の`tcx`と同じ`'tcx`ライフタイムです。

`tcx.infer_ctxt`メソッドは実際にはビルダーを返します。つまり、`infcx`が作成される前に実行できる構成がいくつかあります。詳細については、`InferCtxtBuilder`を参照してください。

<a id="vars"></a>

## 推論変数

推論コンテキストの主な目的は、多数の**推論変数**を保持することです。これらは、正確な値がまだわかっていないが、型チェックを実行する際に明らかになる型またはリージョンを表します。

H-M型システムまたはPrologのような論理言語からの統合の基本的なアイデアに精通している場合、これは同じ概念です。精通していない場合は、H-M型推論の動作に関するチュートリアルを読むか、おそらく[Chalkプロジェクトでの統合][Unification in the Chalk project]に関するこのブログ記事を読むことをお勧めします。

[Unification in the Chalk project]: http://smallcultfollowing.com/babysteps/blog/2017/03/25/unification-in-chalk-part-1/

全体として、推論コンテキストは5種類の推論変数を保存します（<!-- date-check --> 2023年3月現在）：

- 型変数、3つのバリエーションがあります：
  - 一般的な型変数（最も一般的）。これらは任意の型で統合できます。
  - 整数型変数。整数型とのみ統合でき、`22`のような整数リテラル式から発生します。
  - 浮動小数点型変数。浮動小数点型とのみ統合でき、`22.0`のような浮動小数点リテラル式から発生します。
- リージョン変数。ライフタイムを表し、いたるところで発生します。
- Const変数。定数を表します。

すべての型変数は同じように動作します：新しい型変数を作成でき、得られるものは未解決の型`?T`を表す`Ty<'tcx>`です。後で、推論器がサポートするさまざまな操作（等価性やサブタイピングなど）を適用でき、その結果として`?T`を特定の値に**インスタンス化**（または**バインド**）する可能性があります。

リージョン変数は多少異なる方法で動作し、以下の別のセクションで説明されています。

## 等価性/サブタイピングの強制

型推論器で実行できる最も基本的な操作は**等価性**です。これにより、2つの型`T`と`U`が同じであることが強制されます。等価性制約を追加する推奨される方法は、`at`メソッドを使用することです。次のようになります：

```rust,ignore
infcx.at(...).eq(t, u);
```

最初の`at()`呼び出しは少しのコンテキストを提供します。つまり、この統合を行っている理由と、どのような環境で行っているかです。`eq`メソッドは実際の等価性制約を実行します。

物事を等価にすると、それらが正確に等しくなることが強制されます。等価化は`InferResult`を返します。`Err(err)`を返す場合、等価化は失敗し、囲まれた`TypeError`は何が問題だったかを教えてくれます。

成功のケースはおそらくもっと興味深いです。`eq`の「プライマリ」戻り値の型は`()`です。つまり、成功したときに特に興味深い値を返しません。むしろ、型変数の制約などの副作用のために実行されます。ただし、実際の戻り値の型は`()`ではなく、`InferOk<()>`です。`InferOk`型は、追加のトレイト義務を運ぶために使用されます。これらを満たすことはあなたの仕事です（通常は充足コンテキストに登録することによって）。詳細については、[トレイトの章][trait chapter]を参照してください。

[trait chapter]: traits/resolution.html

`infcx.at(..).sub(..)`を介してサブタイピングも同様に強制できます。同じ基本的な概念が適用されます。

## 等価性を「試す」

エラーなしで2つの型を等価にすることが*可能*かどうかを知りたい場合があります。`infcx.can_eq`（またはサブタイピングの場合は`infcx.can_sub`）でそれをテストできます。これが`Ok`を返す場合、等価性は可能です。ただし、すべての場合において、副作用は元に戻されます。

ただし、これらのメソッドの成功または失敗は常に**リージョンをモジュロ**していることに注意してください。つまり、2つの型`&'a u32`と`&'b u32`は、`'a != 'b`であっても、`can_eq`に対して`Ok`を返します。これは、リージョン制約を解決する方法の「2フェーズ」性質から生じます。

## スナップショット

前のセクションの`can_eq`で説明したように、一連の操作を実行してから、その副作用をロールバックできると便利なことがよくあります。これはさまざまな理由で行われます：その1つは、複数の可能性を試してから決定する前にバックトラックできるようにすることです。もう1つは、一連の小さな変更が原子的に行われるか、まったく行われないようにすることです。

これを可能にするために、推論コンテキストは`snapshot`メソッドをサポートしています。これを呼び出すと、実行する操作から発生する変更の記録が開始されます。完了したら、`rollback_to`を呼び出してこれらの変更を元に戻すか、`confirm`を呼び出して永続的にすることができます。スナップショットは、スタックのような規律に従う限り、ネストできます。

スナップショットを直接使用するのではなく、`commit_if_ok`や`probe`などの高レベルパターンをカプセル化するメソッドを使用すると便利なことがよくあります。

## サブタイピング義務

議論する価値がある1つのことは、サブタイピング義務です。2つの型がサブタイプであることを強制すると、`?T <: i32`のように、それらを等価性制約に変換できることがよくあります。これはRustの非常に限定的なサブタイピングの概念から生じます：したがって、上記の場合、`?T <: i32`は`?T = i32`と同等です。

ただし、場合によってはもっと注意する必要があります。たとえば、リージョンが関与する場合です。したがって、`?T <: &'a i32`がある場合、最初に行うことは、リージョン変数で`&'a i32`を「一般化」することです：`&'?b i32`、次に`?T`とそれを統合します（`?T = &'?b i32`）。次に、この新しい変数を元の境界に関連付けます：

```text
&'?b i32 <: &'a i32
```

これにより、リージョン制約（以下を参照）`'?b: 'a`が生成されます。

最後に興味深いケースの1つは、`?T <: ?U`のような2つの非束縛型変数を関連付けることです。その場合、進捗できないので、義務`Subtype(?T, ?U)`をエンキューして`InferOk`メカニズムを介して返します。`?T`または`?U`の詳細がわかったら、再度試す必要があります。

## リージョン制約

リージョンは型とは多少異なる方法で推論されます。物事を熱心に統合するのではなく、進行しながら制約を収集しますが、リージョンを解決する試みは（ほとんど）しません。これらの制約には、「外存」制約の形式があります：

```text
'a: 'b
```

実際、コードはそれらをサブリージョン関係として見る傾向がありますが、同じアイデアです：

```text
'b <= 'a
```

（他にも「verifys」などのさまざまな種類の制約があります。詳細については、[`region_constraints`]モジュールを参照してください。）

2つのリージョン間に等価性制約がある場合、熱心な統合を多少行う場合があります

```text
'a = 'b
```

統合テーブルにその事実を記録します。次に、[`opportunistic_resolve_var`]を使用して、`'b`を`'a`に変換できます（またはその逆）。これは、固定点アルゴリズムの終了を保証するために必要な場合があります。

[`region_constraints`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/region_constraints/index.html
[`opportunistic_resolve_var`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/region_constraints/struct.RegionConstraintCollector.html#method.opportunistic_resolve_var

## リージョン制約の解決

リージョン制約は、他のすべての制約が既知で、他のすべての義務が証明された後、型チェックの最後にのみ解決されます。リージョン制約を解決する方法は現在2つあります：字句的および非字句的です。最終的には1つだけになります。

ここでの例外は、トレイト解決中に使用され、高ランクリージョンを含むリージョン制約に依存するリークチェックです。ルート宇宙のリージョン制約（つまり、`for<'a>`から生じないもの）は、これらのリージョンがすべてコードジェン中に消去されるため、トレイトシステムに影響を与えてはなりません。

**字句的**リージョン制約を解決するには、[`resolve_regions_and_report_errors`]を呼び出します。これによりリージョン制約プロセスが「閉じ」、[`lexical_region_resolve`]コードが呼び出されます。これが完了すると、等価性を作成したり、サブタイピング関係を作成したりする試みはICEをもたらします。

NLLソルバー（実際にはMIR型チェッカー）は少し異なることを行います。トレイト解決には、最後に[`take_and_reset_region_constraints`]を使用する正規クエリを使用します。これにより、正規クエリ中に追加されたすべての外存制約が抽出されます。これは、NLLソルバーが*どの*リージョンが他のリージョンより長生きするかだけでなく、*どこで*も知る必要があるため必要です。最後に、NLLソルバーは[`get_region_var_infos`]を呼び出し、すべてのリージョン変数をソルバーに提供します。

[`resolve_regions_and_report_errors`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_trait_selection/traits/struct.ObligationCtxt.html#method.resolve_regions_and_report_errors
[`lexical_region_resolve`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/lexical_region_resolve/index.html
[`take_and_reset_region_constraints`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxt.html#method.take_and_reset_region_constraints
[`get_region_var_infos`]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc_infer/infer/struct.InferCtxt.html#method.get_region_var_infos

## 字句的リージョン解決

字句的リージョン解決は、最初に各リージョン変数に空の値を割り当てることによって行われます。次に、各外存制約を繰り返し処理し、固定点に達するまでリージョン変数を拡大します。リージョン変数は、リージョン格子上の最小上界関係を使用してかなり直接的な方法で拡大できます。
