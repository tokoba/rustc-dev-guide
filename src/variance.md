# 型とライフタイムパラメータの分散

より一般的な分散の背景については、[背景][background]付録を参照してください。

[background]: ./appendix/background.html

型チェック中に、型とライフタイムパラメータの分散を推論する必要があります。アルゴリズムは、PLDI'11で発表されたAltidorらによる論文["Taming the Wildcards: Combining Definition- and Use-Site Variance"][pldi11]のセクション4から取られており、以降「論文」と呼びます。

[pldi11]: https://people.cs.umass.edu/~yannis/variance-extended2011.pdf

この推論は、コード内で型を使用することを考慮*しない*ように明示的に設計されています。型`X`で定義された型パラメータの分散を決定するには、型`X`の定義とそれが参照する型の定義のみを考慮します。

*データ型*（構造体やenumなど）で見つかった型パラメータの分散のみを推論します。これらの場合、分散が何を意味するかについてかなり簡単な説明があります。型またはライフタイムパラメータの分散は、`T<A>`が`T<B>`のサブタイプであるか（それぞれ`T<'a>`と`T<'b>`）を、`A`と`B`の関係（それぞれ`'a`と`'b`）に基づいて定義します。

トレイト、関数、またはimplで見つかった型パラメータの分散は推論しません。トレイトパラメータの分散は確かに意味があります（そして以前は計算していました）が、実際には意味がかなり微妙で、実際にはそれほど有用ではないため、削除しました。詳細については、[補遺][addendum]を参照してください。一方、関数/implパラメータの分散は意味がありません。なぜなら、これらのパラメータはインスタンス化されてから忘れられ、型やコンパイルされた副産物に永続化されないからです。

[addendum]: #addendum

> **表記法**
>
> この章全体で論文の表記法を使用します：
>
> - `+`は_共変_です。
> - `-`は_反変_です。
> - `*`は_双変_です。
> - `o`は_不変_です。

## アルゴリズム

基本的なアイデアは非常に簡単です。定義された型を反復し、型パラメータ`X`の使用ごとに、その使用サイトの分散が`X`の分散に対して有効である必要があることを示す制約を蓄積します。次に、すべての制約が満たされるまで、`X`の分散を繰り返し洗練します。*常に*解決策があります。なぜなら、限界として、すべての型パラメータを不変と宣言でき、すべての制約が満たされるからです。

簡単な例として、次を考えてみましょう：

```rust,ignore
enum Option<A> { Some(A), None }
enum OptionalFn<B> { Some(|B|), None }
enum OptionalMap<C> { Some(|C| -> C), None }
```

ここで、次の制約を生成します：

```text
1. V(A) <= +
2. V(B) <= -
3. V(C) <= +
4. V(C) <= -
```

これらは、（1）Aの分散は最大でも共変である必要があること、（2）Bの分散は最大でも反変である必要があること、（3、4）Cの分散は最大でも共変*かつ*反変である必要があることを示しています。これらのすべての結果は、次のように定義された分散格子に基づいています：

```text
   *      頂点（双変）
-     +
   o      底（不変）
```

この格子に基づいて、解`V(A)=+`、`V(B)=-`、`V(C)=o`が最適解です。すべての変数を不変と宣言する素朴な解決策が常にあることに注意してください。

固定点反復が必要な理由を不思議に思うかもしれません。理由は、使用サイトの分散自体が他の型パラメータの分散の関数である可能性があるためです。完全な一般性では、制約は次の形式を取ります：

```text
V(X) <= Term
Term := + | - | * | o | V(X) | Term x Term
```

ここで、表記`V(X)`は、その定義クラスに対する型/リージョンパラメータ`X`の分散を示します。`Term x Term`は、論文で定義されている「分散変換」を表します：

> 型変数`X`の型式`E`での分散が`V2`であり、クラス`C`の対応する型パラメータの定義サイト分散が`V1`である場合、型式`C<E>`での`X`の分散は`V3 = V1.xform(V2)`です。

## 制約

where句を持つ構造体やenumがある場合：

```rust,ignore
struct Foo<T: Bar> { ... }
```

`Bar`に対する`T`の分散が`Foo`に対する`T`の分散に影響するかどうか疑問に思うかもしれません。そうではないと主張します。理由：`T`が`Bar`に対して不変であるが`Foo`に対して共変であると仮定しましょう。次に、`Foo<X>`があり、`Foo<Y>`にアップキャストされ、`X <: Y`です。ただし、`X : Bar`である一方、`Y : Bar`は成立しません。その場合、アップキャストは違法になりますが、分散の失敗のためではなく、むしろターゲット型`Foo<Y>`自体が整形式でないためです。基本的に、分散を考慮する前に、関与するすべての型の整形式性を仮定できます。

### 依存関係グラフ管理

分散はクレート全体の推論であるため、注意しないと依存関係グラフがかなり混乱する可能性があります。これを解決するために、2つのクエリにリファクタリングします：

- `crate_variances`は、現在のクレート内のすべてのアイテムの分散を計算します。
- `variances_of`は、個々の読み取りの分散にアクセスします。`crate_variances`をリクエストし、関連するデータを抽出することによって機能します。

`variances_of`の読み取りに制限すると、コードはその特定のアイテムの推論にのみ依存します。

最終的に、このセットアップは[red-greenアルゴリズム][rga]に依存しています。特に、すべての分散クエリは、クレート全体のすべての型定義に実質的に依存しますが（`crate_variances`を介して）、ほとんどの変更は分散推論からの実際の結果の変更にはつながらないため、`variances_of`クエリは再評価後に緑と見なされます。

[rga]: ./queries/incremental-compilation.html

<a id="addendum"></a>

## 補遺：トレイトの分散

上記で述べたように、以前はトレイトの分散を許可していました。これは、トレイトメソッドシグネチャでのトレイト型パラメータの出現に基づいて計算され、トレイトオブジェクトのvtablesの互換性（およびトレイト境界の「仮想」vtablesまたは辞書）を表すために使用されていました。1つの複雑さは、関連型の分散がそれほど明白ではないことです。なぜなら、それらは投影され、さまざまな用途に使用される可能性があるため、`X<A>::Bar`を変化させることが安全である場合が明確ではないからです（実際、それが何を意味するのかさえ）。さらに（以下でカバーされているように）、関連型を持つすべてのトレイトへのすべての入力は不変でなければならず、適用性を制限していました。最後に、すべてのトレイト型パラメータに分散があることを保証するために必要な注釈（`MarkerTrait`、`PhantomFn`）は、わずかな利益のために混乱し、迷惑でした。

歴史的参考のために、分散とトレイトマッチングをどのように解釈できるかを示すテキストを保存します。

### 分散とオブジェクト型

構造体やenumと同様に、2つのオブジェクト型`&Trait<A>`と`&Trait<B>`間のサブタイピング関係を、`A`と`B`の関係に基づいて決定できます。オブジェクト型の場合、`Self`型パラメータを無視することに注意してください。それは未知であり、動的ディスパッチの性質により、適切な`Self`型を期待する関数を常に呼び出すことが保証されます。ただし、他の型パラメータには注意する必要があります。さもないと、ある型を期待しているが別の型が提供された関数を呼び出す可能性があります。

私が言っていることを理解するために、次のようなトレイトを考えてみましょう：

```rust
trait ConvertTo<A> {
    fn convertTo(&self) -> A;
}
```

直感的に、`O=&ConvertTo<Object>`というオブジェクトと`S=&ConvertTo<String>`という別のオブジェクトがある場合、`String <: Object`であるため、`S <: O`です（Javaのような「string」と「object」型を想定しています。これは私のサブタイピングの例としてよく使っています）。実際のアルゴリズムは、（明示的な）型パラメータを分散を尊重してペアワイズで比較することです：ここで、型パラメータAは共変です（戻り位置にのみ現れるため）、したがって`String <: Object`が必要です。

（暗黙的な）`Self`型パラメータのバインディングを考慮しなかったことに気づくでしょう：実際、それは未知なので、それは良いことです。呼び出しが発生するまでその値を知る必要がない理由は、正確には、仮想ディスパッチの動的な性質により、実行するコードが`Self`が何にバインドされていても、呼び出されたオブジェクトの特定の方法に対して正しいからです。したがって、`Self`は`A`とは異なります。なぜなら、呼び出し側は`convertTo()`メソッドの戻り値の型を知るために`A`が既知である必要があるからです。（ついでに、`Self`が受信者の位置の外に現れるメソッドをオブジェクトを介して呼び出すことを防ぐルールがあります。）

### トレイト分散とvtable解決

しかし、トレイトはオブジェクトとだけ使用されるわけではありません。特定のimplが特定のトレイト境界を満たすかどうかを決定するときにも使用されます。ここでシーンを設定するために、関数があると想像してください：

```rust,ignore
fn convertAll<A,T:ConvertTo<A>>(v: &[T]) { ... }
```

次に、`Object`に対する`ConvertTo`の実装があると想像してください：

```rust,ignore
impl ConvertTo<i32> for Object { ... }
```

そして、何らかの理由で、型パラメータ`T`に`String`の値を具体的に提供して、文字列の配列で`convertAll`を呼び出したいとします：

```rust,ignore
let mut vector = vec!["string", ...];
convertAll::<i32, String>(vector);
```

これは合法ですか？言い換えれば、`Object`用の`impl`を型`String`に適用できますか？答えはイエスですが、その理由を見るには、何が起こるかを展開する必要があります：

- `convertAll`はベクトル内のエントリの1つへのポインタを作成します。これは型`&String`を持ちます
- 次に、Objectsと一緒に使用することを意図した`convertTo()`のimplを呼び出します。これは型`fn(self: &Object) -> i32`を持ちます。

  `self`に型`&String`の値を提供することは問題ありません。なぜなら、`&String <: &Object`だからです。

わかりました、直感的には、これが合法であることを望んでいるので、これを分散に戻して、正しい結果を計算しているかどうかを見てみましょう。質問「`String,i32`に対するimplが期待される場所で、`Object,i32`に対するimplが使用可能か？」をどのように表現するかをまず理解する必要があります。

型クラスの辞書渡し実装を考えると役立つかもしれません。その場合、`convertAll()`は、implを表す暗黙的なパラメータを取ります。要するに、次の型のimplを*持っています*：

```text
V_O = ConvertTo<i32> for Object
```

そして、関数プロトタイプは次の型のimplを期待します：

```text
V_S = ConvertTo<i32> for String
```

任意の引数と同様に、与えられた値の型（`V_O`）が期待される型（`V_S`）のサブタイプである場合、これは合法です。したがって、`V_O <: V_S`ですか？答えはさまざまなパラメータの分散に依存します。この場合、`Self`パラメータは反変で、`A`は共変であるため、次のことを意味します：

```text
V_O <: V_S iff
    i32 <: i32
    String <: Object
```

これらの条件は満たされているので、私たちは満足です。

### 分散と関連型

関連型を持つトレイト、または最低でも投影式は、そのすべての入力に対して不変でなければなりません。トレイト参照のサブタイピングが何を意味するかを考えると、これが理にかなっている理由がわかります：

```text
<T as Trait> <: <U as Trait>
```

これは、`T as Trait`を知っている場合、`U as Trait`も知っていることを意味します。さらに、辞書渡しスタイルとして考えると、`<T as Trait>`の辞書は、`<U as Trait>`の辞書が期待される場所で使用しても安全であることを意味します。

問題は、`<T as Trait>`から型を投影できる場合、`<U as Trait>`から投影された型との関係が、`T==U`でない限り完全に不明であるということです（詳細については#21726を参照）。`Trait`を不変にすることで、これが真であることが保証されます。

もう1つの関連する理由は、関連型を持つトレイトを不変にしなかった場合、投影はもはや単一の結果を持つ関数ではなくなることです。次を考えてみましょう：

```rust,ignore
trait Identity { type Out; fn foo(&self); }
impl<T> Identity for T { type Out = T; ... }
```

`<&'static () as Identity>::Out`がある場合、これは任意の`'a`に対して`&'a ()`として有効に導出できます：

```text
<&'a () as Identity> <: <&'static () as Identity>
if &'static () < : &'a ()   -- Identityはselfに対して反変
if 'static : 'a             -- 関係のサブタイピングルール
```

一方、この変更は、`<'static () as Identity>::Out`が常に`&'static ()`であることを意味します（その後、別々に`'a ()`にアップキャストされる可能性があります）。これは#21750の解決に役立ちました。
