# ウォークスルー：典型的なコントリビューション

Rustコンパイラにコントリビュートする方法は_たくさん_あります。バグ修正、パフォーマンス改善、機能の設計支援、既存機能へのフィードバック提供などがあります。この章はそれらの表面をなぞることすら主張しません。代わりに、新しい機能の設計と実装を順を追って説明します。ここで説明するすべてのステップとプロセスがすべてのコントリビューションに必要なわけではなく、それらが発生する際に指摘するように努めます。

一般的に、コントリビューションに興味があり、どこから始めればよいかわからない場合は、遠慮なくお尋ねください！

## 概要

この章で説明する機能は、マクロのための`?` Kleene演算子です。基本的に、次のようなものを書けるようにしたいと考えています：

```rust,ignore
macro_rules! foo {
    ($arg:ident $(, $optional_arg:ident)?) => {
        println!("{}", $arg);

        $(
            println!("{}", $optional_arg);
        )?
    }
}

fn main() {
    let x = 0;
    foo!(x); // ok! "0"を出力
    foo!(x, x); // ok! "0 0"を出力
}
```

つまり、マクロの`$(pat)?`マッチャーは「このパターンは0回または1回出現できる」ことを意味し、他の正規表現構文と同様です。

アイデアから安定したRust機能に至るまでには、いくつかのステップがありました。以下に簡単なリストを示します。これらのそれぞれについて、以下で順を追って説明します。前述のように、これらのすべてがすべてのタイプのコントリビューションに必要なわけではありません。

- **アイデアの議論/Pre-RFC** Pre-RFCは、機能の早期ドラフトまたは設計ディスカッションです。このステージは、設計空間を少し具体化し、アイデアのさまざまなメリットと問題を把握することを目的としています。より広い聴衆に提示する前に、アイデアに対する早期フィードバックを得る素晴らしい方法です。元のディスカッションは[こちら][prerfc]で見つけることができます。
- **RFC** これは、あなたのアイデアをコミュニティに正式に提示して検討してもらうときです。RFCは[こちら][rfc]で見つけることができます。
- **実装** コンパイラでアイデアを不安定に実装します。元の実装は[こちら][impl1]で見つけることができます。
- **反復/洗練の可能性** コミュニティがnightlyコンパイラおよび`std`であなたの機能を体験するにつれて、調整される可能性のある設計選択に関する追加のフィードバックがあるかもしれません。この特定の機能は、多数の[反復][impl2]を[経て][impl3][進みました][impl4]。
- **安定化** 機能が十分に熟成した場合、Rustチームのメンバーが[安定化を提案][merge]する可能性があります。コンセンサスがある場合、これが行われます。
- **リラックス** これであなたの機能は安定したRust機能です！

[prerfc]: https://internals.rust-lang.org/t/pre-rfc-at-most-one-repetition-macro-patterns/6557
[rfc]: https://github.com/rust-lang/rfcs/pull/2298
[impl1]: https://github.com/rust-lang/rust/pull/47752
[impl2]: https://github.com/rust-lang/rust/pull/49719
[impl3]: https://github.com/rust-lang/rust/pull/51336
[impl4]: https://github.com/rust-lang/rust/pull/51587
[merge]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

## Pre-RFCとRFC

> 注意：一般的に、_新しい_機能やRustまたはエコシステムへの大きな変更を提案していない場合は、RFCプロセスに従う必要はありません。代わりに、[実装](#impl)にジャンプできます。
>
> RFCをいつ開くべきかの公式ガイドラインは[こちら][rfcwhen]で見つけることができます。

[rfcwhen]: https://github.com/rust-lang/rfcs#when-you-need-to-follow-this-process

RFCは、提案している機能または変更を詳細に説明するドキュメントです。誰でもRFCを書くことができます。プロセスはすべての人、Rustチームメンバーを含めて同じです。

RFCを開くには、GitHub上の[rust-lang/rfcs](https://github.com/rust-lang/rfcs)リポジトリに対してPRを開きます。詳細な手順は[README](https://github.com/rust-lang/rfcs#what-the-process-is)で見つけることができます。

RFCを開く前に、アイデアを「具体化」するための調査を行う必要があります。急いで提案されたRFCは受け入れられない傾向があります。動機、影響、デメリット、他の機能との潜在的な相互作用について、良い説明をしておく必要があります。

それが多くの作業のように聞こえる場合、それは実際にそうだからです。しかし、心配しないでください！コンパイラハッカーでなくても、_pre-RFC_を行うことで素晴らしいフィードバックを得ることができます。これは、アイデアの_非公式な_ディスカッションです。これを行うのに最適な場所はinternals.rust-lang.orgです。投稿は特定の構造に従う必要はありません。まとまったアイデアである必要すらありません。一般的に、良いRFCを作成するために統合できる大量のフィードバックを得ることができます。

（もう1つのプロのヒント：関連する過去のアイデアのためにRFCsリポジトリとinternalsを検索してみてください。アイデアがすでに検討されていて、拒否されたか、後で再試行するために延期されたことがよくあります。これにより、あなたと他のすべての人の時間を節約できます）

私たちの例の場合、pre-RFCスレッドの参加者が構文の曖昧性と潜在的な解決策を指摘しました。また、全体的なフィードバックは肯定的でした。このケースでは、ディスカッションはかなり迅速に収束しましたが、いくつかのアイデアについては、はるかに多くのディスカッションが発生する可能性があります（たとえば、684件のコメントを受け取った[このRFC][nonascii]を参照してください！）。それが起こった場合、落胆しないでください。それはコミュニティがあなたのアイデアに興味を持っていることを意味しますが、おそらくいくつかの調整が必要です。

[nonascii]: https://github.com/rust-lang/rfcs/pull/2457

`?`マクロ機能のRFCも、RFCスレッドでいくつかのディスカッションを受けました。ほとんどのRFCと同様に、ディスカッションだけでは答えられないいくつかの質問がありました：機能を使用した経験が必要でした。そのような質問はRFCの「未解決の質問」セクションにリストされます。また、RFCディスカッションの過程で、RFC文書自体を更新してディスカッションの経過を反映したい場合があります（たとえば、新しい代替案や過去の作業が追加されたり、提案自体の一部を変更することを決定したりする場合があります）。

最終的に、ディスカッションがコンセンサスに達し、少し落ち着いたように見えたら、Rustチームのメンバーが3つの可能な処分のうちの1つで「最終コメント期間」（FCP）に移行することを提案する場合があります。これは、適切なチームの他のメンバーにRFCをレビューしてコメントしてもらいたいことを意味します。さらにディスカッションが続く可能性があり、それによりさらに多くの変更や未解決の質問が追加される可能性があります。ある時点で、全員が満足すると、RFCはFCPに入ります。これは、人々が異議を唱える最後のチャンスです。FCPが終了すると、処分が採用されます。以下は3つの可能な処分です：

- _マージ_：機能を受け入れます。これは、[`?`マクロ機能][rfcmerge]のマージ提案です。
- _クローズ_：現在の形式でのこの機能はrustに適していません。これがあなたのRFCに起こっても落胆しないでください。個人的に受け取らないでください。これはあなたを反映したものではなく、rustが別の方向に進むというコミュニティの決定です。
- _延期_：この方向に進むことには興味がありますが、今はその時ではありません。これは、適切なRustチームが安定化までのプロセスを通じて機能を導く帯域幅を持っていないために最も頻繁に発生します。多くの場合、これは機能がチームのロードマップに適合しない場合です。延期されたアイデアは後で再訪される可能性があります。

[rfcmerge]: https://github.com/rust-lang/rfcs/pull/2298#issuecomment-360582667

RFCがマージされると、PRはRFCsリポジトリにマージされます。新しい_追跡issue_が[rust-lang/rust]リポジトリに作成され、機能の進捗を追跡し、未解決の質問、実装の進捗、ブロッカーなどについて議論します。これは、[`?`マクロ機能][tracking]の追跡issueです。

[tracking]: https://github.com/rust-lang/rust/issues/48075

<a id="impl"></a>

## 実装

コンパイラに変更を加えるには、[rust-lang/rust]リポジトリに対してPRを開きます。

[rust-lang/rust]: https://github.com/rust-lang/rust

機能/変更/バグ修正/改善によっては、実装は比較的簡単な場合もあれば、大きな取り組みになる場合もあります。より経験豊富なコンパイラ開発者からのヘルプやメンターシップをいつでも依頼できます。また、あなたが機能を実装する必要はありません。しかし、あなたがそうしなければ、他の誰かがするまでしばらくかかるかもしれないことを覚えておいてください。

`?`マクロ機能については、コンパイラのマクロ展開の関連部分を理解する必要がありました。個人的には、[コード内のコメントを改善][comments]することが、それを理解したことを確認するのに役立つ方法であると思いますが、そうしたくない場合はそうする必要はありません。

[comments]: https://github.com/rust-lang/rust/pull/47732

次に、RFCで説明されているとおりに元の機能を[実装][impl1]しました。新しい機能が実装されると、_機能ゲート_の後ろに置かれます。つまり、機能を使用するには`#![feature(my_feature_name)]`を使用する必要があります。機能ゲートは、機能が安定化されると削除されます。

**ほとんどのバグ修正と改善**は機能ゲートを必要としません。変更/改善を行うだけです。

[rust-lang/rust]でPRを開くと、ボットがPRにレビュアーを割り当てます。特定のRustチームメンバーと一緒に作業している場合、スレッドに`r? @reviewer-github-id`のようなコメントを残すことでそのレビュアーをリクエストできます（たとえば、`r? @eddyb`）。誰にリクエストすればよいかわからない場合は、誰もリクエストしないでください。ボットは、変更したファイルに基づいて自動的に誰かを割り当てます。

レビュアーは、PRを承認する前に変更をリクエストする場合があります。コメントを残した後、PRに「S-waiting-on-author」ラベルをマークする場合があります。これは、PRが要求された変更を行うためにあなたがブロックされていることを意味します。変更の反復が完了したら、`@rustbot ready`のコメントを残すことで、PRを再び`S-waiting-on-review`としてマークできます。これにより、`S-waiting-on-author`ラベルが削除され、`S-waiting-on-review`ラベルが追加されます。

質問をしたり、理解できないことや同意できないことについて議論したりすることは自由です。ただし、Rustチームの誰かが承認しない限り、PRはマージされないことを認識してください。レビュアーが`r=me after fixing ...`のようなコメントを残した場合、それは彼らがPRを承認し、些細な問題を修正した後にマージできることを意味します。`@bors r=reviewer-github-id`（例：`@bors r=eddyb`）のコメントでマージできます。`r=someone`には許可が必要で、`r=someone`とコメントすると、borsが「🔑 Insufficient privileges...」のようなことを言う可能性があることに注意してください。その場合は、レビュアーにPRを再訪するように依頼する必要があります。

レビュアーがPRを承認すると、それは`@bors`という別のボットのキューに入ります。`@bors`はCI ビルド/マージキューを管理します。PRが`@bors`キューの先頭に達すると、`@bors`はGitHub Actions上でPRに対してすべてのテストを実行してマージをテストします。これは完了するのに多くの時間がかかります。すべてのテストが合格すると、PRはマージされ、次のnightlyコンパイラの一部になります！

レビュープロセス中にいくつかのPRで発生する可能性のあることがいくつかあります

- 変更が十分に実質的である場合、レビュアーはPR上でFCPをリクエストする場合があります。これにより、適切なチームのすべてのメンバーに変更をレビューする機会が与えられます。
- 変更が破壊を引き起こす可能性がある場合、レビュアーは[crater]実行をリクエストする場合があります。これは、変更を加えたコンパイラをコンパイルし、次に変更されたコンパイラでcrates.io上のすべてのクレートをコンパイルしようとします。これは、エコシステムの大部分に影響を与えるコンパイラの動作への変更を導入したかどうかをチェックする素晴らしいスモークテストです。
- PRのdiffが大きい場合、またはレビュアーが忙しい場合、PRは最初にマージされた他のPRとマージの競合がある可能性があります。通常のgit手順を使用してこれらのマージ競合を修正する必要があります。

[crater]: ./tests/crater.html

新しい機能やそのようなものをしていない場合（たとえば、バグを修正している場合）、それで終わりです！コントリビューションありがとうございます :)

## 実装の洗練

人々がnightlyで新しい機能を体験するにつれて、わずかな変更が提案され、未解決の質問が解決される可能性があります。更新/変更は、上記で説明したように、他の変更を実装するための同じプロセスを経ます（つまり、PRを提出し、レビューを経て、`@bors`を待つなど）。

一部の変更は、FCPとRustチームメンバーによるレビューが必要なほど大きい場合があります。

`?`マクロ機能については、元の実装の後、いくつかの異なる反復を経ました：[1][impl2]、[2][impl3]、[3][impl4]。

その過程で、`?`はセパレータを取るべきではないと決定しました。これはRFCにリストされていた以前の未解決の質問でした。また、曖昧性解消戦略を変更しました：他の繰り返し演算子（たとえば、`+`または`*`）のセパレータトークンとして`?`を使用する機能を削除することにしました。ただし、これは破壊的変更であったため、エディション境界を越えて行うことにしました。したがって、新しい機能はエディション2018でのみ有効にできます。これらの元のRFCからの逸脱には、[別のFCP](https://github.com/rust-lang/rust/issues/51934)が必要でした。

## 安定化

最後に、機能がnightlyで十分に熟成した後、言語チームのメンバーが[安定化を移行][stabilizefcp]しました。

[stabilizefcp]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433177613

_安定化レポート_を書く必要があります。これには次が含まれます

- 動作の簡単な説明とRFCからの逸脱
- 影響を受けるエディションと方法
- 興味深い側面を示すためのいくつかのテストへのリンク

私たちの機能の安定化レポートは[こちら][stabrep]です。

[stabrep]: https://github.com/rust-lang/rust/issues/48075#issuecomment-433243048

この後、機能ゲートを削除してデフォルトで機能を有効にする（2018エディションで）ために[PRが作成されます][stab]。機能に関するメモが[リリースノート][relnotes]に追加されます。

[stab]: https://github.com/rust-lang/rust/pull/56245

機能を安定化する手順は、[機能の安定化](./stabilization_guide.md)で見つけることができます。

[relnotes]: https://github.com/rust-lang/rust/blob/HEAD/RELEASES.md
